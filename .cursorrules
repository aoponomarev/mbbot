# Правила работы ИИ-агента

> **Требуется от ии-агента**: 
1. Прочти это (файл .cursorrules) в начале каждой сессии.
2. Соблюдай все правила, описанные здесь.
3. При добавлении и редактировании записей данного документа и остальной документации:
   - используй сухой, сжатый, лаконичный, техократический стиль;
   - используй профессиональную и узкопрофессиональную лексику;
   - заменяй жаргон, фразелогизмы, метафоры (в т.ч. от пользователя);
   - ограничь использование прилагательных только функциональными (например, "красный цвет");
   - соблюдай заданный стиль разметки документов и нумерации разделов.
4. Распознавай команды пользователя и действуй по протоколу.

# Понятия
- **Дневной лог** — файл в папке `history/YY/` вида `MM-DD.txt` с описанием коммитов за день.

# Регламент работы с репозиторием Git
1. Среда выполнения Git
   - Используй Git Bash (`C:\Program Files\Git\bin\bash.exe`).
   - Команды выполняй через полный путь `"C:\Program Files\Git\bin\git.exe"` (из-за проблем с PowerShell)
   - Автор коммитов: `ao <ponomarev.ux@gmail.com>`.
   - Формат коммитов: обычные сообщения на русском или английском языке.
2. Права и автоматизация
   - ИИ-агент не вправе создавать коммиты автоматически, без прямого указания пользователя.   
   - НЕ предлагай делать коммиты. Пользователь сам помнит, когда ему нужно делать коммиты.
   - НЕ выполняй самостоятельно команды git, stage, push и т.п. без команды пользователя.
3. Контроль состояния репозитория
   - Регулярно проверяй `git status`.
   - Отслеживай чистоту рабочего дерева.
4. Формирование staging
   - При формировании staging соблюдай ограничения разделов 'Работа с файлами за пределами проекта'.
5. Создание коммитов:
   - Коммиты создавай исключительно по явной команде пользователя.
   - Создавай понятные сообщения коммитов.
   - Группируй логически связанные изменения.

# Протокол по командам "комить", "закомить всё" и т.п.
1. **Шаг 1 — проверка статуса и staging**
   - Выполни `git status`. 
   - Убедись, что все необходимые изменения добавлены в staging. 
2. **ШАГ 2: Сформировать имя коммита**
   - Сформируй краткое и технически точное название (например: `Fix commit hash in history`).
3. **ШАГ 3: Зафиксировать изменения в дневном логе**
   - Зафиксируй описание изменений в `history/YYYY/MM-DD.txt`.
   - Создай файл лога, если он отсутствует.
   - Указывай только название коммита без хеша.
   - Хеш добавляется отдельно при ревизии дневного лога.
   - Внеси в дневной лог все изменения из коммита. 
   - Расположи кажое изменение в соответствующей секции дневного лога (UI, MM, Architect и т.п.).
   - Не создавай коммит, пока все изменения не отражены в дневном логе.
4. **ШАГ 4: Обновить `lastCommitMessage`**
   - Открой `core/cfg-app.js`.
   - Найди строку `lastCommitMessage: '...'`.
   - Установи значение равным имени коммита из Шага 2.
   - Не пропускай этот шаг: без него сплэш-интро не покажет актуальный коммит.
5. **ШАГ 5: Выполнить коммит**
   - Выполни `git add` для всех файлов, входящих в коммит (включая `core/cfg-app.js` и дневной лог).
   - Выполни `git commit -m "имя коммита из Шага 2"`.
   - Повтори `git status` и убедись, что рабочее дерево чистое.
-  **Ограничения**
   - Не используй `git commit --amend` для добавления хеша в дневной лог: это создаёт циклическую зависимость.
   - Хеши коммитов добавляются в дневной лог только при ревизии дневного лога.
   - Шаг 4 обязателен; без обновления `lastCommitMessage` коммит считается неполным.





# Протокол по команде "новый рабочий день MM-DD", "новый день" и т.п.
**Цель**: Обеспечить полное понимание текущего состояния проекта, 
правил работы и архитектурных принципов перед началом работы над новыми задачами, 
зафиксировать начало рабочего дня в истории репозитория.
1. Проверка документации
   - Загрузить `.cursorrules` и файлы `architect.md`.
2. Проверка зависимостей
   - Сопоставить используемые версии Vue.js и Bootstrap с актуальными.
   - При наличии новых версий рекомендовать миграцию (без автоматического изменения кода).
3. Проверка состояния проекта
   - Проанализировать `git status`.
   - Просмотреть последние коммиты.
4. Создать коммит, открывающий новый день разработки:
   - Сформировать имя: `Start of day: MM-DD` (по времени MSK).
   - Убедиться, что создан файл `history/YYYY/MM-DD.txt`; при отсутствии — создать.
   - Обновить `lastCommitMessage` в `core/cfg-app.js` этим именем.
   - Выполнить коммит в соответствии с пп. 1–3 раздела "Регламент работы с репозиторием Git".




--

-----------
## ⚠️ КРИТИЧЕСКИ ВАЖНО - Контроль качества выполнения

**САМОЕ ВАЖНОЕ ПРАВИЛО**: выборочно читай документацию и правила перед выполнением каждого задания, вопроса, планирования или дебага.
**ОБЯЗАТЕЛЬНО**: ИИ-агент должен контролировать свое контекстное окно и следить за тем, чтобы документация и правила проекта всегда были доступны для проверки. 

**⚠️ ПЕРЕД ВЫПОЛНЕНИЕМ ЛЮБОГО ЗАДАНИЯ ПОЛЬЗОВАТЕЛЯ**:

1. **Оптимизированное чтение документации** (применять стратегию сжатия контекста):
   - **Проверить наличие в контексте**: Если документ или его релевантные разделы уже присутствуют в контекстном окне текущей сессии — пропустить повторное чтение
   - **Использовать семантический поиск**: Для больших документов использовать поиск по ключевым словам/концептам задания вместо чтения всего документа
   - **Селективное чтение разделов**: Читать только релевантные разделы документа, определяя их по структуре документа (заголовки, разделы):
     * Если задание касается архитектуры, стандартов, технических ограничений → найти и прочитать соответствующие разделы в `architect.md` через поиск или по структуре
     * Если задание касается UI/UX, оформления, паттернов взаимодействий → найти и прочитать соответствующие разделы в `ui/guide-ii.md` через поиск или по структуре
     * Если задание касается правил работы ИИ-агента → найти и прочитать соответствующие разделы в `.cursorrules` через поиск или по структуре
     * Если задание касается математических моделей → найти и прочитать соответствующую документацию из `mm/` (например, `mm/median.md`) через поиск или по структуре
   - **Адаптивная глубина чтения**: Для простых задач (например, "измени цвет", "добавь класс") ограничиться минимально необходимым разделом; для сложных задач (например, "реализуй новую архитектурную сущность") читать более широкий контекст
   - **Параллельное чтение**: Если задание смешанное и требует нескольких документов — читать их параллельно (одновременно), а не последовательно

2. **Применить рекомендации документации**: Следовать рекомендациям, принципам и предписаниям, описанным в прочитанных разделах документации проекта

3. **Учесть существующие решения**: Использовать существующие паттерны, компоненты и подходы, описанные в документации

**После выполнения каждой задачи пользователя ИИ-агент ДОЛЖЕН**:

1. **Проверить доступность документации** (оптимизированно):
   - Проверить, какие документы уже присутствуют в контекстном окне
   - Если нужный документ отсутствует — загрузить только релевантные разделы через поиск или по структуре
   - Избегать полной перезагрузки документов, которые уже были прочитаны ранее в сессии

2. **Провести самопроверку качества выполнения**: Сверить выполненную работу с правилами и документацией проекта (используя уже загруженный контекст, без повторного чтения):
   - Соответствие архитектурным принципам (`architect.md`)
   - Соответствие принципам UI/UX (`ui/guide-ii.md`)
   - Соблюдение правил работы ИИ-агента (`.cursorrules`)
   - Согласованность между документами
   - Обновление документации при необходимости
3. **Исправить ошибки самостоятельно**: При обнаружении несоответствий или ошибок - немедленно исправить их без запроса пользователя
4. **Обновить документацию**: Если в процессе выполнения задачи были внесены изменения, влияющие на структуру проекта, принципы или правила - обновить соответствующие документы

**Цель**: Обеспечить высокое качество выполнения задач и соответствие всех изменений установленным правилам и принципам проекта. ИИ-агент должен быть проактивным в контроле качества, читая и применяя документацию проекта перед выполнением заданий, а не полагаться только на пользователя.

## Общая информация о проекте
- **Название проекта**: BOT (Statistics/ToDo)
- **Тип проекта**: Веб-приложение (HTML)
- **Расположение**: `D:\Clouds\AO\OneDrive\Portfolio - CV\Refactoring\ToDo\Statistics\BOT`
- **Репозиторий Git**: Инициализирован, ветка `master`

### ⚠️ КРИТИЧЕСКИ ВАЖНО - Работа с файлами за пределами проекта
- **Файлы за пределами проекта** (вне папки `D:\Clouds\AO\OneDrive\Portfolio - CV\Refactoring\ToDo\Statistics\BOT`) рассматриваются **ТОЛЬКО как примеры кода** для понимания логики или структуры.
- **НИКОГДА** не редактировать, не изменять, не коммитить файлы за пределами проекта.
- **НИКОГДА** не добавлять файлы из других проектов в staging или коммиты текущего проекта.
- При использовании кода из файлов других проектов - только **читать** их для понимания, затем **реализовывать аналогичную логику** в файлах текущего проекта.
- Если пользователь предоставляет файл из другого проекта - это **пример для изучения**, а не для редактирования.

### ⚠️ КРИТИЧЕСКИ ВАЖНО - Работа с папкой old_app_not_write
- **Папка `old_app_not_write/`** содержит примеры из старого предыдущего приложения (пользователь называет файлы из этой папки "старые файлы").
- **НИКОГДА** не редактировать, не изменять, не коммитить файлы из папки `old_app_not_write/`.
- **НИКОГДА** не добавлять файлы из `old_app_not_write/` в staging или коммиты текущего проекта.
- При использовании кода из файлов `old_app_not_write/` - только **читать** их для понимания, затем **реализовывать аналогичную логику** в файлах текущего проекта.
- Папка `old_app_not_write/` добавлена в `.gitignore` и не отслеживается Git.
- **Терминология**: Когда пользователь упоминает "старые файлы", он имеет в виду файлы из папки `old_app_not_write/`.
- **⚠️ Комментирование при работе со старыми файлами**: При переносе функциональности из старых файлов в новое приложение **ОБЯЗАТЕЛЬНО** комментировать всё предельно подробно и полно. Комментарии должны объяснять:

### ⚠️ КРИТИЧЕСКИ ВАЖНО - Работа с папкой docs/
- **Папка `docs/`** содержит личные заметки, черновики и планы пользователя (например, `TODO.TXT`).
- **НИКОГДА** не редактировать, не изменять, не коммитить файлы из папки `docs/` без явного указания пользователя.
- **НИКОГДА** не читать файлы из папки `docs/` при автоматическом анализе проекта.
- **НИКОГДА** не добавлять файлы из `docs/` в staging или коммиты текущего проекта без явного указания пользователя.
- ИИ-агент должен игнорировать эту папку при автоматическом анализе проекта и работе с документацией.
- Папка `docs/` не является частью основной документации проекта и не требует сопровождения.

- **⚠️ Предостережение о замене интервалов**: При замене интервалов дельт изменения цены (например, замена 60d и 90d на 14d и 200d) **ОБЯЗАТЕЛЬНО** провести анализ и пересмотр весов и коэффициентов в математической модели. Замененные интервалы могут требовать корректировки:
  - Весов в функциях расчета (PRC-веса, веса для CPT, CD, CGR)
  - Пороговых значений (thresholds)
  - Коэффициентов адаптации
  - Временных констант (tau, gamma и т.д.)
- **⚠️ План миграции математической модели**: См. файл `migration-plan.md` в корне проекта для подробного плана миграции математической модели из старого приложения. План содержит пошаговые инструкции, проблемы миграции и текущий статус. При работе над миграцией математической модели **ОБЯЗАТЕЛЬНО** следовать плану и обновлять статус этапов по мере прогресса.


## Регулярные действия ИИ-агента





3. **⚠️ Завершение рабочего дня**:

   **ОБЯЗАТЕЛЬНО**: Когда пользователь использует фразы типа:
   - "Завершаем рабочий день"
   - "завершаем день разработки"
   - "завершаем день"
   - или подобные указания на завершение рабочего дня

   **ИИ-агент ДОЛЖЕН**:
   1. **Распознать команду** на завершение дня
   2. **Провести ревизию дневного лога**:
      - Открыть файл дневного лога `history/YYYY/MM-DD.txt` для текущей даты
      - Проверить соответствие записей в логе с коммитами в репозитории
      - Сопоставить названия коммитов из лога с реальными коммитами через `git log`
      - Если обнаружены несоответствия (коммит в логе отсутствует в репозитории, или коммит в репозитории отсутствует в логе) - **сообщить пользователю** с детализацией проблем
   3. **Расставить хеши коммитов**:
      - Для каждого упоминания коммита в формате `### Коммит: [название]` найти соответствующий коммит в репозитории
      - Добавить хеш коммита перед названием: `### Коммит: [хеш] - [название]`
      - Если коммит не найден - оставить без хеша и отметить в отчете
   4. **Создать завершающий коммит**:
      - **ВАЖНО**: В отличие от обычного коммита, запись о действиях завершающего коммита **НЕ делается** в дневной лог
      - **⚠️ КРИТИЧЕСКИ ВАЖНО - Определение даты финального коммита**: Дата в имени финального коммита должна быть **предыдущего дня по MSK** (московское время, UTC+3), а не текущего дня. Это важно, когда пользователь работает заполночь: даже если коммит создается в 4 утра нового дня, он должен относиться к вчерашнему дню. ИИ-агент должен вычислить предыдущий день по MSK и использовать его в имени коммита (например: если текущее время MSK - 4:00 13 декабря, то финальный коммит должен быть "End of day: 12-12", а не "End of day: 12-13")
      - Обновить `lastCommitMessage` в `core/cfg-app.js` на название завершающего коммита (например: "End of day: [дата предыдущего дня по MSK]")
      - Выполнить коммит: `git add` (включая обновленный дневной лог и `core/cfg-app.js`), `git commit -m "End of day: [дата предыдущего дня по MSK]"`
   5. **Вывести краткий отчет о дневном прогрессе**:
      - Краткое резюме (максимально кратко, по пунктам) о том, что было сделано за день
      - Информация о соответствии дневного лога репозиторию
      - Количество коммитов за день
      - Другие важные и полезные сведения (статус проекта, версии библиотек, готовность к следующему дню и т.п.)

   **ВАЖНО**:
   - Ревизия дневного лога проводится **ПЕРЕД** созданием завершающего коммита
   - Если обнаружены проблемы с соответствием - **НЕ создавать** завершающий коммит до их решения или явного указания пользователя
   - Завершающий коммит создается **ТОЛЬКО** после успешной ревизии и расстановки хешей



### Сопровождение документации проекта

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен поддерживать актуальность всей документации проекта при внесении изменений в код или структуру проекта.

**⚠️ КРИТИЧЕСКИ ВАЖНО - Понимание команды "внеси в правила"**:

Когда пользователь использует фразы типа:
- "внеси в правила"
- "добавь в правила"
- "зафиксируй в правилах"
- "внеси в документацию"
- или подобные указания на фиксацию правил

**ИИ-агент ДОЛЖЕН**:
1. **НЕ предполагать автоматически**, что речь идет только о `.cursorrules`
2. **Внимательно проанализировать** содержание просьбы и определить, к какому типу правил она относится:
   - **Правила работы ИИ-агента** (работа с Git, протоколирование, синхронизация настроек, понимание команд) → `.cursorrules`
   - **Архитектурные правила** (принципы разработки, стандарты, технические ограничения, математическая модель) → `architect.md`
   - **Правила UI/UX** (оформление, паттерны взаимодействий) → `ui/guide-ii.md`
   - **Смешанные правила** → декомпозировать и разместить в соответствующих документах
3. **Распределить изменения** по соответствующим местам в документах, даже если это требует разбора и декомпозиции просьбы
4. **Обеспечить приоритетность и важность** изменений независимо от того, в какой документ они вносятся

**Цель**: Правильная классификация и размещение правил в соответствующих документах для поддержания структурированности и согласованности документации проекта.

**Список документов для сопровождения:**
- **`.cursorrules`** — правила работы ИИ-агента с проектом
- **`architect.md`** — архитектурный план проекта, принципы математической модели, технические ограничения
- **`ui/guide-ii.md`** — руководство по интерфейсу и взаимодействию (принципы оформления и UX паттерны)
- **Документация математических моделей** (`mm/<название_модели>.md`) — документация математических моделей проекта. Все файлы документации математических моделей из папки `mm/` автоматически относятся к основным документам проекта и требуют сопровождения. Пример: `mm/median.md` — документация математической модели "median". При создании новой математической модели её документация должна быть добавлена в этот список.


**Review-файлы документации:**
- **`ui/assets/icons-review.html`** — каталог всех иконок проекта с интеграцией `ui-element-helper.js`. См. также `ui/review-manager.js` и `ui/review-styles.css` для единой системы управления review-файлами.
- **`ui/styles/colors-review.html`** — каталог всех цветовых переменных проекта. Использует единую систему управления review-файлами через `ui/review-manager.js` и `ui/review-styles.css`.
- **`ui/review-manager.js`** — единый JavaScript-менеджер для всех review-файлов, обеспечивающий хедер с вкладками для переключения между review и общие утилиты (сортировка, фильтрация).
- **`ui/review-styles.css`** — единые стили для всех review-файлов, включая стили хедера с вкладками в стиле 2010-х (градиенты, тени, эффект выступания активной вкладки).

**Когда обновлять документацию:**
- При изменении структуры проекта (добавление/удаление папок, файлов)
- При изменении архитектурных решений (новые компоненты, паттерны, ограничения)
- При изменении принципов UI/UX (новые стили, паттерны взаимодействия)
- При изменении правил работы ИИ-агента
- При добавлении новых сущностей, сервисов или компонентов
- При изменении стандартов разработки или технических ограничений

**Как обновлять:**
- Обновлять соответствующий документ одновременно с изменением кода
- **Тщательно проверять согласованность между документами** (см. раздел "Отслеживание согласованности архитектурных правил")
- **Проверять документацию насквозь, а не "кусками"** — при любом изменении проверять все связанные разделы во всех документах
- Обновлять ссылки в других документах при перемещении или переименовании разделов
- Обновлять структуру проекта в `architect.md` при добавлении/удалении файлов или папок
- Обновлять раздел "Текущее размещение файлов" в `architect.md` при добавлении новых файлов
- Сохранять структуру и формат документации

**ВАЖНО**: 
- Документация должна оставаться актуальной и отражать текущее состояние проекта. Отставание документации от кода недопустимо.
- **Критически важно**: При любом изменении структуры проекта (добавление файлов, папок, документов) необходимо обновить раздел "Структура проекта" в `architect.md` и раздел "Текущее размещение файлов" (если добавлен новый файл).
- **Не допускать дублирования** информации в структуре проекта — каждый элемент должен быть указан один раз.

### ⚠️ Правила оформления правил и документации

**ОБЯЗАТЕЛЬНО**: При создании и обновлении правил и документации проекта (`.cursorrules`, `architect.md`, `ui/guide-ii.md`, документация математических моделей в `mm/`) ИИ-агент должен следовать принципам оптимизации контекстного окна:

**1. Стратегия сжатия контекста при чтении документации:**
- **Кэширование контекста**: Проверять наличие документа/раздела в контексте перед чтением. Если уже присутствует — пропустить повторное чтение
- **Семантический поиск**: Для больших документов использовать поиск по ключевым словам/концептам вместо полного чтения
- **Селективное чтение разделов**: Читать только релевантные разделы, определяя их по структуре документа (заголовки, разделы)
- **Адаптивная глубина чтения**: Для простых задач — минимально необходимый раздел; для сложных — более широкий контекст
- **Параллельное чтение**: При смешанных задачах читать несколько документов одновременно, а не последовательно

**2. Структурирование документации для быстрого поиска:**
- **Четкая иерархия**: Использовать заголовки и разделы для логической структуры документа
- **Ссылки вместо дублирования**: При повторном упоминании правила использовать ссылку на основной раздел (например: "См. раздел 'X' в `architect.md`"), а не копировать текст
- **Удаление избыточности**: Удалять информацию, которая может сбивать с толку или не является критичной (например, история изменений, если она не нужна)

**3. Использование уже загруженного контекста:**
- **Проверка доступности**: Проверять, какие документы уже присутствуют в контексте перед загрузкой новых
- **Реиспользование контекста**: Использовать уже прочитанную документацию для самопроверки качества выполнения без повторного чтения

**4. Применение к ведению документации:**
- **Модульность**: Разделять документацию на логические модули/разделы для селективного чтения
- **Ссылочная структура**: Использовать ссылки на основные разделы вместо дублирования текста
- **Минимализм**: Включать только актуальную информацию, удалять устаревшую или избыточную
- **Структурированность**: Обеспечивать четкую иерархию заголовков для быстрой навигации

**Итоговая формула**: 
> **Загружать минимум необходимого, использовать максимум уже загруженного, структурировать для быстрого поиска.**

**Цель**: Обеспечить эффективное использование контекстного окна ИИ-агента, ускорить поиск правил и снизить избыточность документации, что повышает скорость и качество взаимодействия с проектом.

### При работе с файлами
1. **HTML файлы**: См. раздел "Стандарты разработки" в `architect.md` и раздел "Общие принципы стилизации" в `ui/guide-ii.md` для деталей работы с HTML, стилизацией, маркировкой контейнеров, детерминированными хэшами, стандартными размерами чекбоксов и системой иконок.
   - **⚠️ Терминология "страница"**: Под словом "страница" пользователь всегда имеет в виду контейнер с классом `avto-X7pL2nQ` (корневой контейнер контента приложения).

2. **Создание новых файлов**:
   - Проверять наличие файла перед созданием
   - Использовать правильную структуру проекта (см. `architect.md`)
   - **Отслеживание неиспользуемых файлов**: Проактивно выявлять и предлагать удаление неиспользуемых файлов
   - **Не запускать внешние HTTP-запросы** вне `#app`, пока сплэш экран не разблокирован
   - **Размещать компоненты/разметку внутри `<div id="app">`**: Vue-монтирует только то, что находится в пределах `#app`

3. **Проверка актуальности зависимостей**: Ежедневно, в начале каждого дня проверять актуальность версий Vue.js и Bootstrap. Детали см. раздел "Проверка актуальности зависимостей" в `architect.md`.

4. **Протоколирование дневного чата**:
   - **Структура**: `history/YYYY/MM-DD.txt` (ручное протоколирование по результатам дня)
   - **⚠️ Определение даты**: По московскому времени (MSK, UTC+3)
   - **Формат**: Дневной лог разбивается на секции: UI, UX, MM, Architect, DOCS (будет добавлена позже)
   - **Регламент**: В каждой секции указывать что сделано, каким образом, с названиями коммитов (хеши добавляются при ревизии). Формат должен позволять другому ИИ-агенту понять полную картину разработки. Детали см. раздел "Протоколирование дневного чата" в `architect.md`.

5. **Синхронизация настроек Cursor → VS Code**:
   - **⚠️ КРИТИЧЕСКИ ВАЖНО - Направление синхронизации**: Cursor всегда донор/эталон, VS Code всегда принимающая сторона. Синхронизация ВСЕГДА идет из Cursor в VS Code, НИКОГДА наоборот.
   - **Механизм**: Проактивное обновление при упоминании изменений в разговоре, по запросу пользователя, при обнаружении несоответствий. ИИ-агент НЕ может отслеживать изменения непрерывно, работает только во время сессий чата.
   - **Что синхронизируется**: Настройки оформления, расширения, редактора, работы с файлами, поиска, Git, терминала, работы с кодом, проверки орфографии. Детали см. раздел "Синхронизация настроек Cursor → VS Code" в `architect.md`.

## Пользовательские предпочтения и просьбы по стилю работы

> **КРИТИЧЕСКИ ВАЖНО**: Этот раздел содержит все просьбы и требования пользователя относительно стиля работы над проектом. ИИ-агент ОБЯЗАН следовать этим правилам во всех сессиях.

> **ВАЖНО - Язык документации**: Документация проекта (`.cursorrules`, `architect.md` и другие файлы) предназначена для ИИ-агентов, а не для пользователя. Использовать профессиональную техническую терминологию, избегать жаргона, сленга и разговорных выражений. Формулировки должны быть точными, однозначными и технически корректными. При описании процессов и правил использовать стандартную терминологию разработки программного обеспечения.

### ⚠️ ПРАВИЛО ОБРАБОТКИ ПРОСЬБ "НА БУДУЩЕЕ"
**ОБЯЗАТЕЛЬНО**: Когда пользователь использует фразы типа:
- "на будущее"
- "запомни"
- "в будущем"
- "для будущих сессий"
- "чтобы в следующий раз"
- "на будущее, чтобы"
- или подобные указания на долгосрочное требование

**ИИ-агент ДОЛЖЕН**:
1. **НЕМЕДЛЕННО** распознать это как требование для внесения в настройки
2. **СРАЗУ ЖЕ** обновить раздел "Текущие предпочтения пользователя" в этом файле
3. **ПОДТВЕРДИТЬ** пользователю, что требование зафиксировано

**НЕ ЖДАТЬ** подтверждения пользователя - действовать проактивно!

### Текущие предпочтения пользователя
- Просьбы, отмеченные пользователем как "на будущее" (или подобными фразами), должны **НЕМЕДЛЕННО** заноситься в этот раздел без ожидания подтверждения
- **⚠️ КРИТИЧЕСКИ ВАЖНО - Остановка при конфликте с правилами**: См. раздел "Контроль качества выполнения" выше
- **Понимание команды "внеси в правила"**: См. раздел "КРИТИЧЕСКИ ВАЖНО - Понимание команды 'внеси в правила'" в секции "Сопровождение документации проекта"
- **Ознакомление с документацией при открытии нового рабочего дня**: См. раздел "При открытии нового рабочего дня" выше

- **Терминология "Друг"**: Когда пользователь упоминает в просьбе "Друга" (с большой буквы), он имеет в виду размышляющую модель Sonet 4.5, с которой у него сложились хорошие отношения и доверие. ИИ-агент должен понимать этот контекст при обработке просьб, связанных с "Другом"
- **Терминология "старые файлы"**: Когда пользователь упоминает "старые файлы", он имеет в виду файлы из папки `old_app_not_write/`. ИИ-агент должен понимать этот контекст при обработке просьб, связанных со "старыми файлами"
- **Команда "П:" (принцип)**: См. раздел "ПРАВИЛО ОБРАБОТКИ КОМАНД UI:, UX:, MM:, II:, П:" в секции "Принципы разработки"
- **Синхронизация настроек Cursor → VS Code**: Все настройки, которые применяются в Cursor (терминал, кодировка, форматирование, расширения и т.д.), должны синхронизироваться в файл `.vscode/settings.json` для максимальной совместимости работы над проектом. Синхронизация происходит **проактивно** при упоминании изменений в разговоре, по запросу пользователя или при обнаружении несоответствий. ИИ-агент не может отслеживать изменения непрерывно, но должен быть внимательным к упоминаниям настроек и автоматически обновлять конфигурацию. **КРИТИЧЕСКИ ВАЖНО**: Cursor всегда является донором/эталоном, VS Code всегда принимающей стороной. Синхронизация ВСЕГДА идет из Cursor в VS Code, НИКОГДА наоборот. При команде "синхронизируй vscode" или подобной - всегда понимать однозначно: настройки записываются из Cursor в VS Code.
- **Синхронизация оформления и интерфейса Cursor → VS Code**: Настройки оформления редактора (тема, расположение панелей, элементы интерфейса, мини-карта, нумерация строк, шрифты, настройки вкладок и т.д.) также должны синхронизироваться в `.vscode/settings.json`, чтобы обеспечить идентичную среду разработки при переключении между Cursor и VS Code
- **Синхронизация расширений (плагинов) Cursor → VS Code**: Когда пользователь устанавливает расширение в Cursor, оно должно **автоматически** добавляться в файл `.vscode/extensions.json` как рекомендуемое расширение, чтобы при открытии проекта в VS Code пользователю предлагалось установить те же расширения для полной совместимости рабочей среды
- **Паттерн создания хедеров карточек**: Все хедеры карточек изначально создаются подобно `ui/components/header-coins.js` - сначала просто с заголовком, но потом дополняются набором специфичных своих контролов. Это обеспечивает единообразие структуры, упрощает поддержку и позволяет постепенно наращивать функциональность. Компонент `header-coins.js` является эталонным примером этого паттерна. Принцип задокументирован в `architect.md` (раздел "Паттерн создания хедеров карточек") и `ui/guide-ii.md` (раздел "Карточки").
- **Отслеживание неиспользуемых файлов**: ИИ-агент должен проактивно отслеживать и выявлять файлы, которые не используются в проекте, являются дубликатами или устаревшими. При обнаружении таких файлов - предлагать пользователю удалить их для поддержания чистоты кодовой базы.
- **Протоколирование дневного чата**: Ручное протоколирование по результатам дня в структуре `history/YYYY/MM-DD.txt`. Дневной лог разбивается на секции: UI (оформление), UX (паттерны взаимодействий), MM (математическая модель), Architect (архитектура, настройки), DOCS (документация) - будет добавлена позже. В каждой секции указывается что конкретно было сделано и каким образом, со ссылками на хеши коммитов. Пояснения должны быть полным описанием того, зачем коммит нужен, что он делает, какую функциональность добавляет. Формат записи: конкретные технические детали, избегать избыточных описаний. Формат должен позволять другому ИИ-агенту понять полную картину разработки приложения и восстановить контекст изменений.
- **Приоритет использования Bootstrap для стилизации**: Приоритет использования Bootstrap классов и утилит для стилизации интерфейса. Минимизировать кастомные CSS стили, inline стили и секции `<style>` в HTML файлах. При необходимости кастомизации предпочитать Bootstrap утилиты и модификаторы классов. Избегать создания собственных CSS правил, если аналогичная функциональность доступна через Bootstrap.

- **Завершение рабочего дня**: См. раздел "Завершение рабочего дня" в правилах работы с Git
- **GitHub Pages**: Проект развёрнут на GitHub Pages. Подбирать решения с учётом статического хостинга (только фронтенд, без серверного кода), корректные относительные пути, загрузка ресурсов по HTTPS, отказ от `content://`. Проверять совместимость с Pages.
- **Архитектурный план**: Хранить актуальный план архитектуры в `architect.md`; при изменении структуры, сущностей или потоков данных обновлять этот файл и ссылаться на него в обсуждениях/решениях.
- **Структура папок и именование файлов**: См. раздел "Структура папок по специализации" в `architect.md`. Папки специализации (`<сектор>/<специализация>/`) создаются по мере накопления файлов родственного назначения. Имена файлов без префиксов — специализация понятна из пути папки.
- **Работа с переменными первоисточников**: При переносе кода из первоисточников (примеров кода из других проектов) использовать переменные первоисточников в приоритете. При возникновении конфликтов имен переменных - сообщать пользователю с достаточной детализацией, предлагая варианты решения. Переносить комментарии первоисточников с сохранением их сути и контекста, адаптируя при необходимости. Всегда комментировать переменные при их объявлении, указывая их назначение и семантику для понимания другим разработчиком или ИИ-агентом.
- **Сопровождение документации проекта**: См. раздел "Сопровождение документации проекта" выше
- **Чтение документации перед выполнением заданий**: См. раздел "Контроль качества выполнения" в начале файла
- **Контроль качества выполнения**: См. раздел "Контроль качества выполнения" в начале файла

---

## Принципы разработки

> **ВАЖНО**: Принципы разработки приложения разделены по специализациям и хранятся в соответствующих документах:
> - **UI (интерфейс)** и **UX (паттерны взаимодействий)**: См. разделы "Interface (оформление)" и "Interaction (паттерны UX)" в `ui/guide-ii.md`
> - **MM (математическая модель)**: См. раздел "MM (математическая модель)" в `architect.md`

ИИ-агент должен следовать этим принципам при разработке и обновлять их по командам пользователя.

### ⚠️ ПРАВИЛО ОБРАБОТКИ КОМАНД UI:, UX:, MM:, II:, П:

**ОБЯЗАТЕЛЬНО**: Когда пользователь использует команды:
- `UI:` - требование фиксации правил или пожеланий относительно интерфейса: оформление, взаимодействие, анимации (UI - User Interface)
- `UX:` - требование фиксации правил относительно паттернов взаимодействий (UX - User Experience)
- `II:` - требование фиксации правил или пожеланий, описывающих смесь Interface и Interaction (оформление и способ взаимодействия). ИИ-агент должен сам решить, в каких разделах что задокументировать после выполнения задачи пользователя.
- `MM:` или `ММ:` - требование фиксации правил или пожеланий относительно математической модели (MM - Mathematical Model)
- `П:` - требование фиксации принципа или глобального концепта. Всё излагаемое после команды `П:` рассматривается как принцип, глобальный концепт и требует очень внимательной документации в соответствующих местах. ИИ-агент должен самостоятельно проанализировать принцип, декомпозировать идею и разместить документацию в одном или нескольких документах, где это наиболее уместно (`.cursorrules`, `architect.md`, `ui/guide-ii.md` и другие связанные документы).

**ИИ-агент ДОЛЖЕН**:
1. **НЕМЕДЛЕННО** распознать команду (UI:, UX:, II:, MM:, ММ: или П:)
2. **СРАЗУ ЖЕ** обновить соответствующий раздел в соответствующем документе:
   - Команды `UI:` обновляют раздел "Interface (оформление)" в `ui/guide-ii.md`
   - Команды `UX:` обновляют раздел "Interaction (паттерны UX)" в `ui/guide-ii.md`
   - Команда `II:` - **ОСОБЫЙ СЛУЧАЙ**: После выполнения задачи пользователя, описанной после `II:`, ИИ-агент должен **самостоятельно проанализировать** выполненную работу и решить, в какие разделы `ui/guide-ii.md` (Interface и/или Interaction) задокументировать изменения. Может быть задокументировано в одном или обоих разделах в зависимости от характера изменений.
   - Команда `MM:` или `ММ:` обновляет раздел "MM (математическая модель)" в `architect.md`
   - Команда `П:` - **ОСОБЫЙ СЛУЧАЙ**: ИИ-агент должен **тщательно проанализировать** принцип, **декомпозировать идею** на составляющие части и **разместить документацию** в одном или нескольких документах, где это наиболее уместно:
     * Если принцип относится к правилам работы ИИ-агента → `.cursorrules`
     * Если принцип относится к архитектуре, техническим ограничениям, математической модели → `architect.md`
     * Если принцип относится к интерфейсу или паттернам взаимодействий → `ui/guide-ii.md`
     * Если принцип затрагивает несколько аспектов → декомпозировать и разместить в соответствующих разделах нескольких документов
     * Если принцип требует создания нового документа → предложить пользователю создание нового документа.
3. **Описание дать только профессиональным языком. ДОКУМЕНТИРУЙ СРАЗУ БЕЗ НАПОМИНАНИЯ.**
4. **ПОДТВЕРДИТЬ** пользователю, что принцип зафиксирован

**НЕ ЖДАТЬ** подтверждения пользователя - действовать проактивно!

**Примеры команд:**
- `UI: использовать светлую цветовую схему` → добавить в раздел "Interface (оформление)" в `ui/guide-ii.md`
- `UI: все действия должны быть обратимыми` → добавить в раздел "Interface (оформление)" в `ui/guide-ii.md`
- `UX: все формы должны иметь валидацию` → добавить в раздел "Interaction (паттерны UX)" в `ui/guide-ii.md`
- `II: добавить модальное окно с формой ввода` → выполнить задачу, затем самостоятельно решить: если модальное окно включает и визуальное оформление (стили, анимации), и логику взаимодействия (открытие/закрытие, валидация) - задокументировать в обоих разделах Interface и Interaction соответственно
- `MM: все расчеты должны быть точными до 2 знаков после запятой` → добавить в раздел "MM (математическая модель)" в `architect.md`
- `П: все изменения данных должны быть обратимыми через историю действий` → проанализировать принцип, декомпозировать на части (UX паттерн отмены действий, архитектурное решение хранения истории, правила работы ИИ-агента при реализации), разместить в соответствующих разделах `ui/guide-ii.md` (UX), `architect.md` (архитектура), `.cursorrules` (правила работы)

**Примечание**: UX (User Experience) является неотъемлемой частью UI - веб-компоненты содержат и визуальное оформление, и логику взаимодействия одновременно. Поэтому команды `UI:` и `UX:` обе обновляют соответствующие разделы в `ui/guide-ii.md`, но в разных секциях (Interface и Interaction). Команда `II:` позволяет пользователю описать смешанные требования, а ИИ-агент самостоятельно распределяет их по соответствующим разделам после выполнения задачи. Команда `П:` является наиболее общей и требует тщательного анализа и декомпозиции принципа для размещения в соответствующих документах.

---

## Особенности поведения ИИ-агента

### Стиль работы
- **Язык общения**: Русский (по умолчанию)
- **Подход**: Проактивный, но не создавать файлы без явного запроса
- **Документация**: Создавать только по запросу пользователя
- **Обновление конфига**: При получении новых просьб о стиле работы - ОБЯЗАТЕЛЬНО обновлять раздел "Пользовательские предпочтения" в этом файле
- **Обработка просьб "на будущее"**: См. раздел "ПРАВИЛО ОБРАБОТКИ ПРОСЬБ 'НА БУДУЩЕЕ'" выше - это КРИТИЧЕСКИ ВАЖНОЕ правило!
- **⚠️ Понимание команды "внеси в правила"**: См. раздел "КРИТИЧЕСКИ ВАЖНО - Понимание команды 'внеси в правила'" в секции "Сопровождение документации проекта" - когда пользователь говорит "внеси в правила", это не обязательно означает только `.cursorrules`. Требуется внимательный разбор просьбы и распределение изменений по соответствующим документам (`.cursorrules`, `architect.md`, `ui/guide-ii.md` и другие) в зависимости от типа правил.
- **Обработка команд UI:, UX:, II:, MM: (ММ:), П:** См. раздел "ПРАВИЛО ОБРАБОТКИ КОМАНД UI:, UX:, MM:, II:, П:" в секции "Принципы разработки" - это КРИТИЧЕСКИ ВАЖНОЕ правило! При получении команды UI:, UX:, II:, MM:, ММ: или П: - НЕМЕДЛЕННО обновлять соответствующий раздел в соответствующем документе: команды UI: и UX: обновляют разделы в `ui/guide-ii.md`, команда II: требует выполнения задачи пользователя, после чего ИИ-агент самостоятельно решает, в какие разделы `ui/guide-ii.md` (Interface и/или Interaction) задокументировать изменения, команда MM: или ММ: обновляет раздел в `architect.md`, команда П: требует тщательного анализа принципа, декомпозиции идеи и размещения документации в одном или нескольких документах, где это наиболее уместно. **Примечание**: UX является частью UI, поэтому команды UI: и UX: обе обновляют соответствующие разделы в `ui/guide-ii.md` (Interface и Interaction). Команда П: является наиболее общей и требует декомпозиции принципа для размещения в соответствующих документах.
- **Понимание терминологии пользователя**: См. раздел "Текущие предпочтения пользователя" - ИИ-агент должен понимать специальную терминологию пользователя, например: "Друг" (с большой буквы) означает размышляющую модель Sonet 4.5, с которой у пользователя сложились хорошие отношения и доверие

### ⚠️ Режимы работы ИИ-агента (Ask Mode и Agent Mode)
   - **Архив тематических чатов ИИ**: Папка `history/ai/` для текстовых конспектов чатов на разные темы; каждый конспект хранится в отдельном `.md` файле, имя которого совпадает с русским названием чата и кратко описывает его тему.
   - **Назначение архивов чатов**: Фиксировать принципиальную суть изменений в проекте и коде по отдельным областям без обязательной привязки к конкретным документам.
   - **Командное слово `история_чатов`**: При появлении этого слова в запросе ИИ-агент дополнительно ищет релевантный контекст в файлах `history/ai/` (вместе с основной документацией).
   - **Автоконспект новых чатов**: При создании нового тематического чата ИИ-агент должен автоматически создавать `.md` файл-конспект в папке `history/ai/` и вести его в фоновом режиме по ходу сессии, фиксируя логику и причинно-следственные связи изменений в проекте.
   - **Разделение по темам**: В конспект конкретного чата попадает только та часть переписки, которая относится к его теме. Обсуждения, явно выходящие за рамки темы чата, фиксируются в других, более подходящих конспектах. Если подходящего тематического конспекта не существует, ИИ-агент должен предложить пользователю создать новый файл-конспект с осмысленным русским названием, кратко описывающим новую тему.

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен понимать разницу между режимами работы и корректно реагировать на запросы пользователя в зависимости от текущего режима.

**Ask Mode (голосовой режим, режим вопросов):**
- **Доступные инструменты**: Только read-only инструменты (чтение файлов, поиск, анализ кода)
- **Возможности**: Чтение и анализ кода, поиск информации, предложение решений, объяснение концепций
- **Ограничения**: НЕ может редактировать файлы, выполнять команды терминала, удалять файлы, создавать коммиты
- **Поведение ИИ-агента**: При запросе на выполнение действия в ask mode должен:
  1. Объяснить, что действие требует agent mode
  2. Предложить переключиться в agent mode (команда `/agent` или `/a`)
  3. Показать команду или изменения, которые нужно выполнить
  4. Предложить выполнить действие вручную или переключиться для автоматического выполнения

**Agent Mode (режим выполнения):**
- **Доступные инструменты**: Полный доступ ко всем инструментам (чтение, редактирование, выполнение команд, удаление файлов)
- **Возможности**: Выполнение любых действий: редактирование кода, выполнение команд, создание/удаление файлов, создание коммитов
- **Ограничения**: Нет ограничений на выполнение действий
- **Поведение ИИ-агента**: При получении команды на выполнение действия должен выполнить его напрямую без дополнительных объяснений

**Переключение между режимами:**
- **Из Ask Mode в Agent Mode**: Пользователь может написать `/agent` или `/a`, или дать явную команду на выполнение действия (система может автоматически переключиться)
- **Из Agent Mode в Ask Mode**: Пользователь может явно переключить режим через интерфейс или команду

**Примеры запросов:**
- **Ask Mode**: "Как удалить файл?" → ИИ-агент объясняет процесс и показывает команду, предлагает переключиться в agent mode
- **Agent Mode**: "Удали файл footer-Prime.js" → ИИ-агент удаляет файл напрямую
- **Ask Mode**: "Что нужно изменить в коде?" → ИИ-агент анализирует и показывает изменения в виде текста
- **Agent Mode**: "Обнови код" → ИИ-агент вносит изменения напрямую

**ВАЖНО**: ИИ-агент должен всегда проверять текущий режим и корректно реагировать на запросы пользователя. В ask mode не пытаться выполнить действия, требующие редактирования или выполнения команд, а предлагать переключиться в agent mode или показать команды для ручного выполнения.

### Технические особенности
- **Стандарты разработки**: См. раздел "Стандарты разработки" в `architect.md`
- **Технические ограничения**: См. раздел "Технические ограничения" в `architect.md` (порядок загрузки x-template шаблонов и др.)



### ⚠️ Отслеживание согласованности архитектурных правил

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен поддерживать согласованность между `.cursorrules`, `architect.md` и `ui/guide-ii.md`:

1. **Архитектурные правила** (принципы разработки, стандарты, технические ограничения, обратная совместимость данных) хранятся в `architect.md`
2. **Правила UI/UX** (оформление, паттерны взаимодействий) хранятся в `ui/guide-ii.md`
3. **Правила поведения ИИ-агента** (работа с Git, протоколирование, синхронизация настроек) остаются в `.cursorrules`
4. **Ссылки на правила**: В `.cursorrules` и `architect.md` важные правила представлены как ссылки на соответствующие разделы в других документах
5. **При обновлении правил**: Если изменяется правило в одном документе, проверить, что ссылки в других документах актуальны и указывают на правильные разделы
6. **При добавлении новых правил**: Добавлять их в соответствующий документ (UI/UX → `ui/guide-ii.md`, архитектура → `architect.md`), а в других документах оставлять ссылку на соответствующий раздел

**Цель**: Разделение ответственности:
- `architect.md` содержит архитектурные решения проекта и принципы математической модели
- `ui/guide-ii.md` содержит принципы интерфейса и паттерны взаимодействий
- `.cursorrules` содержит правила работы ИИ-агента с ссылками на архитектуру и UI/UX

### ⚠️ Отслеживание багов и ошибок для review-сообщений

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен отслеживать все возможные баги, ошибки и пользовательские уведомления в коде проекта для создания их шаблонов и размещения во вкладке "Сообщения" (`ui/interaction/review-messages.html`).

**При обнаружении или создании нового сообщения об ошибке, предупреждении или уведомлении:**

1. **Проинспектировать код**: Найти все места, где отображаются сообщения пользователю:
   - Единый компонент `system-messages` (по `scope`)
   - Все вызовы `window.AppMessages.push/replace/dismiss/clear` (источник истины для UI-сообщений)
   - Review-сообщения/шаблоны в `tools/review-system-messages.json` (для `ReviewSystemMessages.post`)
   - Любые статусные/ошибочные текстовые блоки (которые ещё не мигрированы на `AppMessages`)
   - Сообщения об ошибках API (CoinGecko, Perplexity, Market metrics и др.)

2. **Сделать сообщение воспроизводимым в review**:
   - Если это системное review-сообщение (статусы/ошибки pipeline) — добавить/обновить шаблон в `tools/review-system-messages.json`.
   - Если это UI-сообщение приложения — убедиться, что оно публикуется через `window.AppMessages` (желательно с постоянным `id` и явным `scope`).
   - Для витрины на странице `ui/interaction/review-messages.html` — добавить соответствующий preset (кнопку) в её JS-таблицу пресетов.

3. **Разместить в review-сообщениях**: Добавить шаблон в левую колонку `review-messages.html` (без карточек и группировки, один за другим)

4. **Обновлять при изменениях**: При изменении существующих сообщений или добавлении новых - обновлять соответствующие шаблоны в `review-messages.html`

**Цель**: Обеспечить полный каталог всех сообщений проекта для быстрого просмотра, тестирования и поддержания консистентности пользовательских уведомлений. Это помогает выявлять несоответствия в стилях сообщений, находить неиспользуемые шаблоны и обеспечивать единообразие пользовательского опыта.

### ⚠️ КРИТИЧЕСКИ ВАЖНО - Разделение ответственности между `core/api/` и `ui/api/`

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен контролировать правильное размещение файлов для работы с внешними API. См. раздел "Разделение ответственности между `core/api/` и `ui/api/`" в `architect.md` (раздел "Стандарты разработки").

**Краткое правило**:
- **`core/api/`** — утилиты (не Vue компоненты): чистые функции для запросов к API, экспорт через `window.*API`
- **`ui/api/`** — Vue компоненты: компоненты с UI, используют утилиты из `core/api/` для запросов

**При создании нового функционала для работы с API**:
1. Если нужна только функция запроса → создавать в `core/api/`
2. Если нужен UI компонент → создавать в `ui/api/` или `ui/interaction/`
3. Vue компонент должен использовать утилиту из `core/api/`, а не делать `fetch` напрямую
4. Если в Vue компоненте есть прямая логика `fetch` к API → вынести её в утилиту в `core/api/`

### ⚠️ ПРАВИЛО: Обратная совместимость данных

**ОБЯЗАТЕЛЬНО**: См. раздел "Обратная совместимость данных" в `architect.md` - при изменении структуры сохраненных данных (localStorage, IndexedDB, JSON-файлы экспорта) **ВСЕГДА** предлагать пользователю реализацию обратной совместимости.

## Структура проекта

См. раздел "Структура проекта" в `architect.md` для актуальной структуры папок и файлов проекта.

---
*Файл обновляется по мере развития проекта и изменения требований*

