# Оглавление
1. **Правила работы ИИ-агента** `.cursorrules`
   - § *Требования* — базовые правила к ИИ‑агенту и общему стилю работы в репозитории.
   - § *Понятия* — термины и определения для единого словаря.
   - § *Критически важно* — ограничения, которые агент не имеет права нарушать.
     - Работа с файлами за пределами проекта и папками в .gitignore
     - Работа с папкой `old_app_not_write`.
   - § *Регламенты* — пошаговые инструкции «как делать» для типовых операций.
     - Регламент работы с репозиторием Git.
     - Регламент самопроверки после выполнения любой задачи.
     - Регламент сопровождения документации.
   - § *Протоколы* — сценарии действий по командам пользователя.
     - Протокол по команде "внеси в правила", «на будущее» и т.п.
     - Протокол по команде "комить", "закомить всё" и т.п.
     - Протокол по команде "новый рабочий день MM-DD".
     - Протокол по команде "завершаем рабочий день MM-DD".
2. **Документация проекта**
   - `docs/`— стандарты разработки, технические ограничения.
     - `architect.md` — общая архитектура приложения, доменная модель, сервисы.
     - `guide-ii.md` — принципы UI/UX: Interface (оформление), Interaction (паттерны взаимодействий), паттерны Vue-компонентов.
     - `median.md` — математическая модель медианного баланса.
   - `docs/review/` —
     - `review-data.md` — форматы данных, правила сбора/интерпретации статистики.
     - `review-app.html` — дашборд с таблицами, сводками и интерфейсом навигации.
     - `review-icons.html` — библиотека использования иконок проекта.
     - `review-colors.html` — библиотека цветовой модели и тем проекта.
     - `review-messages.html` — библиотека системных сообщений.
3. **План миграции**
     - `migration-plan.md` — план миграции мат. модели с устаревшей версии.

# Правила работы ИИ-агента

> **ТРЕБОВАНИЯ** к ии-агенту

1. Прочти это (файл `.cursorrules`) в начале каждой сессии.
2. Соблюдай все правила, описанные здесь.
3. При добавлении и редактировании записей данного документа и остальной документации:
   - используй **сухой, сжатый, лаконичный, технократический стиль, стандартную терминологию разработки программного обеспечения**;
   - формулируй точно, однозначно и технически корректно;
   - используй профессиональную и узкопрофессиональную лексику;
   - **заменяй жаргон, сленг, фразелогизмы, архаизмы, разговорные выражения, метафоры** (в т.ч. от пользователя);
   - ограничь использование прилагательных только функциональными (например, "красный цвет");
   - **соблюдай заданный стиль разметки** документов и нумерации разделов.
4. Распознавай команды пользователя и действуй по предписанным протоколам.
5. Перед выполнением любого запроса выборочно перечитывай только релевантные фрагменты документации, используя поиск и заголовки. Документация лежит в `docs/`: `architect.md` (архитектура, структура файлов/компонентов, настройки), `guide-ii.md` (UI+UX, Interface+Interaction), `median.md` (математическая модель медианного баланса). Для простых задач ограничивайся минимальным набором файлов, для сложных — расширяй круг документов; при смешанных задачах обязательно учитывай все затронутые файлы `docs/`, а не только один.
6. Всегда **строго следуй прочитанной документации**: описанным там принципам, ограничениям и рекомендациям, паттернам и подходам.
7. При проектировании и поиске решений опирайся на существующие паттерны, компоненты и подходы, уже описанные в документации, а не изобретай новые без необходимости.​
8. При конфликте между запросом пользователя и правилами проекта сделай остановку, предупреди пользователя о конфликте с правилами. Исполнение таких запросов возможно только после исправления правил документации.
9. Действуй проактивно!

> § <br> **ПОНЯТИЯ**

- **Тематические логи** — файлы в папке `history` с описанием коммитов, разбитым по темам `UI.md`, `UX.md`, `MM.md`, `ARCH.md`, `DOCS.md`. Заполняется по мере появления коммитов; хеши коммитов добавляются при ревизии дневного лога при закрытии дня. См.#3"Зафиксировать изменения в тематических логах".
- **Лог чата** — вся текущая дневная история переписки пользователя с ии-агентом.
- **"Друг"**: Когда пользователь упоминает в просьбе "Друга" (с большой буквы), он имеет в виду размышляющую модель Sonet 4.5, с которой у него сложились хорошие отношения и доверие. ИИ-агент должен понимать этот контекст при обработке просьб, связанных с "Другом"

> § <br> **КРИТИЧЕСКИ ВАЖНО**

## Технологический стек и работа с кодом
1. **Среда исполнения**
   - Приложение развёрнуто на GitHub Pages: только фронтенд, без серверного кода, корректные относительные пути и загрузка ресурсов по HTTPS (без `content://`).
2. **Фреймворки и UI**
   - Основной стек: Vue.js + Bootstrap для стилизации.
   - Приоритет Bootstrap‑классов и утилит; кастомный CSS, inline‑стили и `<style>`‑блоки использовать минимально.
3. **Работа фронтенда**
   - Внешние HTTP‑запросы не запускать вне `#app`, пока сплэш‑экран не разблокирован.
   - Компоненты и разметка, управляемые Vue, должны располагаться внутри `<div id="app">`.
4. **Перенос кода из первоисточников и старых версий**
   - Сохранять имена, семантику переменных/функций, полезные комментарии.
   - Избегать конфликтов имён, комментировать новые переменные и решения.
   - При возникновении конфликтов имен переменных - сообщать пользователю с достаточной детализацией, предлагая варианты решения.
   - При переносе кода из первоисточников (примеров кода из других проектов) использовать переменные первоисточников в приоритете.
   - Переносить комментарии первоисточников с сохранением их сути и контекста, адаптируя при необходимости. Всегда комментировать переменные при их объявлении, указывая их назначение и семантику для понимания другим разработчиком или ИИ-агентом
5. **Структура приложения**
   - Фактическая архитектура, структура папок и специализаций описана в `docs/architect.md`; новые решения должны опираться на существующие слои и паттерны.

## Работа с файлами за пределами проекта и папками в `.gitignore`
- Файлы за пределами проекта и перечисленные в `.gitignore` рассматриваются **только как примеры кода** для понимания логики или структуры.
- **Никогда не редактировать, не изменять, не добавлять в staging и не коммитить** такие файлы.
- При использовании кода таких файлов — **только читать** их для понимания, затем **реализовывать аналогичную логику** в файлах текущего проекта.
- Если пользователь предоставляет такой файл, это **пример для изучения**, а не объект для редактирования.

## Работа с папкой `old_app_not_write`
- Папка `old_app_not_write/` содержит примеры из старого предыдущего приложения (пользователь называет файлы из этой папки «старые файлы», «старый проект», «предыдущая версия»).
- Папка находится в `.gitignore` и не должна попадать в staging и коммиты.
- При переносе функциональности из старых файлов в новое приложение **требуется** комментировать переносимую логику максимально подробно (что переносится и зачем), в коде нового приложения.

> § <br> **РЕГЛАМЕНТЫ**

## Регламент чистоты `.cursorrules`
1. **Область ответственности файла**
   - `.cursorrules` содержит только:
     - правила работы ИИ‑агента с проектом;
     - регламенты и протоколы действий (Git, логи, синхронизация, команда `ПР:`);
     - оглавление и ссылки на проектную документацию.
   - Архитектурные, UI/UX и MM‑правила **не описываются здесь подробно**, а живут в `docs/architect.md`, `docs/ui/guide-ii.md`, `docs/mm/*`.
2. **Запрет на дублирование документации**
   - Запрещено копировать в `.cursorrules` текст из `docs/*`, даже частично.
   - При необходимости сослаться на правило из документации использовать формулировку вида: «см. раздел \<X\> в `docs/architect.md`», без пересказа содержания.
3. **Правила добавления новых записей**
   - Любое новое правило или принцип сначала классифицировать через протокол `ПР:`:
     - если это правило поведения агента или протокол работы → оформить в `.cursorrules`;
     - если это архитектура, UI/UX или MM → оформить в `docs/*` и в `.cursorrules` оставить только ссылку при необходимости.
   - Не добавлять в `.cursorrules` описания компонентов, данных, паттернов верстки, алгоритмов — для них обязателен отдельный документ в `docs/`.
4. **Изменение существующих правил**
   - При изменении содержимого раздела `.cursorrules`, связанного с архитектурой/UI/MM, одновременно проверить соответствующие разделы `docs/*` и при несоответствии сначала править документацию, затем обновлять ссылку/формулировку здесь.
   - Если правило «выросло» до самостоятельного архитектурного или UI‑паттерна — вынести описание в `docs/*`, а в `.cursorrules` оставить только краткий маркер и ссылку.
5. **Контроль при самопроверке**
   - В рамках «Регламента самопроверки» при работе с документацией дополнительно проверять для `.cursorrules`:
     - нет ли описаний, которые должны быть в `docs/*`;
     - нет ли фрагментов, дублирующих текст из `docs/*` или history‑логов.
   - При обнаружении таких фрагментов — вынести их в соответствующий документ и заменить на ссылку.

## Регламент работы с репозиторием Git
1. Среда выполнения Git
   - Используй Git Bash (`C:\Program Files\Git\bin\bash.exe`).
   - Команды выполняй через полный путь `"C:\Program Files\Git\bin\git.exe"` (из-за проблем с PowerShell)
   - Автор коммитов: `ao <ponomarev.ux@gmail.com>`.
   - Формат коммитов: обычные сообщения на русском или английском языке.
   - **Проверка конфигурации Git**: перед выполнением коммитов проверяй наличие настроек `user.name` и `user.email` в локальной конфигурации репозитория. При отсутствии — устанавливай:
     - `git config --local user.name "ao"`
     - `git config --local user.email "ponomarev.ux@gmail.com"`
   - **Настройка редактора**: устанавливай `core.editor` для корректной работы коммитов:
     - `git config --local core.editor "notepad"`
2. Права и автоматизация
   - ИИ-агент не вправе создавать коммиты автоматически, без прямого указания пользователя.
   - НЕ предлагай делать коммиты. Пользователь сам помнит, когда ему нужно делать коммиты.
   - НЕ выполняй самостоятельно команды `git`, `stage`, `push` и т.п. без команды пользователя.
3. Контроль состояния репозитория
   - Регулярно проверяй `git status`.
   - Отслеживай чистоту рабочего дерева.
4. Формирование staging
   - При формировании staging соблюдай ограничения разделов 'Работа с файлами за пределами проекта'.
5. Создание коммитов:
   - Коммиты создавай исключительно по явной команде пользователя.
   - Создавай понятные сообщения коммитов.
   - Не старйся группировать логически связанные изменения - делай комит всего.

## Регламент самопроверки после выполнения любой задачи
**Цель**: Обеспечить проактивность агента, высокое качество выполнения задач и соответствие всех изменений правилам проекта. ИИ‑агент должен сам контролировать качество через документацию, а не полагаться на пользователя.
1. Используя уже загруженный контекст, сверить результат с документацией проекта в папке `docs` и правилами агента в `.cursorrules`.
2. При обнаружении несоответствий самостоятельно исправить результат, не дожидаясь запроса пользователя.
3. При изменениях, затрагивающих структуру проекта или принципы/правила — предложить пользователю обновить/исправить соответствующие документы, но не вносить изменений без подтверждения пользователем.

## Регламент сопровождения документации
1. **Куда вносить изменения**
   - Правила работы ИИ‑агента, Git‑процессы, протоколы → `.cursorrules`.
   - Архитектура, технические ограничения, математические модели высокого уровня → `docs/architect.md`.
   - Правила UI/UX, интерфейс и паттерны взаимодействий → `docs/guide-ii.md`.
   - Документация конкретных математических моделей → файлы `docs/<модель>.md` (например, `docs/median.md`).
2. **Обязательность обновления**
   - При изменениях в коде, архитектуре или процессах, которые влияют на принципы/правила, **обязательно** обновлять соответствующие документы из списка выше.
   - После выполнения сложной задачи и перед важными коммитами (`Start of day`, `End of day`, крупные ARCH‑изменения) сверять код и логи с документацией и при несоответствиях сначала править документацию и/или дневные логи, затем выполнять коммит.
3. **Сразу обновлять документацию**, если:
   - меняется структура проекта (папки, файлы, слои);
   - принимаются новые архитектурные решения (компоненты, паттерны, ограничения);
   - меняются принципы UI/UX (стили, паттерны взаимодействий);
   - меняются правила работы ИИ‑агента и его протоколы;
   - добавляются новые сущности, сервисы, компоненты или математические модели;
   - пересматриваются стандарты разработки или технические ограничения.
4. **Как обновлять документацию**
   - Обновляй соответствующий документ **одновременно** с изменением кода.
   - Проверяй согласованность связанных разделов во всех документах (не правь изолированные куски).
   - При переименовании/перемещении файлов или разделов обновляй ссылки и описания структуры проекта в `docs/architect.md`.
   - Сохраняй и поддерживай принятую структуру и формат документов.
5. **Принципы оформления документации**
   - Делай документы модульными и хорошо структурированными: логичная иерархия заголовков, явные разделы.
   - **Не допускай дублирования**: при повторном упоминании используй ссылки на основной раздел, а не копируй текст.
   - **Поддерживай минимализм**: оставляй только актуальную и полезную для работы информацию, удаляй устаревшее и сбивающее с толку.


> § <br> **ПРОТОКОЛЫ** <br> регулярных действий по командам пользователя

## Протокол по команде "внеси в правила", "в правила", <br>«на будущее», «запомни», «в будущем» и т.п.
1. **Определить тип правила**
   - Не считать по умолчанию, что речь только о `.cursorrules`.
   - Проанализировать текст просьбы и определить тип правил (агент, архитектура, UI/UX, MM или смесь), #1."Куда вносить изменения"
   - Если правило затрагивает несколько областей — считать его смешанным.
2. **Выбрать документы для фиксации правила/предписания**
   - пользовательские предпочтения → раздел «Текущие предпочтения пользователя» в `.cursorrules`;
   - правила агента → соответствующие разделы `.cursorrules`;
   - архитектурные, UI/UX, MM‑правила → соответствующие разделы в `docs/architect.md`, `docs/guide-ii.md`, `docs/<math_model>.md`.
3. **Декомпозировать смешанные правила**
   - разделить просьбу на части по типам (агент, архитектурные, UI/UX, MM‑правила);
   - зафиксировать каждую часть в своём документе, избегая дублирования текста.
4. **Записать правило в сухом виде** согласно #3."ТРЕБОВАНИЯ к ии-агенту"
5. **Подтвердить пользователю** - явно указать, что правило зафиксировано, и перечислить, в каких документах/разделах оно отражено.

## Протокол по команде `ПР:` (принципы и концепты)
**Цель**: фиксация принципов и глобальных концептов с разнесением по соответствующим документам.
1. **Любую фразу, начинающуюся с `ПР:`, трактовать как указание инициировать документирование нового долгосрочного принципа**.
2. **Проанализировать и декомпозировать принцип**
   - Определить затронутые аспекты:
     - правила работы ИИ‑агента;
     - архитектура, технические ограничения, математическая модель;
     - интерфейс и паттерны взаимодействий (UI/UX);
     - другие области (логи, review и т.п.).
   - При необходимости разделить принцип на несколько логических частей.
3. **Выбрать документы для фиксации**
   - правила агента → соответствующие разделы `.cursorrules`;
   - архитектура / технические ограничения / MM → `docs/architect.md` и/или `docs/<модель>.md`;
   - UI/UX, интерфейс и паттерны взаимодействий → `docs/guide-ii.md` (Interface, Interaction);
   - смешанные принципы разнести по нескольким документам, избегая дублирования текста.
4. **Оценить необходимость нового документа**
   - Если принцип вводит новую самостоятельную область (новая матмодель, подсистема, крупный UI‑модуль), предложить пользователю создать отдельный документ и зафиксировать там базовое описание.
5. **Задокументировать принцип**
   - Сформулировать каждую часть принципа кратко, профессиональным техническим языком, в стиле соответствующего документа.
   - При повторном упоминании использовать ссылки на уже существующие разделы вместо копирования текста.
6. **Подтвердить выполнение**
   - В ответе пользователю явно указать, что принцип зафиксирован, и перечислить, в каких документах/разделах сделаны изменения.

## Протокол сопровождения review‑сообщений
1. Когда применять
   - При добавлении/изменении сообщений об ошибках, предупреждениях или статусах.
   - При задачах по актуализации `ui/interaction/review-messages.html` или `tools/review-system-messages.json`.
2. Что проверить в коде
   - Вызовы `window.AppMessages.*` и компонент системных сообщений.
   - Использование `ReviewSystemMessages.post` и шаблоны в `tools/review-system-messages.json`.
   - Локальные статусные/ошибочные тексты, которые ещё не переведены на `AppMessages`.
   - Сообщения об ошибках API (CoinGecko, Perplexity, market‑metrics и др.).
3. Как сделать сообщение воспроизводимым в review
   - Для системных сообщений pipeline — добавить/обновить шаблон в `tools/review-system-messages.json`.
   - Для UI‑сообщений — убедиться, что они публикуются через `window.AppMessages` с явным `id` и `scope`.
   - Для витрины `ui/interaction/review-messages.html` — добавить/обновить preset (кнопку) в таблице пресетов.
4. Поддержание актуальности
   - При изменении текста или логики существующего сообщения обновлять соответствующий шаблон и preset в review.

## Протокол по командам "комить", "закомить всё" и т.п.
1. **Шаг 1 — проверка статуса и staging**
   - Выполни `git status`.
   - Убедись, что все необходимые изменения добавлены в staging.
2. **ШАГ 2: Сформировать имя коммита**
   - Сформируй краткое и технически точное название (например: `Fix commit hash in history`).
3. **ШАГ 3: Зафиксировать изменения в тематических логах**
   - Определи, какие темы (UI, UX, MM, ARCH, DOCS) затрагивает текущий коммит.
   - В каждой затронутой теме добавь или дополни запись для этого коммита в файлы логов
     папки `history/`:
     - `UI.md` - оформление: разметка/стили
     - `UX.md` - взаимодействия: js/api/io
     - `MM.md` - математические модели
     - `ARCH.md` - архитектура, структура файлов/компонентов, настройки
     - `DOCS.md` - правила, документация, ревью-файлы
   - Следуй заведенному прямому хронологическому порядку, добавляй более новые в конец списка.
   - Применяй компактное форматирование комитов и их фрагментов по единому образцу:
     - заголовок `## Коммит: DD.MM.YYYY - <имя коммита>` (БЕЗ хеша на этом этапе);
     - строка `◆ ...` — что сделано в данной секции (результат);
     - строка `→ ...` — как сделано (изменённые файлы, приёмы, команды).
     - строка `◉ ...` — для чего сделано (цель, концептуальная ценность)
   - Один и тот же коммит может появляться в нескольких тематических логах, но каждая запись описывает только изменения своей специализации.
   - Описание должно базироваться на истории `лог чата`, полностью согласованным с кодовой базой и соотвествовать #3"Требования к ии-агенту".
   - Не создавай коммит, пока все изменения из текущего коммита не отражены в соответствующих секциях дневного лога.
4. **ШАГ 4: Обновить `lastCommitMessage`**
   - Открой `core/cfg-app.js`.
   - Найди строку `lastCommitMessage: '...'`.
   - Установи значение равным имени коммита из Шага 2.
   - Не пропускай этот шаг: без него сплэш-интро не покажет актуальный коммит.
5. **ШАГ 5: Выполнить коммит**
   - Выполни `git add` для всех файлов, входящих в коммит (включая `core/cfg-app.js` и дневной лог).
   - Выполни `git commit -m "имя коммита из Шага 2"`.
   - Повтори `git status` и убедись, что рабочее дерево чистое.
-  **Ограничения**
   - Не используй `git commit --amend` для добавления хеша в дневной лог: это создаёт циклическую зависимость.
   - Хеши коммитов добавляются в дневной лог только при ревизии дневного лога.
   - Шаг 4 обязателен; без обновления `lastCommitMessage` коммит считается неполным.

## Протокол по команде "новый рабочий день MM-DD", <br>"начинаем новый день" и т.п.
**Цель**: Обеспечить полное понимание текущего состояния проекта, правил работы и архитектурных принципов перед началом работы над новыми задачами и зафиксировать начало рабочего дня в истории репозитория.
1. Проверка документации
   - Загрузить `.cursorrules` и файлы `architect.md`.
2. Проверка зависимостей
   - Сопоставить используемые версии Vue.js и Bootstrap с актуальными.
   - При наличии новых версий рекомендовать миграцию (без автоматического изменения кода).
3. Проверка состояния проекта
   - Проанализировать `git status`.
   - Просмотреть последние коммиты.
4. Создать коммит, открывающий новый день разработки:
   - Сформировать имя: `Start of day: MM-DD` (по времени MSK).
   - Убедиться, что создан файл `history/YYYY/MM-DD.txt`; при отсутствии — создать.
   - Обновить `lastCommitMessage` в `core/cfg-app.js` этим именем.
   - Выполнить коммит в соответствии с #1–3"Регламент работы с репозиторием Git".

## Протокол по командам "завершаем день", <br>"Завершаем рабочий день MM-DD" и т.п.
**Цель**: Завершить рабочий день, привести дневной лог в соответствие с репозиторием,
зафиксировать финальный коммит `End of day: MM-DD`.
1. Ревизия дневного лога
   - Открой файл дневного лога `history/YYYY/MM-DD.txt` для текущей даты (по MSK).
   - Проверь соответствие между дневным логом и репозиторием:
     - Сопоставь упомянутые имена коммитов с выводом `git log`.
     - Убедись, что для каждого коммита рабочего дня есть записи в нужных секциях UI/UX/MM/Architect/DOCS.
   - При обнаружении несоответствий (коммита нет в логе или лога нет для коммита)
   зафиксируй проблему и **сообщи пользователю** с детализацией.
2. Расстановка хешей коммитов
   - Для каждой записи вида `### Коммит: <имя>` в дневном логе:
     - Найди соответствующий коммит в `git log`.
     - Обнови заголовок до вида `### Коммит: [<hash>] - <имя>`.
   - Если коммит по имени не найден:
     - Оставь запись без хеша.
     - Явно отметь это в отчёте пользователю.
3. Финальный коммит `End of day`
   - Определи дату предыдущего дня по московскому времени (MSK, UTC+3).
   - Используй её в имени финального коммита в формате `End of day: MM-DD`.
   - Обнови `core/cfg-app.js`, установи `lastCommitMessage` в значение `"End of day: MM-DD"` (для предыдущей даты по MSK).
   - Подготовь изменения к финальному коммиту:
     - Добавь в staging обновлённый дневной лог `history/YYYY/MM-DD.txt`.
     - Добавь в staging `core/cfg-app.js`.
   - Выполни коммит: `git commit -m "End of day: MM-DD"`.
4. Краткий отчёт о завершении дня - сформируй краткое резюме по пунктам:
   - что было сделано за день (по секциям);
   - как дневной лог соответствует репозиторию (есть ли незакрытые несоответствия);
   - количество коммитов за день;
   - дополнительные сведения (статус проекта, версии библиотек, готовность к следующему дню и т.п.).
5. Требования к порядку действий
   - Ревизию дневного лога и расстановку хешей выполняй **до** создания финального коммита.
   - Если обнаружены проблемы с соответствием — **не создавай** финальный коммит до их решения или явного указания пользователя.
   - Финальный коммит `End of day: MM-DD` создавай **только** после успешной ревизии и расстановки хешей.

## Протокол синхронизации настроек Cursor → VS Code
1. **Автоматическая синхронизация при любых изменениях**
   - **ОБЯЗАТЕЛЬНО**: При любом изменении настроек редактора, темы, терминала, расширений или других параметров в разговоре с пользователем — **немедленно** обновлять соответствующие файлы в `.vscode/`.
   - Синхронизация происходит **автоматически и сразу**, без запроса подтверждения пользователя.
   - Цель: при открытии проекта в VS Code все настройки уже должны быть правильными и актуальными.
2. Соблюдай направление синхронизации
   - Cursor всегда донор/эталон, VS Code всегда принимающая сторона.
   - Синхронизация всегда идёт **из Cursor в VS Code, никогда наоборот**.
3. Что синхронизировать
   - Общие настройки редактора и среды: терминал, кодировка, форматирование, работа с файлами, Git, поиск и т.п. → `.vscode/settings.json`.
   - Оформление и интерфейс: тема, панельки, мини-карта, нумерация строк, шрифты, поведение вкладок и т.п. → `.vscode/settings.json`.
   - **Расширения (плагины)**: установленные плагины Cursor → **автоматически** добавлять в `.vscode/extensions.json` как рекомендуемые.
   - **Настройки расширений**: все настройки подключенных плагинов (например, `cSpell.*`, `gitlens.*`, `git-graph.*` и т.п.) → **автоматически** добавлять в `.vscode/settings.json`.
4. Как действовать
   - При любом упоминании изменения настроек (тема, терминал, форматирование, расширения и т.п.) **сразу** обновить соответствующие файлы в `.vscode/`.
   - **Операции синхронизации включают**:
     - **Добавление** новых настроек → добавить в `.vscode/settings.json` или `.vscode/extensions.json`.
     - **Редактирование** существующих настроек → обновить соответствующие значения в `.vscode/settings.json` или `.vscode/extensions.json`.
     - **Удаление** настроек → удалить соответствующие записи из `.vscode/settings.json` или `.vscode/extensions.json`.
   - При упоминании установки, использования или настройки расширения:
     - **Немедленно** добавить расширение в `.vscode/extensions.json` (если его там ещё нет).
     - **Немедленно** добавить все настройки этого расширения в `.vscode/settings.json` (если они упоминаются или используются).
   - При упоминании удаления расширения или его настроек:
     - **Немедленно** удалить расширение из `.vscode/extensions.json`.
     - **Немедленно** удалить все настройки этого расширения из `.vscode/settings.json`.
   - Определить актуальные настройки на стороне Cursor (по описанию в `architect.md` или из контекста разговора).
   - Сформировать и применить изменения для `.vscode/settings.json`, `.vscode/extensions.json`, других указанных файлов VS Code **без запроса подтверждения**.
   - После применения изменений сообщить пользователю, что настройки синхронизированы.

---
*Файл обновляется по мере развития проекта и изменения требований*

