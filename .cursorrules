# Правила работы ИИ-агента для проекта

> **ВАЖНО**: Этот файл автоматически читается Cursor в начале каждой сессии. ИИ-агент должен следовать всем правилам, описанным здесь.

## Общая информация о проекте
- **Название проекта**: BOT (Statistics/ToDo)
- **Тип проекта**: Веб-приложение (HTML)
- **Расположение**: `D:\Clouds\AO\OneDrive\Portfolio - CV\Refactoring\ToDo\Statistics\BOT`
- **Репозиторий Git**: Инициализирован, ветка `master`

## Настройки Git
- **Терминал**: Использовать Git Bash (`C:\Program Files\Git\bin\bash.exe`)
- **Команды Git**: Выполнять через полный путь `"C:\Program Files\Git\bin\git.exe"` (из-за проблем с PowerShell)
- **Автор коммитов**: `ao <ponomarev.ux@gmail.com>`
- **Формат коммитов**: Обычные сообщения на русском или английском языке

## Регулярные действия ИИ-агента

### При работе с Git
1. **Перед коммитом**:
   - Проверить статус репозитория
   - Убедиться, что все изменения добавлены в staging
   - Использовать полный путь к git.exe для команд

2. **Создание коммитов**:
   - **КРИТИЧЕСКИ ВАЖНО**: Коммиты создаются **ТОЛЬКО** по явной команде пользователя. ИИ-агент НЕ должен создавать коммиты автоматически без прямого указания пользователя.
   - **НЕ предлагать** делать коммиты пользователю. Пользователь сам помнит, когда нужно делать коммиты, и попросит об этом явно.
   - **НЕ выполнять** никаких операций с репозиторием (команды git, stage, push и т.п.) без прямого запроса или команды пользователя.
   - **НЕ использовать `git commit --amend`** ради «догоняния» хешей: после каждого amend хеш меняется, и попытки править лог/хеш в логе превращаются в бесконечную петлю. Хеш фиксируется только при ревизии дневного лога, а не в момент коммита.
   - Использовать понятные сообщения коммитов
   - Группировать логически связанные изменения

   ### ⚠️ ОБЯЗАТЕЛЬНЫЙ ЧЕКЛИСТ ПЕРЕД КАЖДЫМ КОММИТОМ (НЕ ПРОПУСКАТЬ!)

   **ПРИ ПОЛУЧЕНИИ КОМАНДЫ НА СОЗДАНИЕ КОММИТА — ВЫПОЛНИТЬ В СТРОГОЙ ПОСЛЕДОВАТЕЛЬНОСТИ:**

   **ШАГ 1: Сформировать имя коммита**
   - Придумать краткое и понятное название (например: "Fix commit hash in history")

   **ШАГ 2: Записать в дневной лог**
   - Зафиксировать описание изменений в `history/YYYY/MM-DD.txt`
   - Создать файл лога, если его еще нет
   - **ВАЖНО**: Указывать только название коммита без хеша
   - Хеш добавляется позже при ревизии дневного лога

   **ШАГ 3: ⚠️ ОБНОВИТЬ lastCommitMessage (ОБЯЗАТЕЛЬНО!)**
   - **КРИТИЧЕСКИ ВАЖНО**: Открыть файл `core/cfg-app.js`
   - Найти строку: `lastCommitMessage: '...'`
   - Заменить значение на имя коммита из Шага 1
   - **ЭТОТ ШАГ НЕЛЬЗЯ ПРОПУСКАТЬ!** Без него сплэш не покажет актуальный коммит

   **ШАГ 4: Выполнить коммит**
   - `git add` нужные файлы (включая `core/cfg-app.js`)
   - `git commit -m "название из Шага 1"`
   - Проверить статус: `git status`

   **ВАЖНО**:
   - **НЕ использовать `git commit --amend`** для добавления хеша в лог (создаёт замкнутый круг)
   - Хеши обновляются отдельно при ревизии дневного лога
   - **ШАГ 3 ОБЯЗАТЕЛЕН** — без обновления `lastCommitMessage` коммит считается неполным!

3. **Проверка состояния**:
   - Регулярно проверять `git status`
   - Отслеживать чистоту рабочего дерева

### При работе с файлами
1. **HTML файлы**:
   - Использовать минимальную валидную HTML5 разметку
   - Язык по умолчанию: `ru`
   - Кодировка: UTF-8
   - Включать viewport meta для адаптивности
   - **Стилизация**: Использовать только Bootstrap классы для стилей, избегать секций `<style>` в HTML файлах. Все стили должны управляться через Bootstrap утилиты и классы

2. **Создание новых файлов**:
   - Проверять наличие файла перед созданием
   - Использовать правильную структуру проекта
    - **Отслеживание ненужных файлов**: Проактивно выявлять и предлагать удаление файлов, которые не используются, являются дубликатами, устаревшими или "болтаются просто так" в проекте. При обнаружении таких файлов - предложить пользователю удалить их для поддержания чистоты проекта
    - **Не запускать внешние HTTP-запросы** (CoinGecko, CDN и т.п.) или иные операции вне `#app`, пока сплэш экран не разблокирован.
    - **Размещать компоненты/разметку внутри `<div id="app">`**: Vue-монтирует только то, что находится в пределах `#app`, поэтому сплэш-экраны, модалки, новые UI-блоки и контейнеры должны рендериться внутри `div` с id `app`.

3. **Проверка актуальности зависимостей**:
   - **Ежедневно, в начале каждого дня**: Проверять актуальность свежих версий Vue.js и Bootstrap
   - Использовать веб-поиск для проверки последних стабильных версий
   - Сравнивать текущие версии в проекте с последними доступными версиями
   - **Немедленно предлагать миграцию и адаптацию** при обнаружении новых версий
   - При миграции проверять breaking changes и обновлять код соответственно
   - Обновлять CDN ссылки в HTML файлах
   - Тестировать работоспособность после обновления

3. **Протоколирование дневного чата**:

   **Структура и формат:**
   - **Структура**: `history/YYYY/MM-DD.txt` (например: `history/2024/12-19.txt`)
   - **Режим записи**: Ручное протоколирование по результатам дня (не автоматическое)
   - **Формат записи**: Дневной лог разбивается на **3 секции**: UI, UX, MM

   **Регламент протоколирования:**

   **Структура дневного лога:**
   - Лог должен быть разбит на три секции: **UI (оформление)**, **UX (паттерны взаимодействий)**, **MM (математическая модель)**
   - В каждой секции описываются только изменения, относящиеся к соответствующей категории
   - Формат: больше конкретики, меньше воды

   **Для каждой секции (UI, UX, MM):**
   - Указывать **что конкретно было сделано** (конкретные действия, изменения в коде)
   - Указывать **каким образом** (методы, инструменты, команды, файлы)
   - При упоминании коммита указывать его название. Хеш коммита добавляется при ревизии дневного лога, когда обнаруживаются записи с названиями коммитов без хешей.
   - Пояснения должны быть **полным описанием** того:
     * Зачем коммит нужен
     * Что он делает
     * Какую функциональность добавляет
   - Формат должен позволять другому ИИ-агенту понять полную картину разработки и восстановить контекст изменений

   **Пример формата секции:**
   ```
   ## UI (оформление)

   ### Коммит: 52f6e11 - "Add Font Awesome icons and theme toggle button with dark/light mode support"
   - **Что сделано**: Добавлена кнопка переключения темы (светлая/темная) с иконками Font Awesome
   - **Как сделано**:
     * Подключен Font Awesome 6.5.1 через CDN в `<head>` (link rel="stylesheet")
     * Добавлена кнопка в `index.html` с классом `btn btn-outline-secondary rounded-circle`
     * Реализован метод `toggleTheme()` в Vue.js для переключения между 'light' и 'dark'
     * Добавлен метод `applyTheme()` для применения темы к элементу `<html>` через атрибут `data-bs-theme`
     * Реализовано сохранение выбранной темы в `localStorage` для персистентности
     * Использованы иконки `fa-moon` (для светлой темы) и `fa-sun` (для темной темы)
   - **Функциональность**: Пользователь может переключать тему приложения между светлой и темной, выбор сохраняется между сессиями
   ```

   **Когда протоколировать:**
   - По результатам дня или по запросу пользователя
   - При завершении значимых этапов работы
   - При необходимости зафиксировать важные решения

   **Автоматическое создание**: Создавать подпапки при смене года автоматически при первом протоколировании

3. **Синхронизация настроек Cursor → VS Code**:

   **⚠️ КРИТИЧЕСКИ ВАЖНО - Направление синхронизации:**
   - **Cursor** - всегда **донор/эталон** (источник настроек)
   - **VS Code** - всегда **принимающая сторона** (получатель настроек)
   - Синхронизация **ВСЕГДА** идет из Cursor в VS Code
   - **НИКОГДА** не наоборот - VS Code никогда не является источником настроек
   - При команде "синхронизируй vscode" или подобной - всегда понимать однозначно: настройки записываются из Cursor в VS Code

   **Механизм отслеживания изменений:**
   - **Проактивное обновление**: ИИ-агент автоматически обновляет `.vscode/settings.json` когда:
     * Пользователь упоминает изменение настройки в разговоре (например: "изменил тему на темную", "настроил автосохранение")
     * Пользователь устанавливает расширение (автоматически добавляется в `.vscode/extensions.json`)
     * Пользователь добавляет слово в словарь орфографии (автоматически добавляется в `.vscode/cspell-dict.txt`)
     * Пользователь просит изменить настройку проекта
   - **По запросу пользователя**: При явной просьбе синхронизировать настройки (например: "синхронизируй настройки", "обнови конфиг")
   - **При упоминании настроек**: Если пользователь упоминает настройку в контексте работы над проектом - предложить обновить её в `.vscode/settings.json`

   **ВАЖНО**: ИИ-агент НЕ может отслеживать изменения настроек Cursor в реальном времени (непрерывно), так как работает только во время сессий чата. Синхронизация происходит:
   1. Автоматически при упоминании изменений в разговоре
   2. По явной просьбе пользователя
   3. Проактивно при обнаружении несоответствий

   **Что синхронизируется:**
   - Поддерживать совместимость настроек терминала, кодировки, форматирования
   - **Синхронизировать настройки оформления**: тема, расположение панелей, элементы интерфейса, мини-карта, нумерация строк, шрифты, настройки вкладок, breadcrumbs и другие визуальные настройки
   - **Синхронизировать расширения**: при установке расширения в Cursor - **НЕМЕДЛЕННО** добавлять его в `.vscode/extensions.json` как рекомендуемое расширение, указывая правильный идентификатор расширения (например, `"esbenp.prettier-vscode"`)
   - **Синхронизировать настройки редактора**: автодополнение, IntelliSense, Emmet, сниппеты, автозакрытие скобок/кавычек, работа с несколькими курсорами, подсветка кода
   - **Синхронизировать настройки работы с файлами**: автосохранение, горячий выход, ассоциации файлов, исключения для watcher
   - **Синхронизировать настройки поиска**: умный поиск, игнорирование файлов, предпросмотр замены
   - **Синхронизировать настройки Git**: интеграция Git, декорации, timeline, merge editor
   - **Синхронизировать настройки терминала**: стиль курсора, размер шрифта, поведение копирования
   - **Синхронизировать настройки работы с кодом**: code actions, code lens, folding, color decorators
   - **Синхронизировать настройки проверки орфографии**: словари, пользовательские слова, языки проверки, исключения

## Пользовательские предпочтения и просьбы по стилю работы

> **КРИТИЧЕСКИ ВАЖНО**: Этот раздел содержит все просьбы и требования пользователя относительно стиля работы над проектом. ИИ-агент ОБЯЗАН следовать этим правилам во всех сессиях.

### ⚠️ ПРАВИЛО ОБРАБОТКИ ПРОСЬБ "НА БУДУЩЕЕ"
**ОБЯЗАТЕЛЬНО**: Когда пользователь использует фразы типа:
- "на будущее"
- "запомни"
- "в будущем"
- "для будущих сессий"
- "чтобы в следующий раз"
- "на будущее, чтобы"
- или подобные указания на долгосрочное требование

**ИИ-агент ДОЛЖЕН**:
1. **НЕМЕДЛЕННО** распознать это как требование для внесения в настройки
2. **СРАЗУ ЖЕ** обновить раздел "Текущие предпочтения пользователя" в этом файле
3. **ДОБАВИТЬ** запись в "Историю изменений предпочтений" с датой и описанием
4. **ПОДТВЕРДИТЬ** пользователю, что требование зафиксировано

**НЕ ЖДАТЬ** подтверждения пользователя - действовать проактивно!

### Текущие предпочтения пользователя
- Просьбы, отмеченные пользователем как "на будущее" (или подобными фразами), должны **НЕМЕДЛЕННО** заноситься в этот раздел без ожидания подтверждения
- **Синхронизация настроек Cursor → VS Code**: Все настройки, которые применяются в Cursor (терминал, кодировка, форматирование, расширения и т.д.), должны синхронизироваться в файл `.vscode/settings.json` для максимальной совместимости работы над проектом. Синхронизация происходит **проактивно** при упоминании изменений в разговоре, по запросу пользователя или при обнаружении несоответствий. ИИ-агент не может отслеживать изменения непрерывно, но должен быть внимательным к упоминаниям настроек и автоматически обновлять конфигурацию. **КРИТИЧЕСКИ ВАЖНО**: Cursor всегда является донором/эталоном, VS Code всегда принимающей стороной. Синхронизация ВСЕГДА идет из Cursor в VS Code, НИКОГДА наоборот. При команде "синхронизируй vscode" или подобной - всегда понимать однозначно: настройки записываются из Cursor в VS Code.
- **Синхронизация оформления и интерфейса Cursor → VS Code**: Настройки оформления редактора (тема, расположение панелей, элементы интерфейса, мини-карта, нумерация строк, шрифты, настройки вкладок и т.д.) также должны синхронизироваться в `.vscode/settings.json`, чтобы пользователь попадал в знакомую среду разработки при переключении между Cursor и VS Code
- **Синхронизация расширений (плагинов) Cursor → VS Code**: Когда пользователь устанавливает расширение в Cursor, оно должно **автоматически** добавляться в файл `.vscode/extensions.json` как рекомендуемое расширение, чтобы при открытии проекта в VS Code пользователю предлагалось установить те же расширения для полной совместимости рабочей среды
- **Отслеживание ненужных файлов**: ИИ-агент должен проактивно отслеживать и выявлять файлы, которые не используются, являются дубликатами, устаревшими или "болтаются просто так" в проекте. При обнаружении таких файлов - предлагать пользователю удалить их для поддержания чистоты проекта. Не оставлять файлы "просто так" без явной необходимости.
- **Протоколирование дневного чата**: Ручное протоколирование по результатам дня в структуре `history/YYYY/MM-DD.txt`. Дневной лог разбивается на 3 секции: UI (оформление), UX (паттерны взаимодействий), MM (математическая модель). В каждой секции указывается что конкретно было сделано и каким образом, со ссылками на хеши коммитов. Пояснения должны быть полным описанием того, зачем коммит нужен, что он делает, какую функциональность добавляет. Формат: больше конкретики, меньше воды. Формат должен позволять другому ИИ-агенту понять полную картину разработки приложения и восстановить контекст изменений.
- **Стилизация через Bootstrap**: Использовать только Bootstrap классы для стилей, избегать секций `<style>` в HTML файлах. Все стили должны управляться через Bootstrap утилиты и классы. В будущем так и поступать - использовать Bootstrap вместо кастомных CSS стилей.
- **Создание коммитов только по команде пользователя**: Коммиты в Git создаются **ТОЛЬКО** по явной команде пользователя. ИИ-агент НЕ должен создавать коммиты автоматически без прямого указания пользователя. Все изменения могут быть подготовлены (добавлены в staging через `git add`), но коммит выполняется только когда пользователь явно попросит об этом.
- **GitHub Pages**: Проект развёрнут на GitHub Pages. Подбирать решения с учётом статического хостинга (только фронтенд, без серверного кода), корректные относительные пути, загрузка ресурсов по HTTPS, отказ от `content://`. Проверять совместимость с Pages.
- **Архитектурный план**: Хранить актуальный план архитектуры в `architect.md`; при изменении структуры, сущностей или потоков данных обновлять этот файл и ссылаться на него в обсуждениях/решениях.
- **Префиксы файлов**: Использовать систему префиксов из `architect.md` (`<категория>-<сектор?>-<имя>.<ext>`). Поддерживать актуальность пула префиксов в `architect.md`, именовать новые файлы по соглашению и при появлении новых типов дополнять список префиксов.

### История изменений предпочтений
- **2024-12-19**: Добавлено правило об автоматическом занесении просьб "на будущее" в настройки. Пользователь отметил, что все пожелания, которые он отмечает как "на будущее" в тексте, должны восприниматься как требующие внесения в настройки и сразу туда заноситься.
- **2024-12-19**: Добавлено требование синхронизации настроек Cursor → VS Code. Пользователь попросил на будущее настроить синхронизацию всех настроек, которые применяются в Cursor, в файл `.vscode/settings.json` для максимальной совместимости работы над проектом.
- **2024-12-19**: Добавлено требование синхронизации оформления и интерфейса. Пользователь попросил синхронизировать настройки оформления редактора (тема, расположение панелей, элементы интерфейса и прочее) между Cursor и VS Code, чтобы попадать в знакомую среду разработки.
- **2024-12-19**: Изменена тема на светлую (Default Light+). Пользователь предпочитает светлую тему.
- **2024-12-19**: Изменена тема на Quiet Light - светлая тема с приглушенными (muted) цветами для более комфортной работы.
- **2024-12-19**: Изменена тема на GitHub Light - светлая тема с мягкими цветами в стиле GitHub.
- **2024-12-19**: Подключена тема Atom One Light - популярная приглушенная светлая тема (требует расширение akamud.vscode-theme-onelight).
- **2024-12-19**: Синхронизированы настройки VS Code с учетом пользовательских изменений: `workbench.editor.showTabs: "multiple"`, `editor.occurrencesHighlight: "singleFile"`, `workbench.editor.tabActionLocation: "right"`, удалена настройка `workbench.activityBar.visible`.
- **2024-12-19**: Добавлено правило отслеживания ненужных файлов. Пользователь попросил на будущее отслеживать файлы, которые "болтаются просто так" в проекте, и предлагать их удаление для поддержания чистоты проекта.
- **2024-12-19**: Возвращена дефолтная светлая тема (Default Light+). Пользователь отключил тему Atom One Light и вернулся к дефолтной теме.
- **2024-12-19**: Добавлена система логирования чата. Пользователь попросил на будущее вести логи в структуре `history/YYYY/Bot-YY-MM.zip` с файлами `YY-MM-DD.txt`. Запись должна вестись в непрерывном режиме после каждого запроса. Создавать подпапки при смене года и месяца автоматически.
- **2024-12-19**: Изменена схема логирования на простые текстовые файлы. Пользователь попросил упростить логирование без Python. Теперь используется структура `history/YYYY/MM-DD.txt` (простые текстовые файлы вместо zip-архивов). Логируются полные ответы ИИ-агента, а не краткие резюме.
- **2024-12-19**: Изменена схема на ручное протоколирование по результатам дня. Убрано автоматическое логирование. Создан регламент протоколирования: запросы пользователя записываются слово в слово, ответы ИИ-агента адаптируются для понимания другим ИИ-агентом (указывается что именно и как было сделано, результаты, контекст).
- **2024-12-19**: Изменен формат дневного лога: разбиение на 3 секции (UI, UX, MM). В каждой секции указывается что конкретно было сделано и каким образом, со ссылками на хеши коммитов. Пояснения должны быть полным описанием функциональности коммита. Формат: больше конкретики, меньше воды.
- **2024-12-19**: Добавлено требование синхронизации расширений. Пользователь попросил, чтобы плагины (расширения), которые добавляются в Cursor, автоматически добавлялись в `.vscode/extensions.json` для VS Code.
- **2024-12-19**: Добавлена секция "Принципы" с тремя разделами: UI (оформление), UX (паттерны взаимодействий), MM (математическая модель). Добавлено правило обработки команд UI:, UX:, MM: (ММ:) - при получении команды ИИ-агент должен немедленно обновить соответствующий раздел в секции "Принципы" и добавить запись в историю изменений.
- **2024-12-19**: Добавлено правило направления синхронизации настроек: Cursor всегда является донором/эталоном, VS Code всегда принимающей стороной. Синхронизация ВСЕГДА идет из Cursor в VS Code, НИКОГДА наоборот. При команде "синхронизируй vscode" или подобной - всегда понимать однозначно: настройки записываются из Cursor в VS Code.
- **2024-12-19**: Добавлено правило ежедневной проверки актуальности версий Vue.js и Bootstrap. В начале каждого дня ИИ-агент должен проверять свежие версии библиотек, сравнивать с текущими версиями в проекте и немедленно предлагать миграцию и адаптацию при обнаружении новых версий.
- **2024-12-19**: Добавлено правило стилизации через Bootstrap. Пользователь попросил на будущее использовать только Bootstrap классы для стилей, избегать секций `<style>` в HTML файлах. Все стили должны управляться через Bootstrap утилиты и классы.
- **2025-12-07**: Добавлено правило создания коммитов только по команде пользователя. Пользователь попросил на будущее создавать коммиты только по его явной команде, а не автоматически. ИИ-агент может подготавливать изменения (добавлять в staging), но коммит выполняется только когда пользователь явно попросит об этом.
- **2025-12-07**: Добавлено требование учитывать работу на GitHub Pages (статический фронтенд, HTTPS, относительные пути, без серверного кода и `content://`).
- **2025-12-08**: Добавлено требование вести архитектурный план в `architect.md` и обновлять его при изменениях структуры/сущностей.
- **2025-12-08**: Добавлено требование использовать систему префиксов для файлов и поддерживать её актуальность в `architect.md`; дополнять пул префиксов при появлении новых типов.
- **2025-12-08**: Уточнён регламент коммита: имя — до коммита, описание — в дневной лог под этим именем (создать лог при необходимости, указывать только название без хеша), обновить `lastCommitMessage` в `core/cfg-app.js` (шаг 3), затем коммит с этим именем. **ВАЖНО**: НЕ использовать `git commit --amend` для добавления хеша в лог — это создаёт замкнутый круг. Хеши обновляются при ревизии дневного лога.
- **2025-12-08**: Усилен регламент обновления `lastCommitMessage`: добавлен яркий обязательный чеклист с 4 шагами, где Шаг 3 (обновление `lastCommitMessage` в `core/cfg-app.js`) выделен как КРИТИЧЕСКИ ВАЖНЫЙ и ОБЯЗАТЕЛЬНЫЙ. Без выполнения этого шага коммит считается неполным. Пользователь отметил, что ИИ-агент забывал обновлять эту переменную перед коммитом.
- **2025-12-08**: Добавлено правило обратной совместимости данных. При изменении структуры сохраненных данных (localStorage, JSON-файлы, IndexedDB) ИИ-агент должен предлагать пользователю реализацию обратной совместимости, объяснять риски и предоставлять выбор. Правило применяется чаще всего при работе с экспортом/импортом настроек, переименовании полей, миграции схем данных.

---

## Принципы

> **ВАЖНО**: Этот раздел содержит принципы разработки приложения, разделенные на три категории. ИИ-агент должен следовать этим принципам при разработке и обновлять их по командам пользователя.

### ⚠️ ПРАВИЛО ОБРАБОТКИ КОМАНД UI:, UX:, MM:

**ОБЯЗАТЕЛЬНО**: Когда пользователь использует команды:
- `UI:` - требование фиксации правил или пожеланий относительно интерфейса: оформление, взаимодействие, анимации (UI - User Interface)
- `UX:` - требование фиксации правил относительно паттернов взаимодействий (UX - User Experience). **Примечание**: UX является частью UI, поэтому правила UX также добавляются в раздел "UI (интерфейс)"
- `MM:` или `ММ:` - требование фиксации правил или пожеланий относительно математической модели (MM - Mathematical Model)

**ИИ-агент ДОЛЖЕН**:
1. **НЕМЕДЛЕННО** распознать команду (UI:, UX:, MM: или ММ:)
2. **СРАЗУ ЖЕ** обновить соответствующий раздел в секции "Принципы" этого файла
   - Команды `UI:` и `UX:` обе идут в раздел "UI (интерфейс)"
   - Команда `MM:` или `ММ:` идет в раздел "MM (математическая модель)"
3. **ДОБАВИТЬ** запись в "Историю изменений предпочтений" с датой и описанием
4. **ПОДТВЕРДИТЬ** пользователю, что принцип зафиксирован

**НЕ ЖДАТЬ** подтверждения пользователя - действовать проактивно!

**Примеры команд:**
- `UI: использовать светлую цветовую схему` → добавить в раздел "UI (интерфейс)"
- `UI: все действия должны быть обратимыми` → добавить в раздел "UI (интерфейс)"
- `MM: все расчеты должны быть точными до 2 знаков после запятой` → добавить в раздел "MM (математическая модель)"

**Примечание**: Команды `UX:` также направляются в раздел "UI (интерфейс)", так как UX (User Experience) является неотъемлемой частью UI. Веб-компоненты содержат и визуальное оформление, и логику взаимодействия одновременно.

### UI (интерфейс)

*Принципы и правила интерфейса приложения: оформление, взаимодействие (UX), анимации, accessibility*

- *(Пока пусто - принципы будут добавляться по командам UI: или UX:)*

### MM (математическая модель)

*Принципы математической модели, расчетов и обработки данных*

- *(Пока пусто - принципы будут добавляться по командам MM: или ММ:)*

---

## Особенности поведения ИИ-агента

### Стиль работы
- **Язык общения**: Русский (по умолчанию)
- **Подход**: Проактивный, но не создавать файлы без явного запроса
- **Документация**: Создавать только по запросу пользователя
- **Обновление конфига**: При получении новых просьб о стиле работы - ОБЯЗАТЕЛЬНО обновлять раздел "Пользовательские предпочтения" в этом файле
- **Обработка просьб "на будущее"**: См. раздел "ПРАВИЛО ОБРАБОТКИ ПРОСЬБ 'НА БУДУЩЕЕ'" выше - это КРИТИЧЕСКИ ВАЖНОЕ правило!
- **Обработка команд UI:, UX:, MM: (ММ:)**: См. раздел "ПРАВИЛО ОБРАБОТКИ КОМАНД UI:, UX:, MM:" в секции "Принципы" - это КРИТИЧЕСКИ ВАЖНОЕ правило! При получении команды UI:, UX:, MM: или ММ: - НЕМЕДЛЕННО обновлять соответствующий раздел в секции "Принципы". **Примечание**: UX является частью UI, поэтому команды UI: и UX: обе обновляют раздел "UI (интерфейс)".

### Технические особенности
- **Терминал**: PowerShell имеет проблемы с командами (искажение команд), использовать Git Bash или полный путь к исполняемым файлам
- **Кодировка файлов**: UTF-8
- **Окончания строк**: CRLF (Windows), но Git настроен на автоматическое преобразование

### Приоритеты
1. Сохранение работоспособности кода
2. Следование лучшим практикам
3. Чистота рабочего дерева Git
4. Валидность HTML разметки

### ⚠️ ПРАВИЛО: Обратная совместимость данных

**ОБЯЗАТЕЛЬНО**: При изменении структуры сохраненных данных (localStorage, IndexedDB, JSON-файлы экспорта) - **ВСЕГДА** предлагать пользователю реализацию обратной совместимости.

**Когда применять:**
- Переименование полей в JSON
- Изменение формата хранения (например: строка → объект)
- Миграция структуры localStorage/IndexedDB
- Обновление схемы экспорта/импорта
- Изменение версий API или форматов данных

**Что делать:**
1. **Предложить пользователю** добавить обратную совместимость
2. **Объяснить**, в чем будет состоять совместимость:
   - Какие старые форматы будут поддерживаться
   - Как будет происходить миграция данных
   - Какие риски при отсутствии совместимости (потеря данных, ошибки импорта и т.д.)
3. **Показать пример кода** для поддержки старого и нового формата
4. **Дать выбор пользователю**: делать совместимость сейчас или отложить

**Пример:**
```javascript
// Пользователь: "переименуй apiKey в apiKeyPerplexity"
// ИИ-агент должен предложить:

// Вариант 1: Без обратной совместимости (быстро, но может сломать существующие данные)
if (settings.secureData.apiKeyPerplexity) { ... }

// Вариант 2: С обратной совместимостью (медленнее, но безопасно)
if (settings.secureData.apiKeyPerplexity) {
  // Новый формат
} else if (settings.secureData.apiKey) {
  // Старый формат (для совместимости)
  // Автоматически мигрируем в новый
}
```

**Частые случаи:**
- **Экспорт/импорт настроек** - чаще всего требует совместимости
- **localStorage ключи** - при переименовании учитывать существующие данные
- **JSON-схемы** - версионировать (_version) и поддерживать старые версии
- **Миграция БД** - всегда с проверкой наличия данных в старом формате

**Исключения** (когда совместимость НЕ нужна):
- Проект на ранней стадии разработки (до первого релиза)
- Пользователь явно сказал "не надо обратной совместимости"
- Изменения не влияют на сохраненные данные (только UI/логика)

## Структура проекта
```
BOT/
├── index.html          # Главный HTML файл
├── .git/              # Git репозиторий
├── .vscode/           # Настройки VS Code (для совместимости с Cursor)
│   ├── settings.json  # Настройки проекта (синхронизируются с Cursor)
│   ├── extensions.json # Рекомендуемые расширения
│   ├── cspell-dict.txt # Пользовательский словарь для проверки орфографии
│   └── README.md      # Документация по настройкам
├── history/           # Логи чата
│   └── YYYY/          # Папки по годам
│       └── MM-DD.txt  # Дневные логи (например: 12-19.txt)
└── .cursorrules       # Правила работы ИИ-агента (этот файл)
```

## Заметки для будущих сессий
- Репозиторий настроен корректно для Windows
- Git Bash установлен и доступен
- Первый коммит создан: "Initial commit: add minimal HTML structure"
- Файл `.gitignore` отсутствует (можно добавить при необходимости)

## Рекомендации для улучшения
- [ ] Добавить `.gitignore` для исключения временных файлов
- [ ] Настроить удаленный репозиторий (GitHub/GitLab) при необходимости
- [ ] Добавить структуру проекта (CSS, JS файлы) по мере развития

---
*Файл обновляется по мере развития проекта и изменения требований*

