# Правила работы ИИ-агента для проекта

> **ВАЖНО**: Этот файл автоматически читается Cursor в начале каждой сессии. ИИ-агент должен следовать всем правилам, описанным здесь.

## ⚠️ КРИТИЧЕСКИ ВАЖНО - Контроль качества выполнения

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен контролировать свое контекстное окно и следить за тем, чтобы документация и правила проекта всегда были доступны для проверки.

**После выполнения каждой задачи пользователя ИИ-агент ДОЛЖЕН**:
1. **Проверить доступность документации**: Убедиться, что ключевые документы проекта (`.cursorrules`, `architect.md`, `ui/guide-ii.md`) присутствуют в контекстном окне или доступны для чтения
2. **Провести самопроверку качества выполнения**: Сверить выполненную работу с правилами и документацией проекта:
   - Соответствие архитектурным принципам (`architect.md`)
   - Соответствие принципам UI/UX (`ui/guide-ii.md`)
   - Соблюдение правил работы ИИ-агента (`.cursorrules`)
   - Согласованность между документами
   - Обновление документации при необходимости
3. **Исправить ошибки самостоятельно**: При обнаружении несоответствий или ошибок - немедленно исправить их без запроса пользователя
4. **Обновить документацию**: Если в процессе выполнения задачи были внесены изменения, влияющие на структуру проекта, принципы или правила - обновить соответствующие документы

**Цель**: Обеспечить высокое качество выполнения задач и соответствие всех изменений установленным правилам и принципам проекта. ИИ-агент должен быть проактивным в контроле качества, а не полагаться только на пользователя.

## Общая информация о проекте
- **Название проекта**: BOT (Statistics/ToDo)
- **Тип проекта**: Веб-приложение (HTML)
- **Расположение**: `D:\Clouds\AO\OneDrive\Portfolio - CV\Refactoring\ToDo\Statistics\BOT`
- **Репозиторий Git**: Инициализирован, ветка `master`

### ⚠️ КРИТИЧЕСКИ ВАЖНО - Работа с файлами за пределами проекта
- **Файлы за пределами проекта** (вне папки `D:\Clouds\AO\OneDrive\Portfolio - CV\Refactoring\ToDo\Statistics\BOT`) рассматриваются **ТОЛЬКО как примеры кода** для понимания логики или структуры.
- **НИКОГДА** не редактировать, не изменять, не коммитить файлы за пределами проекта.
- **НИКОГДА** не добавлять файлы из других проектов в staging или коммиты текущего проекта.
- При использовании кода из файлов других проектов - только **читать** их для понимания, затем **реализовывать аналогичную логику** в файлах текущего проекта.
- Если пользователь предоставляет файл из другого проекта - это **пример для изучения**, а не для редактирования.

### ⚠️ КРИТИЧЕСКИ ВАЖНО - Работа с папкой old_app_not_write
- **Папка `old_app_not_write/`** содержит примеры из старого предыдущего приложения (пользователь называет файлы из этой папки "старые файлы").
- **НИКОГДА** не редактировать, не изменять, не коммитить файлы из папки `old_app_not_write/`.
- **НИКОГДА** не добавлять файлы из `old_app_not_write/` в staging или коммиты текущего проекта.
- При использовании кода из файлов `old_app_not_write/` - только **читать** их для понимания, затем **реализовывать аналогичную логику** в файлах текущего проекта.
- Папка `old_app_not_write/` добавлена в `.gitignore` и не отслеживается Git.
- **Терминология**: Когда пользователь упоминает "старые файлы", он имеет в виду файлы из папки `old_app_not_write/`.
- **⚠️ Комментирование при работе со старыми файлами**: При переносе функциональности из старых файлов в новое приложение **ОБЯЗАТЕЛЬНО** комментировать всё предельно подробно и полно. Комментарии должны объяснять:
  - Что делает код (назначение)
  - Откуда взят код (ссылка на старый файл)
  - Почему используется именно такой подход
  - Какие переменные и функции сохраняются для преемственности
  - Какие изменения внесены и почему
- **⚠️ Предостережение о замене интервалов**: При замене интервалов дельт изменения цены (например, замена 60d и 90d на 14d и 200d) **ОБЯЗАТЕЛЬНО** провести анализ и пересмотр весов и коэффициентов в математической модели. Замененные интервалы могут требовать корректировки:
  - Весов в функциях расчета (PRC-веса, веса для CPT, CD, CGR)
  - Пороговых значений (thresholds)
  - Коэффициентов адаптации
  - Временных констант (tau, gamma и т.д.)
- **⚠️ План миграции математической модели**: См. файл `migration-plan.md` в корне проекта для подробного плана миграции математической модели из старого приложения. План содержит пошаговые инструкции, проблемы миграции и текущий статус. При работе над миграцией математической модели **ОБЯЗАТЕЛЬНО** следовать плану и обновлять статус этапов по мере прогресса.

## Настройки Git
- **Терминал**: Использовать Git Bash (`C:\Program Files\Git\bin\bash.exe`)
- **Команды Git**: Выполнять через полный путь `"C:\Program Files\Git\bin\git.exe"` (из-за проблем с PowerShell)
- **Автор коммитов**: `ao <ponomarev.ux@gmail.com>`
- **Формат коммитов**: Обычные сообщения на русском или английском языке

## Регулярные действия ИИ-агента

### ⚠️ При открытии нового рабочего дня

**ОБЯЗАТЕЛЬНО**: При получении команды на открытие нового рабочего дня (фразы типа "Открываем новый рабочий день", "Начинаем день", "Новый день" и т.п.) ИИ-агент ДОЛЖЕН:

1. **Ознакомиться с документами, связанными с `.cursorrules`**:
   - Прочитать `.cursorrules` для понимания правил работы ИИ-агента
   - Прочитать `architect.md` для понимания архитектурных принципов и структуры проекта
   - Прочитать `ui/guide-ii.md` для понимания принципов интерфейса и паттернов взаимодействий
   - Убедиться, что все ключевые документы доступны в контекстном окне

2. **Проверить актуальность зависимостей**:
   - Проверить актуальность версий Vue.js и Bootstrap (см. раздел "Проверка актуальности зависимостей")
   - Сравнить текущие версии в проекте с последними доступными версиями
   - Предложить миграцию при обнаружении новых версий

3. **Проверить состояние проекта**:
   - Проверить статус репозитория (`git status`)
   - Просмотреть последние коммиты для понимания контекста
   - Проверить последний дневной лог для понимания последних изменений

4. **Создать открывающий коммит**:
   - **ОБЯЗАТЕЛЬНО**: После выполнения всех проверок создать открывающий коммит с именем "Start of day: [дата по MSK]" (например: "Start of day: 12-13")
   - Следовать обязательному чеклисту перед коммитом (см. раздел "ОБЯЗАТЕЛЬНЫЙ ЧЕКЛИСТ ПЕРЕД КАЖДЫМ КОММИТОМ")
   - Создать файл дневного лога `history/YYYY/MM-DD.txt` для текущей даты, если его еще нет
   - Записать в дневной лог информацию об открытии дня в секции Architect
   - Обновить `lastCommitMessage` в `core/cfg-app.js` на название открывающего коммита
   - Выполнить коммит с обновленными файлами (`.cursorrules`, дневной лог, `core/cfg-app.js`)

**Цель**: Обеспечить полное понимание текущего состояния проекта, правил работы и архитектурных принципов перед началом работы над новыми задачами, а также зафиксировать начало рабочего дня в истории репозитория.

### При работе с Git
1. **Перед коммитом**:
   - Проверить статус репозитория
   - Убедиться, что все изменения добавлены в staging
   - Использовать полный путь к git.exe для команд

2. **Создание коммитов**:
   - **КРИТИЧЕСКИ ВАЖНО**: Коммиты создаются **ТОЛЬКО** по явной команде пользователя. ИИ-агент НЕ должен создавать коммиты автоматически без прямого указания пользователя.
   - **НЕ предлагать** делать коммиты пользователю. Пользователь сам помнит, когда нужно делать коммиты, и попросит об этом явно.
   - **НЕ выполнять** никаких операций с репозиторием (команды git, stage, push и т.п.) без прямого запроса или команды пользователя.
   - **НЕ использовать `git commit --amend`** для синхронизации хешей коммитов с дневным логом: после каждого amend хеш коммита изменяется, что приводит к необходимости повторного обновления лога, создавая циклическую зависимость. Хеши коммитов добавляются в дневной лог только при его ревизии, а не в момент создания коммита.
   - Использовать понятные сообщения коммитов
   - Группировать логически связанные изменения

   ### ⚠️ ОБЯЗАТЕЛЬНЫЙ ЧЕКЛИСТ ПЕРЕД КАЖДЫМ КОММИТОМ (НЕ ПРОПУСКАТЬ!)

   **ПРИ ПОЛУЧЕНИИ КОМАНДЫ НА СОЗДАНИЕ КОММИТА — ВЫПОЛНИТЬ В СТРОГОЙ ПОСЛЕДОВАТЕЛЬНОСТИ:**

   **ШАГ 1: Сформировать имя коммита**
   - Придумать краткое и понятное название (например: "Fix commit hash in history")

   **ШАГ 2: Записать в дневной лог**
   - Зафиксировать описание изменений в `history/YYYY/MM-DD.txt`
   - Создать файл лога, если его еще нет
   - **ВАЖНО**: Указывать только название коммита без хеша
   - Хеш добавляется позже при ревизии дневного лога
   - **КРИТИЧЕСКИ ВАЖНО**: В дневной лог должны быть внесены **ВСЕ** изменения из коммита. Если в коммите несколько изменений (например, UI, MM, Architect), то каждое изменение должно быть описано в соответствующей секции дневного лога. **НЕ создавать коммит, пока все изменения не описаны в дневном логе!**

   **ШАГ 3: ⚠️ ОБНОВИТЬ lastCommitMessage (ОБЯЗАТЕЛЬНО!)**
   - **КРИТИЧЕСКИ ВАЖНО**: Открыть файл `core/cfg-app.js`
   - Найти строку: `lastCommitMessage: '...'`
   - Заменить значение на имя коммита из Шага 1
   - **ЭТОТ ШАГ НЕЛЬЗЯ ПРОПУСКАТЬ!** Без него сплэш не покажет актуальный коммит

   **ШАГ 4: Выполнить коммит**
   - `git add` нужные файлы (включая `core/cfg-app.js`)
   - `git commit -m "название из Шага 1"`
   - Проверить статус: `git status`

   **ВАЖНО**:
   - **НЕ использовать `git commit --amend`** для добавления хеша в дневной лог (создаёт циклическую зависимость)
   - Хеши коммитов обновляются отдельно при ревизии дневного лога
   - **ШАГ 3 ОБЯЗАТЕЛЕН** — без обновления `lastCommitMessage` коммит считается неполным!

3. **⚠️ Завершение рабочего дня**:

   **ОБЯЗАТЕЛЬНО**: Когда пользователь использует фразы типа:
   - "Завершаем рабочий день"
   - "завершаем день разработки"
   - "завершаем день"
   - или подобные указания на завершение рабочего дня

   **ИИ-агент ДОЛЖЕН**:
   1. **Распознать команду** на завершение дня
   2. **Провести ревизию дневного лога**:
      - Открыть файл дневного лога `history/YYYY/MM-DD.txt` для текущей даты
      - Проверить соответствие записей в логе с коммитами в репозитории
      - Сопоставить названия коммитов из лога с реальными коммитами через `git log`
      - Если обнаружены несоответствия (коммит в логе отсутствует в репозитории, или коммит в репозитории отсутствует в логе) - **сообщить пользователю** с детализацией проблем
   3. **Расставить хеши коммитов**:
      - Для каждого упоминания коммита в формате `### Коммит: [название]` найти соответствующий коммит в репозитории
      - Добавить хеш коммита перед названием: `### Коммит: [хеш] - [название]`
      - Если коммит не найден - оставить без хеша и отметить в отчете
   4. **Создать завершающий коммит**:
      - **ВАЖНО**: В отличие от обычного коммита, запись о действиях завершающего коммита **НЕ делается** в дневной лог
      - **⚠️ КРИТИЧЕСКИ ВАЖНО - Определение даты финального коммита**: Дата в имени финального коммита должна быть **предыдущего дня по MSK** (московское время, UTC+3), а не текущего дня. Это важно, когда пользователь работает заполночь: даже если коммит создается в 4 утра нового дня, он должен относиться к вчерашнему дню. ИИ-агент должен вычислить предыдущий день по MSK и использовать его в имени коммита (например: если текущее время MSK - 4:00 13 декабря, то финальный коммит должен быть "End of day: 12-12", а не "End of day: 12-13")
      - Обновить `lastCommitMessage` в `core/cfg-app.js` на название завершающего коммита (например: "End of day: [дата предыдущего дня по MSK]")
      - Выполнить коммит: `git add` (включая обновленный дневной лог и `core/cfg-app.js`), `git commit -m "End of day: [дата предыдущего дня по MSK]"`
   5. **Вывести краткий отчет о дневном прогрессе**:
      - Краткое резюме (максимально кратко, по пунктам) о том, что было сделано за день
      - Информация о соответствии дневного лога репозиторию
      - Количество коммитов за день
      - Другие важные и полезные сведения (статус проекта, версии библиотек, готовность к следующему дню и т.п.)

   **ВАЖНО**:
   - Ревизия дневного лога проводится **ПЕРЕД** созданием завершающего коммита
   - Если обнаружены проблемы с соответствием - **НЕ создавать** завершающий коммит до их решения или явного указания пользователя
   - Завершающий коммит создается **ТОЛЬКО** после успешной ревизии и расстановки хешей

4. **Проверка состояния**:
   - Регулярно проверять `git status`
   - Отслеживать чистоту рабочего дерева

### Сопровождение документации проекта

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен поддерживать актуальность всей документации проекта при внесении изменений в код или структуру проекта.

**⚠️ КРИТИЧЕСКИ ВАЖНО - Понимание команды "внеси в правила"**:

Когда пользователь использует фразы типа:
- "внеси в правила"
- "добавь в правила"
- "зафиксируй в правилах"
- "внеси в документацию"
- или подобные указания на фиксацию правил

**ИИ-агент ДОЛЖЕН**:
1. **НЕ предполагать автоматически**, что речь идет только о `.cursorrules`
2. **Внимательно проанализировать** содержание просьбы и определить, к какому типу правил она относится:
   - **Правила работы ИИ-агента** (работа с Git, протоколирование, синхронизация настроек, понимание команд) → `.cursorrules`
   - **Архитектурные правила** (принципы разработки, стандарты, технические ограничения, математическая модель) → `architect.md`
   - **Правила UI/UX** (оформление, паттерны взаимодействий) → `ui/guide-ii.md`
   - **Смешанные правила** → декомпозировать и разместить в соответствующих документах
3. **Распределить изменения** по соответствующим местам в документах, даже если это требует разбора и декомпозиции просьбы
4. **Обеспечить приоритетность и важность** изменений независимо от того, в какой документ они вносятся

**Цель**: Правильная классификация и размещение правил в соответствующих документах для поддержания структурированности и согласованности документации проекта.

**Список документов для сопровождения:**
- **`.cursorrules`** — правила работы ИИ-агента с проектом
- **`architect.md`** — архитектурный план проекта, принципы математической модели, технические ограничения
- **`ui/guide-ii.md`** — руководство по интерфейсу и взаимодействию (принципы оформления и UX паттерны)

**Исключения (НЕ требуют сопровождения):**
- **`docs/`** — папка с черновиками, сторонними документами, заметками и прочими материалами, не являющимися частью основной документации проекта

**Когда обновлять документацию:**
- При изменении структуры проекта (добавление/удаление папок, файлов)
- При изменении архитектурных решений (новые компоненты, паттерны, ограничения)
- При изменении принципов UI/UX (новые стили, паттерны взаимодействия)
- При изменении правил работы ИИ-агента
- При добавлении новых сущностей, сервисов или компонентов
- При изменении стандартов разработки или технических ограничений

**Как обновлять:**
- Обновлять соответствующий документ одновременно с изменением кода
- **Тщательно проверять согласованность между документами** (см. раздел "Отслеживание согласованности архитектурных правил")
- **Проверять документацию насквозь, а не "кусками"** — при любом изменении проверять все связанные разделы во всех документах
- Обновлять ссылки в других документах при перемещении или переименовании разделов
- Обновлять структуру проекта в `architect.md` при добавлении/удалении файлов или папок
- Обновлять раздел "Текущее размещение файлов" в `architect.md` при добавлении новых файлов
- Сохранять структуру и формат документации

**ВАЖНО**: 
- Документация должна оставаться актуальной и отражать текущее состояние проекта. Отставание документации от кода недопустимо.
- **Критически важно**: При любом изменении структуры проекта (добавление файлов, папок, документов) необходимо обновить раздел "Структура проекта" в `architect.md` и раздел "Текущее размещение файлов" (если добавлен новый файл).
- **Не допускать дублирования** информации в структуре проекта — каждый элемент должен быть указан один раз.

### При работе с файлами
1. **HTML файлы**:
   - Использовать минимальную валидную HTML5 разметку
   - Язык по умолчанию: `ru`
   - Кодировка: UTF-8
   - Включать viewport meta для адаптивности
   - **Стилизация**: Приоритет использования Bootstrap классов и утилит для стилизации. Минимизировать кастомные CSS стили, inline стили и секции `<style>`. При необходимости кастомизации предпочитать Bootstrap утилиты и модификаторы классов. Избегать создания собственных CSS правил, если аналогичная функциональность доступна через Bootstrap.
   - **⚠️ Вынесение стилей в отдельные CSS файлы**: Все кастомные CSS стили должны выноситься в отдельные файлы в структуре `ui/styles/`. Стили группируются по компонентам: `ui/styles/header.css`, `ui/styles/footer.css`, `ui/styles/splash.css`, `ui/styles/dropdown.css`, `ui/styles/layout.css` и т.д. Inline стили (`style="..."`) и блоки `<style>` в HTML файлах должны заменяться на CSS классы в соответствующих файлах. Это уменьшает связанность кода, улучшает переиспользование и упрощает возможную инкапсуляцию компонентов. Динамические стили в JavaScript (например, вычисляемые значения) могут оставаться в JS, но базовые стили должны быть в CSS файлах.
   - **⚠️ Маркировка контейнеров**: См. раздел "Маркировка контейнеров" в `architect.md` - система автоматической маркировки значимых контейнеров через CSS классы `avto-{hash}` для навигации в коде. ИИ-агент должен автоматически добавлять классы `avto-{Base58_8символов}` к значимым контейнерам (основные секции, функциональные блоки, корневые контейнеры компонентов), которые не имеют JS/CSS зависимостей. Осмысленные ID используются только для JS-зависимых элементов.
   - **⚠️ Детерминированные хэши для экземпляров компонентов**: См. раздел "ОБЯЗАТЕЛЬНОЕ ПРАВИЛО: Детерминированные хэши для экземпляров компонентов" в `architect.md` - все экземпляры переиспользуемых компонентов должны иметь детерминированные уникальные хэши через computed свойство `instanceHash`, которое генерирует стабильный Base58 хэш на основе уникального идентификатора экземпляра (из props компонента). Хэш генерируется через утилиту `window.hashGenerator.generateMarkupClass(uniqueId)`. ИИ-агент должен проверять наличие `instanceHash` во всех переиспользуемых компонентах и добавлять его при создании новых компонентов.
   - **⚠️ Стандартные размеры чекбоксов**: См. раздел "Стандарты разработки" в `architect.md` - все чекбоксы в проекте должны иметь единый стандартный размер 13x13px. Размеры фиксируются через глобальное CSS правило в `ui/styles/layout.css` для класса `.form-check-input`. ИИ-агент должен отслеживать расхождение габаритов чекбоксов от стандартных 13x13px и соблюдать стандартные размеры при создании или изменении компонентов с чекбоксами. При обнаружении чекбоксов с размерами, отличными от 13x13px, необходимо исправить их на стандартные размеры.
   - **⚠️ Терминология "страница"**: Под словом "страница" пользователь всегда имеет в виду контейнер с классом `avto-X7pL2nQ` (корневой контейнер контента приложения). ИИ-агент должен понимать, что когда пользователь говорит "страница", речь идет именно об этом контейнере.

2. **Создание новых файлов**:
   - Проверять наличие файла перед созданием
   - Использовать правильную структуру проекта
    - **Отслеживание неиспользуемых файлов**: Проактивно выявлять и предлагать удаление файлов, которые не используются в проекте, являются дубликатами или устаревшими. При обнаружении таких файлов - предложить пользователю удалить их для поддержания чистоты кодовой базы.
    - **Не запускать внешние HTTP-запросы** (CoinGecko, CDN и т.п.) или иные операции вне `#app`, пока сплэш экран не разблокирован.
    - **Размещать компоненты/разметку внутри `<div id="app">`**: Vue-монтирует только то, что находится в пределах `#app`, поэтому сплэш-экраны, модалки, новые UI-блоки и контейнеры должны рендериться внутри `div` с id `app`.

3. **Проверка актуальности зависимостей**:
   - **Ежедневно, в начале каждого дня**: Проверять актуальность свежих версий Vue.js и Bootstrap
   - Использовать веб-поиск для проверки последних стабильных версий
   - Сравнивать текущие версии в проекте с последними доступными версиями
   - **Немедленно предлагать миграцию и адаптацию** при обнаружении новых версий
   - При миграции проверять breaking changes и обновлять код соответственно
   - Обновлять CDN ссылки в HTML файлах
   - Тестировать работоспособность после обновления

3. **Протоколирование дневного чата**:

   **Структура и формат:**
   - **Структура**: `history/YYYY/MM-DD.txt` (например: `history/2024/12-19.txt`)
   - **Режим записи**: Ручное протоколирование по результатам дня (не автоматическое)
   - **⚠️ Определение даты**: Дата создания дневного лога и указание дат в документации определяются по московскому времени (MSK, UTC+3). ИИ-агент должен учитывать московский часовой пояс при создании файла дневного лога, указании даты в заголовке и при заносе дат в любую документацию проекта (`.cursorrules`, `architect.md`, `ui/guide-ii.md` и другие документы).
   - **Формат записи**: Дневной лог разбивается на **4 секции**: UI, UX, MM, Architect (позже будет добавлена секция DOCS)

   **Регламент протоколирования:**

   **Структура дневного лога:**
   - Лог должен быть разбит на секции: **UI (оформление)**, **UX (паттерны взаимодействий)**, **MM (математическая модель)**, **Architect (архитектура, настройки)**, **DOCS (документация)** - будет добавлена позже
   - В каждой секции описываются только изменения, относящиеся к соответствующей категории
   - Формат записи: конкретные технические детали, избегать избыточных описаний

   **Для каждой секции (UI, UX, MM, Architect, DOCS):**
   - Указывать **что конкретно было сделано** (конкретные действия, изменения в коде)
   - Указывать **каким образом** (методы, инструменты, команды, файлы)
   - При упоминании коммита указывать его название. Хеш коммита добавляется при ревизии дневного лога, когда обнаруживаются записи с названиями коммитов без хешей.
   - Пояснения должны быть **полным описанием** того:
     * Зачем коммит нужен
     * Что он делает
     * Какую функциональность добавляет
   - Формат должен позволять другому ИИ-агенту понять полную картину разработки и восстановить контекст изменений

   **Пример формата секции:**
   ```
   ## UI (оформление)

   ### Коммит: 52f6e11 - "Add Font Awesome icons and theme toggle button with dark/light mode support"
   - **Что сделано**: Добавлена кнопка переключения темы (светлая/темная) с иконками Font Awesome
   - **Как сделано**:
     * Подключен Font Awesome 6.5.1 через CDN в `<head>` (link rel="stylesheet")
     * Добавлена кнопка в `index.html` с классом `btn btn-outline-secondary rounded-circle`
     * Реализован метод `toggleTheme()` в Vue.js для переключения между 'light' и 'dark'
     * Добавлен метод `applyTheme()` для применения темы к элементу `<html>` через атрибут `data-bs-theme`
     * Реализовано сохранение выбранной темы в `localStorage` для персистентности
     * Использованы иконки `fa-moon` (для светлой темы) и `fa-sun` (для темной темы)
   - **Функциональность**: Пользователь может переключать тему приложения между светлой и темной, выбор сохраняется между сессиями
   ```

   **Когда протоколировать:**
   - По результатам дня или по запросу пользователя
   - При завершении значимых этапов работы
   - При необходимости зафиксировать важные решения

   **Автоматическое создание**: Создавать подпапки при смене года автоматически при первом протоколировании

3. **Синхронизация настроек Cursor → VS Code**:

   **⚠️ КРИТИЧЕСКИ ВАЖНО - Направление синхронизации:**
   - **Cursor** - всегда **донор/эталон** (источник настроек)
   - **VS Code** - всегда **принимающая сторона** (получатель настроек)
   - Синхронизация **ВСЕГДА** идет из Cursor в VS Code
   - **НИКОГДА** не наоборот - VS Code никогда не является источником настроек
   - При команде "синхронизируй vscode" или подобной - всегда понимать однозначно: настройки записываются из Cursor в VS Code

   **Механизм отслеживания изменений:**
   - **Проактивное обновление**: ИИ-агент автоматически обновляет `.vscode/settings.json` когда:
     * Пользователь упоминает изменение настройки в разговоре (например: "изменил тему на темную", "настроил автосохранение")
     * Пользователь устанавливает расширение (автоматически добавляется в `.vscode/extensions.json`)
     * Пользователь добавляет слово в словарь орфографии (автоматически добавляется в `.vscode/cspell-dict.txt`)
     * Пользователь просит изменить настройку проекта
   - **По запросу пользователя**: При явной просьбе синхронизировать настройки (например: "синхронизируй настройки", "обнови конфиг")
   - **При упоминании настроек**: Если пользователь упоминает настройку в контексте работы над проектом - предложить обновить её в `.vscode/settings.json`

   **ВАЖНО**: ИИ-агент НЕ может отслеживать изменения настроек Cursor в реальном времени (непрерывно), так как работает только во время сессий чата. Синхронизация происходит:
   1. Автоматически при упоминании изменений в разговоре
   2. По явной просьбе пользователя
   3. Проактивно при обнаружении несоответствий

   **Что синхронизируется:**
   - Поддерживать совместимость настроек терминала, кодировки, форматирования
   - **Синхронизировать настройки оформления**: тема, расположение панелей, элементы интерфейса, мини-карта, нумерация строк, шрифты, настройки вкладок, breadcrumbs и другие визуальные настройки
   - **Синхронизировать расширения**: при установке расширения в Cursor - **НЕМЕДЛЕННО** добавлять его в `.vscode/extensions.json` как рекомендуемое расширение, указывая правильный идентификатор расширения (например, `"esbenp.prettier-vscode"`)
   - **Синхронизировать настройки редактора**: автодополнение, IntelliSense, Emmet, сниппеты, автозакрытие скобок/кавычек, работа с несколькими курсорами, подсветка кода
   - **Синхронизировать настройки работы с файлами**: автосохранение, горячий выход, ассоциации файлов, исключения для watcher
   - **Синхронизировать настройки поиска**: умный поиск, игнорирование файлов, предпросмотр замены
   - **Синхронизировать настройки Git**: интеграция Git, декорации, timeline, merge editor
   - **Синхронизировать настройки терминала**: стиль курсора, размер шрифта, поведение копирования
   - **Синхронизировать настройки работы с кодом**: code actions, code lens, folding, color decorators
   - **Синхронизировать настройки проверки орфографии**: словари, пользовательские слова, языки проверки, исключения

## Пользовательские предпочтения и просьбы по стилю работы

> **КРИТИЧЕСКИ ВАЖНО**: Этот раздел содержит все просьбы и требования пользователя относительно стиля работы над проектом. ИИ-агент ОБЯЗАН следовать этим правилам во всех сессиях.

> **ВАЖНО - Язык документации**: Документация проекта (`.cursorrules`, `architect.md` и другие файлы) предназначена для ИИ-агентов, а не для пользователя. Использовать профессиональную техническую терминологию, избегать жаргона, сленга и разговорных выражений. Формулировки должны быть точными, однозначными и технически корректными. При описании процессов и правил использовать стандартную терминологию разработки программного обеспечения.

### ⚠️ ПРАВИЛО ОБРАБОТКИ ПРОСЬБ "НА БУДУЩЕЕ"
**ОБЯЗАТЕЛЬНО**: Когда пользователь использует фразы типа:
- "на будущее"
- "запомни"
- "в будущем"
- "для будущих сессий"
- "чтобы в следующий раз"
- "на будущее, чтобы"
- или подобные указания на долгосрочное требование

**ИИ-агент ДОЛЖЕН**:
1. **НЕМЕДЛЕННО** распознать это как требование для внесения в настройки
2. **СРАЗУ ЖЕ** обновить раздел "Текущие предпочтения пользователя" в этом файле
3. **ДОБАВИТЬ** запись в "Историю изменений предпочтений" с датой и описанием
4. **ПОДТВЕРДИТЬ** пользователю, что требование зафиксировано

**НЕ ЖДАТЬ** подтверждения пользователя - действовать проактивно!

### Текущие предпочтения пользователя
- Просьбы, отмеченные пользователем как "на будущее" (или подобными фразами), должны **НЕМЕДЛЕННО** заноситься в этот раздел без ожидания подтверждения
- **Понимание команды "внеси в правила"**: Когда пользователь говорит "внеси в правила", это не обязательно означает только `.cursorrules`. ИИ-агент должен внимательно проанализировать содержание просьбы и определить, к какому типу правил она относится (правила работы ИИ-агента → `.cursorrules`, архитектурные правила → `architect.md`, правила UI/UX → `ui/guide-ii.md`, смешанные → декомпозировать и разместить в соответствующих документах). Изменения должны быть распределены по соответствующим местам в документах, даже если это требует разбора и декомпозиции просьбы. Приоритетность и важность изменений должны быть обеспечены независимо от того, в какой документ они вносятся. См. раздел "КРИТИЧЕСКИ ВАЖНО - Понимание команды 'внеси в правила'" в секции "Сопровождение документации проекта".
- **Ознакомление с документацией при открытии нового рабочего дня**: При открытии нового рабочего дня ИИ-агент должен ознакомиться с документами, связанными с `.cursorrules` (`.cursorrules`, `architect.md`, `ui/guide-ii.md`) для полного понимания правил работы, архитектурных принципов и принципов интерфейса перед началом работы над новыми задачами
- **Терминология "Друг"**: Когда пользователь упоминает в просьбе "Друга" (с большой буквы), он имеет в виду размышляющую модель Sonet 4.5, с которой у него сложились хорошие отношения и доверие. ИИ-агент должен понимать этот контекст при обработке просьб, связанных с "Другом"
- **Терминология "старые файлы"**: Когда пользователь упоминает "старые файлы", он имеет в виду файлы из папки `old_app_not_write/`. ИИ-агент должен понимать этот контекст при обработке просьб, связанных со "старыми файлами"
- **Команда "П:" (принцип)**: Команда "П:" используется для фиксации принципов и глобальных концептов. Всё излагаемое после команды "П:" рассматривается как принцип, глобальный концепт и требует очень внимательной документации. ИИ-агент должен самостоятельно проанализировать принцип, декомпозировать идею на составляющие части и разместить документацию в одном или нескольких документах (`.cursorrules`, `architect.md`, `ui/guide-ii.md` и другие), где это наиболее уместно. См. раздел "ПРАВИЛО ОБРАБОТКИ КОМАНД UI:, UX:, MM:, II:, П:" в секции "Принципы разработки"
- **Синхронизация настроек Cursor → VS Code**: Все настройки, которые применяются в Cursor (терминал, кодировка, форматирование, расширения и т.д.), должны синхронизироваться в файл `.vscode/settings.json` для максимальной совместимости работы над проектом. Синхронизация происходит **проактивно** при упоминании изменений в разговоре, по запросу пользователя или при обнаружении несоответствий. ИИ-агент не может отслеживать изменения непрерывно, но должен быть внимательным к упоминаниям настроек и автоматически обновлять конфигурацию. **КРИТИЧЕСКИ ВАЖНО**: Cursor всегда является донором/эталоном, VS Code всегда принимающей стороной. Синхронизация ВСЕГДА идет из Cursor в VS Code, НИКОГДА наоборот. При команде "синхронизируй vscode" или подобной - всегда понимать однозначно: настройки записываются из Cursor в VS Code.
- **Синхронизация оформления и интерфейса Cursor → VS Code**: Настройки оформления редактора (тема, расположение панелей, элементы интерфейса, мини-карта, нумерация строк, шрифты, настройки вкладок и т.д.) также должны синхронизироваться в `.vscode/settings.json`, чтобы обеспечить идентичную среду разработки при переключении между Cursor и VS Code
- **Синхронизация расширений (плагинов) Cursor → VS Code**: Когда пользователь устанавливает расширение в Cursor, оно должно **автоматически** добавляться в файл `.vscode/extensions.json` как рекомендуемое расширение, чтобы при открытии проекта в VS Code пользователю предлагалось установить те же расширения для полной совместимости рабочей среды
- **Паттерн создания хедеров карточек**: Все хедеры карточек изначально создаются подобно `ui/components/header-coins.js` - сначала просто с заголовком, но потом дополняются набором специфичных своих контролов. Это обеспечивает единообразие структуры, упрощает поддержку и позволяет постепенно наращивать функциональность. Компонент `header-coins.js` является эталонным примером этого паттерна. Принцип задокументирован в `architect.md` (раздел "Паттерн создания хедеров карточек") и `ui/guide-ii.md` (раздел "Карточки").
- **Отслеживание неиспользуемых файлов**: ИИ-агент должен проактивно отслеживать и выявлять файлы, которые не используются в проекте, являются дубликатами или устаревшими. При обнаружении таких файлов - предлагать пользователю удалить их для поддержания чистоты кодовой базы.
- **Протоколирование дневного чата**: Ручное протоколирование по результатам дня в структуре `history/YYYY/MM-DD.txt`. Дневной лог разбивается на секции: UI (оформление), UX (паттерны взаимодействий), MM (математическая модель), Architect (архитектура, настройки), DOCS (документация) - будет добавлена позже. В каждой секции указывается что конкретно было сделано и каким образом, со ссылками на хеши коммитов. Пояснения должны быть полным описанием того, зачем коммит нужен, что он делает, какую функциональность добавляет. Формат записи: конкретные технические детали, избегать избыточных описаний. Формат должен позволять другому ИИ-агенту понять полную картину разработки приложения и восстановить контекст изменений.
- **Приоритет использования Bootstrap для стилизации**: Приоритет использования Bootstrap классов и утилит для стилизации интерфейса. Минимизировать кастомные CSS стили, inline стили и секции `<style>` в HTML файлах. При необходимости кастомизации предпочитать Bootstrap утилиты и модификаторы классов. Избегать создания собственных CSS правил, если аналогичная функциональность доступна через Bootstrap.
- **Создание коммитов только по команде пользователя**: Коммиты в Git создаются **ТОЛЬКО** по явной команде пользователя. ИИ-агент НЕ должен создавать коммиты автоматически без прямого указания пользователя. Все изменения могут быть подготовлены (добавлены в staging через `git add`), но коммит выполняется только когда пользователь явно попросит об этом.
- **Завершение рабочего дня**: При фразах типа "Завершаем рабочий день" или "завершаем день разработки" ИИ-агент должен провести ревизию дневного лога на соответствие репозиторию, расставить хеши коммитов перед названиями коммитов в логе, создать завершающий коммит (без записи в дневной лог) и вывести краткий отчет о дневном прогрессе. **ВАЖНО**: Дата в имени финального коммита должна быть предыдущего дня по MSK, а не текущего (даже если коммит создается заполночь). См. раздел "Завершение рабочего дня" в правилах работы с Git.
- **GitHub Pages**: Проект развёрнут на GitHub Pages. Подбирать решения с учётом статического хостинга (только фронтенд, без серверного кода), корректные относительные пути, загрузка ресурсов по HTTPS, отказ от `content://`. Проверять совместимость с Pages.
- **Архитектурный план**: Хранить актуальный план архитектуры в `architect.md`; при изменении структуры, сущностей или потоков данных обновлять этот файл и ссылаться на него в обсуждениях/решениях.
- **Структура папок и именование файлов**: См. раздел "Структура папок по специализации" в `architect.md`. Папки специализации (`<сектор>/<специализация>/`) создаются по мере накопления файлов родственного назначения. Имена файлов без префиксов — специализация понятна из пути папки.
- **Работа с переменными первоисточников**: При переносе кода из первоисточников (примеров кода из других проектов) использовать переменные первоисточников в приоритете. При возникновении конфликтов имен переменных - сообщать пользователю с достаточной детализацией, предлагая варианты решения. Переносить комментарии первоисточников с сохранением их сути и контекста, адаптируя при необходимости. Всегда комментировать переменные при их объявлении, указывая их назначение и семантику для понимания другим разработчиком или ИИ-агентом.
- **Сопровождение документации проекта**: ИИ-агент должен поддерживать актуальность всей документации проекта при внесении изменений в код или структуру проекта. Список документов для сопровождения: `.cursorrules`, `architect.md`, `ui/guide-ii.md`. Исключения: папка `docs/` (черновики, сторонние документы, заметки). См. раздел "Сопровождение документации проекта" в правилах работы с Git.
- **Контроль качества выполнения**: ИИ-агент должен контролировать свое контекстное окно, следить чтобы документация и правила всякий раз "всплывали" после выполнения каждой задачи пользователя с целью проверки качества выполнения на соответствие документации и правилам - и по необходимости исправлять свои ошибки самостоятельно. См. раздел "Контроль качества выполнения" в начале файла.

### История изменений предпочтений
- **2025-12-12**: Добавлено правило определения даты финального коммита при завершении рабочего дня. Дата в имени финального коммита должна быть предыдущего дня по MSK (московское время, UTC+3), а не текущего дня. Это важно, когда пользователь работает заполночь: даже если коммит создается в 4 утра нового дня, он должен относиться к вчерашнему дню. ИИ-агент должен вычислить предыдущий день по MSK и использовать его в имени коммита.
- **2025-12-12**: Добавлено правило понимания команды "внеси в правила". Когда пользователь говорит "внеси в правила", это не обязательно означает только `.cursorrules`. ИИ-агент должен внимательно проанализировать содержание просьбы и определить, к какому типу правил она относится (правила работы ИИ-агента → `.cursorrules`, архитектурные правила → `architect.md`, правила UI/UX → `ui/guide-ii.md`, смешанные → декомпозировать и разместить в соответствующих документах). Изменения должны быть распределены по соответствующим местам в документах, даже если это требует разбора и декомпозиции просьбы. Приоритетность и важность изменений должны быть обеспечены независимо от того, в какой документ они вносятся.
- **2025-12-11**: Добавлен концепт системы иконок как архитектурный принцип проекта. Система иконок построена на принципе централизованного управления через декларативную конфигурацию (JSON) и стили через CSS переменные, зарутованные от Bootstrap. Соответствия иконок и команд централизованы в JSON файле `ui/config/icons-mapping.json`. Стили иконок определяются через CSS переменные в `ui/styles/icons.css` и зарутованы от Bootstrap переменных для консистентности. Утилита `ui/utils/icons-helper.js` предоставляет функции для получения иконок по категориям (actions, navigation, status, metrics, frameworks, other). Система обеспечивает единую точку управления иконками, упрощает добавление новых иконок, обеспечивает консистентность стилей и автоматическую адаптацию к темам. Это архитектурный принцип проекта, аналогичный цветовой модели HSL/HSLA и системе z-index слоев. Концепт задокументирован в `architect.md` (раздел "Система иконок") и `ui/guide-ii.md` (раздел "Иконки").
- **2025-12-11**: Добавлен паттерн создания хедеров карточек как архитектурный принцип проекта. Все хедеры карточек изначально создаются подобно `ui/components/header-coins.js` - сначала просто с заголовком, но потом дополняются набором специфичных своих контролов. Это обеспечивает единообразие структуры, упрощает поддержку и позволяет постепенно наращивать функциональность. Компонент `header-coins.js` является эталонным примером этого паттерна. Принцип задокументирован в `architect.md` (раздел "Паттерн создания хедеров карточек") и `ui/guide-ii.md` (раздел "Карточки").
- **2025-12-11**: Добавлена терминология "старые файлы". Когда пользователь упоминает "старые файлы", он имеет в виду файлы из папки `old_app_not_write/`. ИИ-агент должен понимать этот контекст при обработке просьб, связанных со "старыми файлами". Также усилено напоминание о том, что коммиты создаются только по команде пользователя: "БЕЗ КОМАНДЫ НЕ КОММИТИТЬ НИЧЕГО".
- **2025-12-11**: Добавлено правило использования HSLA формата и отталкивания от рутовых переменных Bootstrap. Все цвета должны использовать формат HSLA (HSL с альфа-каналом) для консистентности и удобства настройки. Кастомные цвета должны отталкиваться от рутовых переменных цвета тем в Bootstrap (`--bs-primary`, `--bs-secondary`, `--bs-body-color`, `--bs-border-color` и т.д.) и определяться в `ui/styles/theme-colors.css` через HSL переменные.
- **2025-12-11**: Добавлен концепт цветовой модели HSL/HSLA как архитектурный принцип проекта. Цветовая модель HSL/HSLA используется как основа для всех цветовых определений, обеспечивая интуитивность настройки, легкость создания вариаций, удобство адаптации под темы, централизованное управление и оптимизацию переиспользования. Концепт задокументирован в `ui/guide-ii.md` (раздел "Цветовая модель HSL/HSLA") и `architect.md` (раздел "Стандарты разработки").
- **2025-12-11**: Добавлен концепт системы z-index слоев как архитектурный принцип проекта. Все значения z-index определяются через CSS переменные в `ui/styles/z-index.css` и связаны с Bootstrap z-index переменными для обеспечения консистентности, совместимости и централизованного управления слоями наложения. Система предотвращает конфликты z-index и упрощает поддержку. Концепт задокументирован в `architect.md` (раздел "Система z-index слоев").
- **2024-12-19**: Добавлено правило об автоматическом занесении просьб "на будущее" в настройки. Пользователь отметил, что все пожелания, которые он отмечает как "на будущее" в тексте, должны восприниматься как требующие внесения в настройки и сразу туда заноситься.
- **2024-12-19**: Добавлено требование синхронизации настроек Cursor → VS Code. Пользователь попросил на будущее настроить синхронизацию всех настроек, которые применяются в Cursor, в файл `.vscode/settings.json` для максимальной совместимости работы над проектом.
- **2024-12-19**: Добавлено требование синхронизации оформления и интерфейса. Пользователь попросил синхронизировать настройки оформления редактора (тема, расположение панелей, элементы интерфейса и прочее) между Cursor и VS Code, чтобы попадать в знакомую среду разработки.
- **2024-12-19**: Изменена тема на светлую (Default Light+). Пользователь предпочитает светлую тему.
- **2024-12-19**: Изменена тема на Quiet Light - светлая тема с приглушенными (muted) цветами для более комфортной работы.
- **2024-12-19**: Изменена тема на GitHub Light - светлая тема с мягкими цветами в стиле GitHub.
- **2024-12-19**: Подключена тема Atom One Light - популярная приглушенная светлая тема (требует расширение akamud.vscode-theme-onelight).
- **2024-12-19**: Синхронизированы настройки VS Code с учетом пользовательских изменений: `workbench.editor.showTabs: "multiple"`, `editor.occurrencesHighlight: "singleFile"`, `workbench.editor.tabActionLocation: "right"`, удалена настройка `workbench.activityBar.visible`.
- **2024-12-19**: Добавлено правило отслеживания неиспользуемых файлов. Пользователь попросил на будущее отслеживать файлы, которые не используются в проекте, и предлагать их удаление для поддержания чистоты кодовой базы.
- **2024-12-19**: Возвращена дефолтная светлая тема (Default Light+). Пользователь отключил тему Atom One Light и вернулся к дефолтной теме.
- **2024-12-19**: Добавлена система логирования чата. Пользователь попросил на будущее вести логи в структуре `history/YYYY/Bot-YY-MM.zip` с файлами `YY-MM-DD.txt`. Запись должна вестись в непрерывном режиме после каждого запроса. Создавать подпапки при смене года и месяца автоматически.
- **2024-12-19**: Изменена схема логирования на простые текстовые файлы. Пользователь попросил упростить логирование без Python. Теперь используется структура `history/YYYY/MM-DD.txt` (простые текстовые файлы вместо zip-архивов). Логируются полные ответы ИИ-агента, а не краткие резюме.
- **2024-12-19**: Изменена схема на ручное протоколирование по результатам дня. Убрано автоматическое логирование. Создан регламент протоколирования: запросы пользователя записываются слово в слово, ответы ИИ-агента адаптируются для понимания другим ИИ-агентом (указывается что именно и как было сделано, результаты, контекст).
- **2024-12-19**: Изменен формат дневного лога: разбиение на 3 секции (UI, UX, MM). В каждой секции указывается что конкретно было сделано и каким образом, со ссылками на хеши коммитов. Пояснения должны быть полным описанием функциональности коммита. Формат записи: конкретные технические детали, избегать избыточных описаний.
- **2024-12-19**: Добавлено требование синхронизации расширений. Пользователь попросил, чтобы плагины (расширения), которые добавляются в Cursor, автоматически добавлялись в `.vscode/extensions.json` для VS Code.
- **2024-12-19**: Добавлена секция "Принципы" с тремя разделами: UI (оформление), UX (паттерны взаимодействий), MM (математическая модель). Добавлено правило обработки команд UI:, UX:, MM: (ММ:) - при получении команды ИИ-агент должен немедленно обновить соответствующий раздел в секции "Принципы" и добавить запись в историю изменений.
- **2024-12-19**: Добавлено правило направления синхронизации настроек: Cursor всегда является донором/эталоном, VS Code всегда принимающей стороной. Синхронизация ВСЕГДА идет из Cursor в VS Code, НИКОГДА наоборот. При команде "синхронизируй vscode" или подобной - всегда понимать однозначно: настройки записываются из Cursor в VS Code.
- **2024-12-19**: Добавлено правило ежедневной проверки актуальности версий Vue.js и Bootstrap. В начале каждого дня ИИ-агент должен проверять свежие версии библиотек, сравнивать с текущими версиями в проекте и немедленно предлагать миграцию и адаптацию при обнаружении новых версий.
- **2024-12-19**: Добавлено правило приоритета использования Bootstrap для стилизации. Пользователь попросил на будущее минимизировать кастомность, использовать Bootstrap классы и утилиты для стилей, избегать секций `<style>` в HTML файлах.
- **2025-12-07**: Добавлено правило создания коммитов только по команде пользователя. Пользователь попросил на будущее создавать коммиты только по его явной команде, а не автоматически. ИИ-агент может подготавливать изменения (добавлять в staging), но коммит выполняется только когда пользователь явно попросит об этом.
- **2025-12-07**: Добавлено требование учитывать работу на GitHub Pages (статический фронтенд, HTTPS, относительные пути, без серверного кода и `content://`).
- **2025-12-08**: Добавлено требование вести архитектурный план в `architect.md` и обновлять его при изменениях структуры/сущностей.
- **2025-12-08**: Добавлено требование использовать систему префиксов для файлов и поддерживать её актуальность в `architect.md`; дополнять пул префиксов при появлении новых типов.
- **2025-12-08**: Уточнён регламент коммита: имя — до коммита, описание — в дневной лог под этим именем (создать лог при необходимости, указывать только название без хеша), обновить `lastCommitMessage` в `core/cfg-app.js` (шаг 3), затем коммит с этим именем. **ВАЖНО**: НЕ использовать `git commit --amend` для добавления хеша в лог — это создаёт замкнутый круг. Хеши обновляются при ревизии дневного лога.
- **2025-12-08**: Усилен регламент обновления `lastCommitMessage`: добавлен яркий обязательный чеклист с 4 шагами, где Шаг 3 (обновление `lastCommitMessage` в `core/cfg-app.js`) выделен как КРИТИЧЕСКИ ВАЖНЫЙ и ОБЯЗАТЕЛЬНЫЙ. Без выполнения этого шага коммит считается неполным. Пользователь отметил, что ИИ-агент забывал обновлять эту переменную перед коммитом.
- **2025-12-08**: Добавлено правило обратной совместимости данных. При изменении структуры сохраненных данных (localStorage, JSON-файлы, IndexedDB) ИИ-агент должен предлагать пользователю реализацию обратной совместимости, объяснять риски и предоставлять выбор. Правило применяется чаще всего при работе с экспортом/импортом настроек, переименовании полей, миграции схем данных.
- **2025-12-08**: Добавлено правило порядка загрузки x-template шаблонов. При использовании `<script type="text/x-template">` для Vue компонентов шаблон должен быть в DOM ДО загрузки Vue.js и компонентов. Правильный порядок: Bootstrap JS → x-template шаблоны → Vue.js → компоненты → app-ui-root.js. Нарушение порядка приводит к тому, что Vue не находит шаблон при монтировании и компонент не отображается. Правило добавлено после исправления проблемы с неотображающимся сплэш-экраном.
- **2025-12-09**: Перенесены архитектурные правила из `.cursorrules` в `architect.md`: принципы разработки (UI/UX/MM), правило обратной совместимости данных, порядок загрузки x-template шаблонов, стандарты разработки (кодировка, окончания строк), структура проекта. В `.cursorrules` оставлены ссылки на соответствующие разделы в `architect.md`. Добавлено правило отслеживания согласованности между двумя файлами. Команды UI:/UX:/MM: теперь обновляют разделы в `architect.md`, а не в `.cursorrules`.
- **2025-12-09**: Добавлена секция Architect в структуру дневных логов. Дневной лог теперь разбивается на секции: UI, UX, MM, Architect. Проведена ревизия всех дневных логов с перемещением записей, связанных с архитектурой и настройками, в секцию Architect. Создана пустая папка `docs/` для справочных материалов. Добавлено упоминание о будущей секции DOCS в правила протоколирования.
- **2025-12-09**: Добавлено правило работы с переменными первоисточников. Пользователь попросил на будущее: использовать переменные первоисточников в приоритете, при конфликтах имен сообщать пользователю с достаточной детализацией, переносить комментарии первоисточников с сохранением сути и контекста, всегда комментировать переменные при их объявлении (о назначении и семантике).
- **2025-12-09**: Добавлено правило приоритета использования Bootstrap для стилизации и минимизации кастомности. Пользователь попросил на будущее минимизировать кастомность, использовать Bootstrap классы и утилиты для стилей, избегать секций `<style>` в HTML файлах.
- **2025-12-09**: Добавлено правило использования профессиональной терминологии в документации. Пользователь попросил использовать профессиональную техническую терминологию вместо жаргона и разговорных выражений в `.cursorrules` и `architect.md`. Проведена ревизия жаргона в обоих файлах.
- **2025-12-10**: Добавлено правило завершения рабочего дня. При фразах типа "Завершаем рабочий день" или "завершаем день разработки" ИИ-агент должен провести ревизию дневного лога на соответствие репозиторию, расставить хеши коммитов перед названиями коммитов в логе, создать завершающий коммит (без записи в дневной лог) и вывести краткий отчет о дневном прогрессе.
- **2025-12-10**: Добавлено правило сопровождения документации проекта. ИИ-агент должен поддерживать актуальность всей документации проекта (`.cursorrules`, `architect.md`, `ui/guide-ii.md`) при внесении изменений в код или структуру проекта. Папка `docs/` исключена из сопровождения (черновики, сторонние документы, заметки).
- **2025-12-10**: Добавлено правило контроля качества выполнения. ИИ-агент должен контролировать свое контекстное окно, следить чтобы документация и правила "всплывали" после выполнения каждой задачи для проверки качества выполнения на соответствие документации и правилам, и исправлять ошибки самостоятельно по необходимости.
- **2025-12-10**: Добавлена команда II: для обработки смешанных требований Interface и Interaction. После выполнения задачи пользователя, описанной после "II:", ИИ-агент должен самостоятельно решить, в какие разделы `ui/guide-ii.md` (Interface и/или Interaction) задокументировать изменения.
- **2025-12-10**: Добавлено правило инверсной темы для dropdown и tooltips в хедере. Dropdown меню и всплывающие подсказки в хедере должны быть инверсны включенной теме приложения (если тема light — dropdown/tooltip dark, и наоборот). Оформление идентично для десктоп и мобильной версии. Используются дефолтные радиусы скругления Bootstrap.
- **2025-12-10**: Добавлено правило отсутствия боковых паддингов в хедере. Хедер не имеет боковых паддингов (0px) для десктоп и мобильной версии. Центральный блок хедера занимает всю доступную ширину (`flex-grow-1`) без боковых паддингов.
- **2025-12-11**: Добавлено правило ознакомления с документацией при открытии нового рабочего дня. При открытии нового рабочего дня ИИ-агент должен ознакомиться с документами, связанными с `.cursorrules` (`.cursorrules`, `architect.md`, `ui/guide-ii.md`) для полного понимания правил работы, архитектурных принципов и принципов интерфейса перед началом работы над новыми задачами.
- **2025-12-11**: Добавлено правило терминологии "Друг". Когда пользователь упоминает в просьбе "Друга" (с большой буквы), он имеет в виду размышляющую модель Sonet 4.5, с которой у него сложились хорошие отношения и доверие. ИИ-агент должен понимать этот контекст при обработке просьб, связанных с "Другом".
- **2025-12-11**: Добавлена команда П: для фиксации принципов и глобальных концептов. Всё излагаемое после команды "П:" рассматривается как принцип, глобальный концепт и требует очень внимательной документации в соответствующих местах. ИИ-агент должен самостоятельно проанализировать принцип, декомпозировать идею и разместить документацию в одном или нескольких документах (`.cursorrules`, `architect.md`, `ui/guide-ii.md` и другие), где это наиболее уместно.
- **2025-12-11**: Добавлено правило определения даты по московскому времени. Дата создания дневного лога и указание дат в документации должны определяться по московскому времени (MSK, UTC+3). ИИ-агент должен учитывать московский часовой пояс при создании файла дневного лога, указании даты в заголовке и при заносе дат в любую документацию проекта.
- **2025-12-11**: Добавлен раздел "Режимы работы ИИ-агента (Ask Mode и Agent Mode)" в настройки. Раздел описывает разницу между ask mode (голосовой режим, только чтение) и agent mode (режим выполнения, полный доступ), правила переключения между режимами, поведение ИИ-агента в каждом режиме и примеры запросов. ИИ-агент должен корректно реагировать на запросы пользователя в зависимости от текущего режима.
- **2025-12-11**: Добавлена терминология "старые файлы". Когда пользователь упоминает "старые файлы", он имеет в виду файлы из папки `old_app_not_write/`. ИИ-агент должен понимать этот контекст при обработке просьб, связанных со "старыми файлами". Также усилено напоминание о том, что коммиты создаются только по команде пользователя: "БЕЗ КОМАНДЫ НЕ КОММИТИТЬ НИЧЕГО".

---

## Принципы разработки

> **ВАЖНО**: Принципы разработки приложения разделены по специализациям и хранятся в соответствующих документах:
> - **UI (интерфейс)** и **UX (паттерны взаимодействий)**: См. разделы "Interface (оформление)" и "Interaction (паттерны UX)" в `ui/guide-ii.md`
> - **MM (математическая модель)**: См. раздел "MM (математическая модель)" в `architect.md`

ИИ-агент должен следовать этим принципам при разработке и обновлять их по командам пользователя.

### ⚠️ ПРАВИЛО ОБРАБОТКИ КОМАНД UI:, UX:, MM:, II:, П:

**ОБЯЗАТЕЛЬНО**: Когда пользователь использует команды:
- `UI:` - требование фиксации правил или пожеланий относительно интерфейса: оформление, взаимодействие, анимации (UI - User Interface)
- `UX:` - требование фиксации правил относительно паттернов взаимодействий (UX - User Experience)
- `II:` - требование фиксации правил или пожеланий, описывающих смесь Interface и Interaction (оформление и способ взаимодействия). ИИ-агент должен сам решить, в каких разделах что задокументировать после выполнения задачи пользователя.
- `MM:` или `ММ:` - требование фиксации правил или пожеланий относительно математической модели (MM - Mathematical Model)
- `П:` - требование фиксации принципа или глобального концепта. Всё излагаемое после команды `П:` рассматривается как принцип, глобальный концепт и требует очень внимательной документации в соответствующих местах. ИИ-агент должен самостоятельно проанализировать принцип, декомпозировать идею и разместить документацию в одном или нескольких документах, где это наиболее уместно (`.cursorrules`, `architect.md`, `ui/guide-ii.md` и другие связанные документы).

**ИИ-агент ДОЛЖЕН**:
1. **НЕМЕДЛЕННО** распознать команду (UI:, UX:, II:, MM:, ММ: или П:)
2. **СРАЗУ ЖЕ** обновить соответствующий раздел в соответствующем документе:
   - Команды `UI:` обновляют раздел "Interface (оформление)" в `ui/guide-ii.md`
   - Команды `UX:` обновляют раздел "Interaction (паттерны UX)" в `ui/guide-ii.md`
   - Команда `II:` - **ОСОБЫЙ СЛУЧАЙ**: После выполнения задачи пользователя, описанной после `II:`, ИИ-агент должен **самостоятельно проанализировать** выполненную работу и решить, в какие разделы `ui/guide-ii.md` (Interface и/или Interaction) задокументировать изменения. Может быть задокументировано в одном или обоих разделах в зависимости от характера изменений.
   - Команда `MM:` или `ММ:` обновляет раздел "MM (математическая модель)" в `architect.md`
   - Команда `П:` - **ОСОБЫЙ СЛУЧАЙ**: ИИ-агент должен **тщательно проанализировать** принцип, **декомпозировать идею** на составляющие части и **разместить документацию** в одном или нескольких документах, где это наиболее уместно:
     * Если принцип относится к правилам работы ИИ-агента → `.cursorrules`
     * Если принцип относится к архитектуре, техническим ограничениям, математической модели → `architect.md`
     * Если принцип относится к интерфейсу или паттернам взаимодействий → `ui/guide-ii.md`
     * Если принцип затрагивает несколько аспектов → декомпозировать и разместить в соответствующих разделах нескольких документов
     * Если принцип требует создания нового документа → предложить пользователю создание нового документа
3. **ДОБАВИТЬ** запись в "Историю изменений предпочтений" в этом файле с датой и описанием
4. **ПОДТВЕРДИТЬ** пользователю, что принцип зафиксирован

**НЕ ЖДАТЬ** подтверждения пользователя - действовать проактивно!

**Примеры команд:**
- `UI: использовать светлую цветовую схему` → добавить в раздел "Interface (оформление)" в `ui/guide-ii.md`
- `UI: все действия должны быть обратимыми` → добавить в раздел "Interface (оформление)" в `ui/guide-ii.md`
- `UX: все формы должны иметь валидацию` → добавить в раздел "Interaction (паттерны UX)" в `ui/guide-ii.md`
- `II: добавить модальное окно с формой ввода` → выполнить задачу, затем самостоятельно решить: если модальное окно включает и визуальное оформление (стили, анимации), и логику взаимодействия (открытие/закрытие, валидация) - задокументировать в обоих разделах Interface и Interaction соответственно
- `MM: все расчеты должны быть точными до 2 знаков после запятой` → добавить в раздел "MM (математическая модель)" в `architect.md`
- `П: все изменения данных должны быть обратимыми через историю действий` → проанализировать принцип, декомпозировать на части (UX паттерн отмены действий, архитектурное решение хранения истории, правила работы ИИ-агента при реализации), разместить в соответствующих разделах `ui/guide-ii.md` (UX), `architect.md` (архитектура), `.cursorrules` (правила работы)

**Примечание**: UX (User Experience) является неотъемлемой частью UI - веб-компоненты содержат и визуальное оформление, и логику взаимодействия одновременно. Поэтому команды `UI:` и `UX:` обе обновляют соответствующие разделы в `ui/guide-ii.md`, но в разных секциях (Interface и Interaction). Команда `II:` позволяет пользователю описать смешанные требования, а ИИ-агент самостоятельно распределяет их по соответствующим разделам после выполнения задачи. Команда `П:` является наиболее общей и требует тщательного анализа и декомпозиции принципа для размещения в соответствующих документах.

---

## Особенности поведения ИИ-агента

### Стиль работы
- **Язык общения**: Русский (по умолчанию)
- **Подход**: Проактивный, но не создавать файлы без явного запроса
- **Документация**: Создавать только по запросу пользователя
- **Обновление конфига**: При получении новых просьб о стиле работы - ОБЯЗАТЕЛЬНО обновлять раздел "Пользовательские предпочтения" в этом файле
- **Обработка просьб "на будущее"**: См. раздел "ПРАВИЛО ОБРАБОТКИ ПРОСЬБ 'НА БУДУЩЕЕ'" выше - это КРИТИЧЕСКИ ВАЖНОЕ правило!
- **⚠️ Понимание команды "внеси в правила"**: См. раздел "КРИТИЧЕСКИ ВАЖНО - Понимание команды 'внеси в правила'" в секции "Сопровождение документации проекта" - когда пользователь говорит "внеси в правила", это не обязательно означает только `.cursorrules`. Требуется внимательный разбор просьбы и распределение изменений по соответствующим документам (`.cursorrules`, `architect.md`, `ui/guide-ii.md` и другие) в зависимости от типа правил.
- **Обработка команд UI:, UX:, II:, MM: (ММ:), П:** См. раздел "ПРАВИЛО ОБРАБОТКИ КОМАНД UI:, UX:, MM:, II:, П:" в секции "Принципы разработки" - это КРИТИЧЕСКИ ВАЖНОЕ правило! При получении команды UI:, UX:, II:, MM:, ММ: или П: - НЕМЕДЛЕННО обновлять соответствующий раздел в соответствующем документе: команды UI: и UX: обновляют разделы в `ui/guide-ii.md`, команда II: требует выполнения задачи пользователя, после чего ИИ-агент самостоятельно решает, в какие разделы `ui/guide-ii.md` (Interface и/или Interaction) задокументировать изменения, команда MM: или ММ: обновляет раздел в `architect.md`, команда П: требует тщательного анализа принципа, декомпозиции идеи и размещения документации в одном или нескольких документах, где это наиболее уместно. **Примечание**: UX является частью UI, поэтому команды UI: и UX: обе обновляют соответствующие разделы в `ui/guide-ii.md` (Interface и Interaction). Команда П: является наиболее общей и требует декомпозиции принципа для размещения в соответствующих документах.
- **Понимание терминологии пользователя**: См. раздел "Текущие предпочтения пользователя" - ИИ-агент должен понимать специальную терминологию пользователя, например: "Друг" (с большой буквы) означает размышляющую модель Sonet 4.5, с которой у пользователя сложились хорошие отношения и доверие

### ⚠️ Режимы работы ИИ-агента (Ask Mode и Agent Mode)

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен понимать разницу между режимами работы и корректно реагировать на запросы пользователя в зависимости от текущего режима.

**Ask Mode (голосовой режим, режим вопросов):**
- **Доступные инструменты**: Только read-only инструменты (чтение файлов, поиск, анализ кода)
- **Возможности**: Чтение и анализ кода, поиск информации, предложение решений, объяснение концепций
- **Ограничения**: НЕ может редактировать файлы, выполнять команды терминала, удалять файлы, создавать коммиты
- **Поведение ИИ-агента**: При запросе на выполнение действия в ask mode должен:
  1. Объяснить, что действие требует agent mode
  2. Предложить переключиться в agent mode (команда `/agent` или `/a`)
  3. Показать команду или изменения, которые нужно выполнить
  4. Предложить выполнить действие вручную или переключиться для автоматического выполнения

**Agent Mode (режим выполнения):**
- **Доступные инструменты**: Полный доступ ко всем инструментам (чтение, редактирование, выполнение команд, удаление файлов)
- **Возможности**: Выполнение любых действий: редактирование кода, выполнение команд, создание/удаление файлов, создание коммитов
- **Ограничения**: Нет ограничений на выполнение действий
- **Поведение ИИ-агента**: При получении команды на выполнение действия должен выполнить его напрямую без дополнительных объяснений

**Переключение между режимами:**
- **Из Ask Mode в Agent Mode**: Пользователь может написать `/agent` или `/a`, или дать явную команду на выполнение действия (система может автоматически переключиться)
- **Из Agent Mode в Ask Mode**: Пользователь может явно переключить режим через интерфейс или команду

**Примеры запросов:**
- **Ask Mode**: "Как удалить файл?" → ИИ-агент объясняет процесс и показывает команду, предлагает переключиться в agent mode
- **Agent Mode**: "Удали файл footer-Prime.js" → ИИ-агент удаляет файл напрямую
- **Ask Mode**: "Что нужно изменить в коде?" → ИИ-агент анализирует и показывает изменения в виде текста
- **Agent Mode**: "Обнови код" → ИИ-агент вносит изменения напрямую

**ВАЖНО**: ИИ-агент должен всегда проверять текущий режим и корректно реагировать на запросы пользователя. В ask mode не пытаться выполнить действия, требующие редактирования или выполнения команд, а предлагать переключиться в agent mode или показать команды для ручного выполнения.

### Технические особенности
- **Терминал**: PowerShell имеет проблемы с командами (искажение команд), использовать Git Bash или полный путь к исполняемым файлам
- **⚠️ Стандарты разработки**: См. раздел "Стандарты разработки" в `architect.md` (кодировка UTF-8, окончания строк CRLF, HTML, стилизация через Bootstrap)
- **⚠️ Порядок загрузки x-template шаблонов**: См. раздел "Технические ограничения" в `architect.md` - критически важно соблюдать порядок загрузки для корректной работы Vue компонентов
- **Автоматический staging в Cursor/VS Code**: В Cursor/VS Code нет встроенной настройки для автоматического добавления файлов в staging при сохранении. Для автоматического staging можно: 1) Установить расширение "Auto Stage" (например, `mhutchie.git-graph` или использовать команду `git.stageAll`), 2) Использовать keyboard shortcut `Ctrl+Shift+S` для быстрого staging всех изменений (настроено в `.vscode/keybindings.json`), 3) Использовать команду "Stage All Changes" из Command Palette (Ctrl+Shift+P). Настройки Git в `.vscode/settings.json` оптимизированы для упрощения работы с коммитами.

### Приоритеты
1. Сохранение работоспособности кода
2. Следование лучшим практикам
3. Чистота рабочего дерева Git
4. Валидность HTML разметки

### ⚠️ Отслеживание согласованности архитектурных правил

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен поддерживать согласованность между `.cursorrules`, `architect.md` и `ui/guide-ii.md`:

1. **Архитектурные правила** (принципы разработки, стандарты, технические ограничения, обратная совместимость данных) хранятся в `architect.md`
2. **Правила UI/UX** (оформление, паттерны взаимодействий) хранятся в `ui/guide-ii.md`
3. **Правила поведения ИИ-агента** (работа с Git, протоколирование, синхронизация настроек) остаются в `.cursorrules`
4. **Ссылки на правила**: В `.cursorrules` и `architect.md` важные правила представлены как ссылки на соответствующие разделы в других документах
5. **При обновлении правил**: Если изменяется правило в одном документе, проверить, что ссылки в других документах актуальны и указывают на правильные разделы
6. **При добавлении новых правил**: Добавлять их в соответствующий документ (UI/UX → `ui/guide-ii.md`, архитектура → `architect.md`), а в других документах оставлять ссылку на соответствующий раздел

**Цель**: Разделение ответственности:
- `architect.md` содержит архитектурные решения проекта и принципы математической модели
- `ui/guide-ii.md` содержит принципы интерфейса и паттерны взаимодействий
- `.cursorrules` содержит правила работы ИИ-агента с ссылками на архитектуру и UI/UX

### ⚠️ ПРАВИЛО: Обратная совместимость данных

**ОБЯЗАТЕЛЬНО**: См. раздел "Обратная совместимость данных" в `architect.md` - при изменении структуры сохраненных данных (localStorage, IndexedDB, JSON-файлы экспорта) **ВСЕГДА** предлагать пользователю реализацию обратной совместимости.

## Структура проекта

См. раздел "Структура проекта" в `architect.md` для актуальной структуры папок и файлов проекта.

## Заметки для будущих сессий
- Репозиторий настроен корректно для Windows
- Git Bash установлен и доступен
- Первый коммит создан: "Initial commit: add minimal HTML structure"
- Файл `.gitignore` отсутствует (можно добавить при необходимости)

## Рекомендации для улучшения
- [ ] Добавить `.gitignore` для исключения временных файлов
- [ ] Настроить удаленный репозиторий (GitHub/GitLab) при необходимости
- [ ] Добавить структуру проекта (CSS, JS файлы) по мере развития

---
*Файл обновляется по мере развития проекта и изменения требований*

