# Архитектурный план

Цели: запуск без бэкенда (CDN Vue + локальные файлы), работа из папки/`file://`, получение данных из публичных API (CoinGecko и др.), всё состояние и история — локально (localStorage/IndexedDB).

Слои
- core/: конфиг, fetch-обёртка (таймауты/ретраи), абстракция хранения (localStorage/IndexedDB), общие расчётные хелперы, схемы валидации входящих данных.
  - core/security/: утилиты обфускации, валидация ключей, безопасное хранение чувствительных данных (PIN-коды, API-ключи).
  - core/api/: утилиты для работы с внешними API (не Vue компоненты). Независимые модули, экспортируют функции через `window`.
- domain/:
  - entities/: asset, metric, index, strategy, portfolio, history (временные ряды), correlation.
  - services/: calculator (метрики/индексы), portfolio-builder (weights/стратегии), backtest, correlation.
- features/ (feature-first):
  - markets: загрузка и отображение рынка (цены, проценты, объёмы).
  - metrics: расчёт/просмотр метрик по периодам.
  - indices: конструирование пользовательских индексов/скорингов.
  - portfolios: конструктор портфелей под стратегии, предпросмотр метрик.
  - strategies: пресеты правил (ребаланс, лимиты веса, фильтры).
  - correlations: матрицы корреляций для активов/портфелей.
  - history: загрузка, кэширование и просмотр временных рядов.
  - import-export: JSON экспорт/импорт настроек, стратегий, портфелей.
  - settings: тема, API-ключи, периодичность обновлений.
- ui/: переиспользуемые компоненты (таблицы, карточки, формы, графики), layout, тема/токены (через Bootstrap-утилиты).
  - ui/api/: Vue компоненты для работы с внешними API (Perplexity, CoinGecko, импорт/экспорт). Используют утилиты из `core/api/`.
  - ui/interaction/: компоненты взаимодействия с пользователем (сплэш, тема, чат).
- tests/: unit (расчёты), integration (сценарии сборки портфелей, импорт/экспорт).

Текущее размещение файлов
- **core/cfg-app.js** — конфиг приложения (defaults, модели).
- **core/security/u-sec-obfuscate.js** — утилиты обфускации для безопасного хранения PIN и API-ключей.
- **core/api/coingecko.js** — утилита для работы с CoinGecko API (трансформация данных, запросы к markets, search, top coins). Независимый модуль, экспортирует функции через `window.coinGeckoAPI`.
- **core/api/market-metrics.js** — утилита для получения метрик рынка (FGI, VIX, BTC Dominance, Open Interest, Funding Rate, Long/Short Ratio). Независимый модуль, экспортирует функции через `window.marketMetrics`.
- **core/api/perplexity.js** — утилита для отправки запросов к Perplexity Chat Completions API. Независимый модуль, экспортирует функции через `window.perplexityAPI`.
- **ui/api/import-export.js** — экспорт/импорт настроек.
- **ui/api/perplexity.js** (или **ui/api/settings.js**) — компонент общих настроек проекта (включая Perplexity AI).
- **ui/api/coins-manager.js** — компонент менеджера монет с поиском монет, избранным (хранилище избранного), сортировкой таблиц, кэшированием иконок, добавлением топ N монет по капитализации и объему. Использует утилиты из `core/api/coingecko.js` для работы с CoinGecko API.
- **ui/interaction/splash.js** — сплэш-экран с защитой PIN-кодом и настройкой API-ключа.
- **ui/interaction/theme.js** — применение темы.
- **ui/interaction/chat.js** — чат Perplexity. Использует утилиты из `core/api/perplexity.js` для работы с Perplexity API.
- **ui/interaction/header.js** — компонент хедера с гамбургер-меню, селектом математической модели, вкладками отображения и кнопками управления.
- **ui/interaction/footer.js** — компонент футера с индексами рынка и версиями фреймворков.
- **ui/styles/header.css** — стили компонента хедера.
- **ui/styles/footer.css** — стили компонента футера.
- **ui/styles/splash.css** — стили компонента сплэш-экрана.
- **ui/styles/dropdown.css** — стили dropdown меню (Material Design).
- **ui/styles/button.css** — стили компонента кнопки (перенос паддингов Bootstrap на дочерние элементы для корректной работы tooltips).
- **ui/styles/layout.css** — общие стили layout (контейнеры, отступы).
- **ui/styles/chat.css** — стили компонента чата.
- **ui/guide-ii.md** — руководство по интерфейсу и взаимодействию (принципы оформления и UX паттерны).
- **app/app-ui-root.js** — сборка и монтирование Vue-приложения.
- **index.html** — корневой HTML, подключает скрипты через CDN + локальные, подключает CSS файлы из `ui/styles/`.
- **review-app.html** — страница статистики проекта с рейтингом файлов, диаграммами распределения по типам файлов и топ-10 файлов, автоматической статистикой по иконкам и цветам. Использует единую систему управления review-файлами через `ui/review-manager.js` и `ui/review-styles.css`.
- **ui/interaction/review-messages.html** — каталог шаблонов сообщений Bootstrap (info, success, warning, danger) с примерами оформления. Использует единую систему управления review-файлами через `ui/review-manager.js` и `ui/review-styles.css`.
- **review-app-stats.js** — скрипт для подсчета и отображения статистики проекта (количество строк кода, файлов, иконок, цветов, рейтинг файлов, диаграммы).
- **ui/utils/table-sort-mixin.js** — глобальный Vue mixin для циклической сортировки таблиц (desc → asc → null → desc). Первый клик по несортированной колонке начинается с сортировки по убыванию (desc).
- **ui/utils/column-visibility-mixin.js** — переиспользуемый Vue mixin для управления видимостью колонок таблицы через вкладки. Поддерживает конфигурацию скрытия колонок в зависимости от активной вкладки, префиксное совпадение классов (например, 'col-percent' скрывает все 'col-percent-*'), мгновенное переключение через CSS классы на `<col>`, `<th>` и `<td>` элементах.
- **ui/utils/pluralize.js** — утилита для склонения русских числительных (форма 1, форма 2, форма 5).
- **ui/utils/ui-element-helper.js** — утилита для работы с UI элементами (иконки, кнопки, меню) на основе централизованного JSON файла соответствий.
- **ui/utils/coins-cd-helpers.js** — утилиты для работы с CD (Cumulative Delta): получение, форматирование и работа с CD значениями. Независимый модуль, экспортирует функции через `window.coinsCDHelpers`.
- **ui/utils/coins-favorites-helpers.js** — утилиты для работы с избранным: управление списком избранных монет, добавление/удаление, получение информации, обработка "неудачных" тикеров. Независимый модуль, экспортирует функции через `window.coinsFavoritesHelpers`.
- **ui/utils/hash-generator.js** — утилита для генерации детерминированных Base58 хэшей из строк. Используется для создания стабильных уникальных классов маркировки (`avto-{hash}`) для экземпляров компонентов. Обеспечивает, что один и тот же идентификатор всегда дает один и тот же хэш, что позволяет стилизовать конкретные экземпляры компонентов через их уникальные классы.
- **mm/median/utils/math-helpers.js** — базовые математические утилиты (clamp, safeNumber, tanh, median) для математической модели "median". Все модули изолированы через IIFE для предотвращения конфликтов имен.
- **mm/median/core/prc-weights.js** — расчет PRC-весов (Proximity Relevance Coefficients) для заданного горизонта прогноза, обновленные timeFramesDays для новых интервалов CoinGecko `[1/24, 1, 7, 14, 30, 200]`.
- **mm/median/core/pv1h-clip.js** — клиппинг PV1h (расчет порога клиппинга и сглаживание экстремальных значений). Константа EPSILON для порога чувствительности.
- **mm/median/metrics/cpt.js** — расчет CPT (Coin Potential) - потенциала монеты для краткосрочной торговли. Функции `computeEnhancedCPT` и `formatEnhancedCPT`. Базовые веса адаптированы для новых интервалов CoinGecko.
- **mm/median/metrics/cd.js** — расчет CD (Cumulative Delta) - накопительной дельты, отражающей суммарное изменение цены за период. Функции `calculateCDsWeighted` (расчет сырых и взвешенных CD) и `approximateCDHFromSeries` (аппроксимация CDH на горизонте). Экспортирует через `window.mmMedianCD`.
- **mm/median.md** — документация математической модели "median": переменные, вычислительный трек, глоссарий, особенности реализации.
- **ui/config/ui-element-mapping.json** — JSON файл с соответствиями иконок и команд, разделенными по категориям (actions, navigation, status, metrics, frameworks, other).
- **ui/config/table-columns-config.js** — централизованная конфигурация колонок таблицы монет. Статический объект конфигурации, не зависящий от Vue компонентов. Экспортирует `tableColumns` через `window.tableColumnsConfig`.
- **ui/components/header-coins.js** — компонент хедера для карточек с индикатором монет. Является эталонным примером паттерна создания хедеров карточек: изначально создается с простым заголовком, затем дополняется специфичными контролами.
- **ui/components/sortable-header.js** — переиспользуемый Vue компонент для сортируемых заголовков таблиц. Отображает заголовок колонки с иконкой сортировки (fas fa-sort, fas fa-sort-up, fas fa-sort-down) в зависимости от состояния (null, asc, desc). Эмитит событие `sort` при клике для обработки родительским компонентом. Используется в таблицах для единообразного отображения сортируемых заголовков. Имеет детерминированный `instanceHash` на основе `field` prop.
- **ui/components/table-coin-row.js** — переиспользуемый Vue компонент для первых двух колонок таблицы (№ и Тикер). Обеспечивает единообразие отображения первых двух колонок во всех таблицах вкладок математической модели Median. Содержит методы для получения ссылки на Bybit и тикера монеты. Используется для синхронизации отображения и поведения на всех вкладках. Имеет детерминированный `instanceHash` на основе `coin.id` или комбинации `coin.symbol` и `index`.
- **ui/components/cell-num.js** — переиспользуемый Vue компонент для форматирования и отображения числовых значений в ячейках таблицы. Обеспечивает гибкое форматирование чисел с поддержкой различных типов (integer, decimal, fraction), способов округления (precision, significant, step), разделителей, цветовых секторов, префиксов и единиц измерения, локализации и tooltip с полным значением. Используется для единообразного отображения числовых данных во всех таблицах. Имеет детерминированный `instanceHash` на основе `cellId` prop (опционально).
- **ui/components/cell-row-select.js** — переиспользуемый Vue компонент для ячейки выбора строки таблицы. Обеспечивает чекбокс с поддержкой indeterminate состояния, статусы строки (badges), номер строки, индикатор группы, разные типы строк (header, summary, warning, error) и разные режимы выбора (single, multiple, group). Используется для управления выбором строк в таблицах. Имеет детерминированный `instanceHash` на основе `rowId` prop.
- **ui/components/cell-coin.js** — переиспользуемый Vue компонент для отображения монеты в ячейке таблицы. Обеспечивает отображение иконки монеты, тикера, полного названия во всплывающей подсказке (title), обработку кликов и контекстного меню, кастомизацию через CSS-классы. Эмитит событие `context-menu` для открытия контекстного меню родительским компонентом. Используется для единообразного отображения монет во всех таблицах. Имеет детерминированный `instanceHash` на основе `coinId` prop.
- **ui/components/header-cell.js** — переиспользуемый Vue компонент для заголовков колонок таблицы с выпадающим меню и опциональной сортировкой. Обеспечивает единообразное поведение для всех типов заголовков. Имеет детерминированный `instanceHash` на основе `sortField` или `label` prop.
- **ui/components/header-cell-check.js** — переиспользуемый Vue компонент для мультичекбокса "выбрать все" в заголовке таблицы. Поддерживает неопределенное состояние (indeterminate). Имеет детерминированный `instanceHash` на основе статического идентификатора `'header-cell-check-all'`.
- **ui/components/table-data.js** — переиспользуемый Vue компонент для отображения таблиц с конфигурацией колонок. Обеспечивает централизованное управление колонками, поддержку специальных типов колонок, автоматическое форматирование и сортировку. Использует статический хэш `avto-4WpN9rS` (компонент-контейнер, используется один раз).
- **ui/components/button.js** — универсальный компонент кнопки с иконкой, текстом и индикатором. Основан на `uiElementHelper` для получения конфигурации (иконки, labels, tooltips). Обеспечивает полную UI-совместимость с Bootstrap (variants, sizes), раздельные tooltips для основной части и индикатора, перенос паддингов Bootstrap на дочерние элементы для корректной работы tooltips. Имеет детерминированный `instanceHash` на основе `buttonId`, `iconCommand` или `label` prop.
- **ui/components/menu-item.js** — переиспользуемый Vue компонент для пунктов меню с иконкой, командой и отметкой/указателем. Обеспечивает интеграцию с системой UI элементов через `uiElementHelper` (загрузка иконок из `ui-element-mapping.json`), отображение текста команды (label из mapping), универсальный индикатор для статусов (selected, disabled, loading, warning, error) или язычков переходов (submenu, external, modal), раздельные tooltips для основной части и индикатора. Используется для единообразного отображения пунктов меню во всех выпадающих списках. Имеет детерминированный `instanceHash` на основе `itemId`, `iconCommand` или `label` prop. Подробнее см. раздел "Паттерны универсальных компонентов" ниже.
- **ui/components/dropdown-menu.js** — переиспользуемый Vue компонент для универсального выпадающего меню. Обеспечивает единообразное поведение для всех выпадающих меню в приложении: позиционирование (absolute/fixed), размещение (bottom-start, bottom-end, top-start, top-end), клавиатурную навигацию (Escape, стрелки, Home/End), автофокус на первом элементе, закрытие по клику вне меню, управление курсором триггера через `trigger-selector` prop. Используется для всех выпадающих меню (счетчик, поиск, избранное, контекстное меню, меню сортировки). Имеет детерминированный `instanceHash` на основе `instanceId` prop. Подробнее см. раздел "Паттерны универсальных компонентов" ниже.
- **ui/components/horizon-input.js** — переиспользуемый Vue компонент для ввода числового значения горизонта прогноза (1-90 дней). Поддерживает v-model через `modelValue` и `update:modelValue`, валидацию и ограничение значений (min, max), настраиваемые размеры (sm, md, lg) и отображение label. Используется в хедере приложения и может использоваться в модальных окнах.

### Единая DOM-структура review-страниц

**Цель:** обеспечить единообразную, предсказуемую структуру DOM для всех вкладок/страниц ревью-файлов (статистика, цвета, иконки, сообщения и т.п.), чтобы:
- стили из `ui/review-styles.css` и общие стили (`ui/styles/layout.css`, `ui/styles/icons.css`) корректно применялись ко всем вкладкам без дублирования правил;
- `ui/review-manager.js` мог безусловно вставлять хедер с вкладками и каркас системных сообщений, не “ломая” верстку отдельных страниц;
- было проще сопровождать и развивать новые review-страницы по единому контракту.

**Базовый шаблон DOM для любой review-страницы:**
- `<body>`:
  - в `<head>` **обязательно** подключаются:
    - Bootstrap CSS;
    - Font Awesome + Material Symbols (иконки);
    - `ui/review-styles.css` (единые стили обзора);
    - `ui/styles/layout.css` и `ui/styles/icons.css` (общие стили приложения и иконок);
    - `ui/review-manager.js` (единый менеджер ревью) — **строго до** любых других скриптов review-страницы;
  - в `<body>` **нет** собственных хедеров/футеров: глобальный review-хедер с вкладками и секция системных сообщений вставляются динамически `ui/review-manager.js` поверх разметки страницы.

- `<div id="app" class="container-fluid">`:
  - единственный корневой контейнер содержимого review-страницы;
  - **обязателен** для всех вкладок ревью и должен быть прямым потомком `<body>` (review-manager ориентируется именно на `#app`);
  - внутри `#app` располагается **только контент конкретной вкладки**, без дублирования глобального хедера, футера и внешних контейнеров.

**Поведение `ui/review-manager.js` относительно DOM:**
- при загрузке страницы:
  - находит `#app` и вставляет **над ним** или **внутри него, первым элементом**:
    - общий review-хедер с вкладками (switch между review-страницами);
    - секцию системных сообщений для конкретной вкладки (Bootstrap card с заголовком и collapse);
  - далее оставляет нетронутым основной контент страницы внутри `#app`.
- новые review-страницы **обязаны** соответствовать этому контракту:
  - иметь ровно один `#app` контейнер, без дополнительных “корней”;
  - не вставлять собственные хедеры/футеры вне `#app`, чтобы не конфликтовать с общим layout;
  - использовать внутри `#app` стандартные Bootstrap-карточки и сетку (`row`/`col-*`), чтобы правила из `ui/review-styles.css` (например, выравнивание высоты карточек, отступы, стили collapse-кнопок) работали одинаково.

**Примеры соответствия:**
- `review-app.html`:
  - `<div id="app" class="container-fluid">` содержит только карточки статистики, диаграмму и таблицу рейтинга файлов;
  - таблицы и карточки помечаются классами, ожидаемыми `ui/review-styles.css` (например, `review-app-summary-row`, `review-table`).
- `ui/interaction/review-messages.html`:
  - `<div id="app" class="container-fluid">` содержит карточку Auto-scan и карточки с примерами сообщений;
  - секция системных сообщений вверху и review-хедер добавляются `ui/review-manager.js` и **не должны** дублироваться в самой странице.

**Архитектурные правила:**
- Любая новая review-страница:
  - создаётся по образцу существующих (`review-app.html`, `ui/interaction/review-messages.html`);
  - всегда содержит `#app` как единый корневой контейнер содержимого;
  - не нарушает предполагаемую вложенность: `body → #app.container-fluid → (row/col/card/….)`.
- Любые изменения в DOM-структуре review-страниц должны проверяться на:
  - совместимость с `ui/review-manager.js` (вставка хедера и системных сообщений);
  - сохранение применимости общих стилей из `ui/review-styles.css` (особенно селекторов, завязанных на `#app`, `.review-*` и стандартные Bootstrap-классы).

**Review-файлы документации UI**

- `ui/assets/icons-review.html` — каталог всех иконок проекта с интеграцией `ui-element-helper.js`. Использует общий менеджер `ui/review-manager.js` и стили `ui/review-styles.css`.
- `ui/styles/colors-review.html` — каталог всех цветовых переменных проекта, работающий через ту же систему review-файлов (`ui/review-manager.js`, `ui/review-styles.css`).
- `ui/review-manager.js` — общий JavaScript‑менеджер для всех review-страниц (хедер с вкладками, переключение между review, общие утилиты).
- `ui/review-styles.css` — общие стили для review-файлов, включая стилизованный хедер вкладок.

### Структура папок по специализации
- Папки специализации (`<сектор>/<специализация>/`) создаются по мере накопления файлов однородного назначения.
- Примеры: `ui/api/` (компоненты для работы с API), `ui/interaction/` (компоненты взаимодействия), `mm/` (математическая модель).
- Имена файлов без префиксов — специализация определяется из пути папки.

Ключевые сущности
- Asset: {id, symbol, name}.
- Metric: {assetId, period, kind, value}; источник — data-sources → calculator.
- Index: агрегированные скоры/метрики из набора Metric + формула.
- Strategy: правила (лимиты веса, фильтры волатильности/ликвидности, ребаланс).
- Portfolio: {strategyId, weights{assetId: number}, derivedMetrics, rebalance rules}.
- History: таймсерии цен/метрик/портфелей для backtest/корреляций.
- Correlation: матрицы между Asset/Portfolio на базе History.

Поток данных
Fetch (ui/api) → Validate/Normalize (schemas) → Compute (calculator/indices) → Build (portfolio-builder/strategy) → Persist (storage/IndexedDB) → Render (ui/api, ui/interaction).

Хранение и оффлайн
- Настройки и ключи: localStorage.
- История цен/метрик/портфелей: IndexedDB (поэтапная загрузка, при необходимости дельта-сжатие или RLE-кодирование).
- Экспорт/импорт: JSON для настроек, стратегий, портфелей, исторических срезов.

Библиотеки (при необходимости через CDN)
- Vue (уже есть), Chart.js или Lightweight Charts для графиков, zod (или легковесная своя валидация) для схем, idb-keyval для удобной работы с IndexedDB.

Стандарты разработки
- **Кодировка файлов**: UTF-8
- **Окончания строк**: CRLF (Windows), но Git настроен на автоматическое преобразование
- **HTML**: Минимальная валидная HTML5 разметка, язык по умолчанию `ru`, кодировка UTF-8, viewport meta для адаптивности
- **⚠️ Разделение ответственности между `core/api/` и `ui/api/`**: Критически важное архитектурное правило для обеспечения правильной организации кода:
  - **`core/api/`** — утилиты для работы с внешними API (не Vue компоненты):
    - Независимые модули, не зависят от Vue
    - Экспортируют чистые функции через `window.*API` (например: `window.coinGeckoAPI`, `window.perplexityAPI`, `window.marketMetrics`)
    - Содержат только логику запросов к API, обработку ошибок, трансформацию данных
    - Не содержат UI логики, реактивности Vue, шаблонов, состояний компонентов
    - Могут использоваться в любом контексте (Vue компоненты, обычные скрипты, тесты)
    - Примеры: `core/api/coingecko.js`, `core/api/perplexity.js`, `core/api/market-metrics.js`
  - **`ui/api/`** — Vue компоненты для работы с внешними API:
    - Vue компоненты с `template`, `data`, `methods`, `computed`, `watch`
    - Управляют UI состоянием (loading, error, данные для отображения)
    - Используют утилиты из `core/api/` для выполнения запросов к API
    - Содержат логику взаимодействия с пользователем, формы, отображение данных
    - Примеры: `ui/api/coins-manager.js` (использует `core/api/coingecko.js`), `ui/api/perplexity.js` (компонент настроек)
  - **Правило контроля для ИИ-агента**: При создании нового функционала для работы с внешним API:
    1. Если нужна только функция запроса к API → создавать в `core/api/`
    2. Если нужен UI компонент с формами, состоянием, реактивностью → создавать в `ui/api/` или `ui/interaction/`
    3. Vue компонент должен использовать утилиту из `core/api/`, а не делать запросы напрямую через `fetch`
    4. Если в Vue компоненте есть прямая логика `fetch` к API → вынести её в утилиту в `core/api/`
- **⚠️ Архитектурные системы UI/UX**: Проект использует несколько архитектурных систем для обеспечения консистентности и централизованного управления UI элементами:
  - **Цветовая модель HSL/HSLA**: Все цвета определяются через HSL/HSLA переменные в `ui/styles/theme-colors.css`. Подробнее см. раздел "Цветовая модель HSL/HSLA" в `ui/guide-ii.md`.
  - **Система z-index слоев**: Все значения `z-index` определяются через CSS переменные в `ui/styles/z-index.css` и связаны с Bootstrap z-index переменными. Подробнее см. раздел "Система z-index слоев" в `ui/guide-ii.md`.
  - **Система UI элементов (ui-element-helper)**: Централизованное управление UI элементами (иконки, кнопки, меню) через декларативную конфигурацию (JSON) и стили через CSS переменные. Подробнее см. раздел "Система иконок" в `ui/guide-ii.md`.
  - **Маркировка контейнеров**: Система автоматической маркировки контейнеров через CSS классы `avto-{hash}` для навигации в коде. Подробнее см. раздел "Маркировка контейнеров" в `ui/guide-ii.md`.
- **⚠️ Стандарты UI/UX**: Детальные правила стилизации, компонентов, паттернов взаимодействия описаны в `ui/guide-ii.md`. В `architect.md` остаются только архитектурные принципы и паттерны.

### Маркировка контейнеров

**Принцип**: Система автоматической маркировки значимых контейнеров через CSS классы `avto-{Base58_8символов}` для навигации в коде и указания агенту места в разметке.

**Архитектурные правила**:
- Классы `avto-*` используются только для маркировки, не используются в JS/CSS
- ID используются только для JS-зависимых элементов
- Полная изоляция: классы = маркировка, ID = функциональность
- Все экземпляры переиспользуемых компонентов должны иметь детерминированные уникальные хэши через computed свойство `instanceHash` на основе props компонента

**⚠️ Терминология**: Под словом "страница" пользователь всегда имеет в виду контейнер с классом `avto-X7pL2nQ` (корневой контейнер контента приложения).

**Детали реализации**: См. раздел "Маркировка контейнеров" в `ui/guide-ii.md`.

### Система z-index слоев

**Принцип**: Все значения `z-index` определяются через CSS переменные в `ui/styles/z-index.css` и связаны с Bootstrap z-index переменными для обеспечения консистентности и совместимости с компонентами Bootstrap.

**Архитектурные правила**:
- Все z-index значения должны использовать переменные из `ui/styles/z-index.css`
- Избегать хардкодных значений `z-index` в CSS правилах и inline стилях
- Переменные связаны с Bootstrap переменными для совместимости
- Централизованное управление предотвращает конфликты z-index

**Детали реализации**: См. раздел "Система z-index слоев" в `ui/guide-ii.md`.

### Система UI элементов (ui-element-helper)

**Принцип**: Архитектурный принцип централизованного управления UI элементами (иконки, кнопки, меню) через декларативную конфигурацию (JSON) и стили через CSS переменные, зарутованные от Bootstrap.

**Архитектурные правила**:
- Все соответствия иконок и команд централизованы в JSON файле `ui/config/ui-element-mapping.json`
- **⚠️ ВАЖНО - Встроенное содержимое**: Для избежания CORS проблем при работе с `file://` протоколом, содержимое `ui-element-mapping.json` встроено непосредственно в `ui/utils/ui-element-helper.js` как константа `uiElementMapping`. При добавлении новой иконки или команды **ОБЯЗАТЕЛЬНО** обновлять оба места:
  1. `ui/config/ui-element-mapping.json` (для документации и каталога иконок)
  2. Встроенное содержимое в `ui/utils/ui-element-helper.js` (для работы приложения)
- Стили иконок определяются через CSS переменные в `ui/styles/icons.css`, зарутованные от Bootstrap переменных
- Утилита `ui/utils/ui-element-helper.js` предоставляет функции для получения конфигурации UI элементов по категориям
- Система обеспечивает единую точку управления, упрощает добавление новых элементов, обеспечивает консистентность стилей и автоматическую адаптацию к темам

**Детали реализации**: См. раздел "Система иконок" в `ui/guide-ii.md`.

### Паттерн создания хедеров карточек

**Принцип**: Все хедеры карточек изначально создаются подобно `ui/components/header-coins.js` - сначала просто с заголовком, но потом дополняются набором специфичных своих контролов.

**Архитектурные правила**:
- Эталонный пример: `ui/components/header-coins.js`
- Единообразие структуры: все хедеры следуют единому паттерну
- Постепенное наращивание функциональности: от простого заголовка к специфичным контролам
- Структура: Props → Emits → Methods → Template (x-template)

**Детали реализации**: См. раздел "Паттерн создания хедеров карточек" в `ui/guide-ii.md`.

### Парадигма переключения представлений (View Switching Pattern)

**Принцип**: Централизованное управление состоянием активного представления (view) через единую точку истины в корневом компоненте приложения. Single Source of Truth (SSOT) с реактивным распространением через Vue.js.

**Архитектурные правила**:
- Состояние `activeTab` хранится в корневом компоненте (`app/app-ui-root.js`)
- Персистентность через `localStorage` с автоматическим восстановлением
- Переключение через метод `switchTab()` компонента хедера (`ui/interaction/header.js`)
- Компоненты получают `activeTab` через `this.$root.activeTab` или `window.appRoot.activeTab`
- Использование computed свойств для реактивности

**Детали реализации**: См. раздел "Парадигма переключения представлений" в `ui/guide-ii.md`.

### Переиспользуемая фича: Управление видимостью колонок таблицы через вкладки

**Принцип**: Переиспользуемый Vue mixin для управления видимостью колонок таблицы на основе активного представления. Интегрируется с парадигмой переключения представлений через реактивное отслеживание `activeTab`.

**Файл**: `ui/utils/column-visibility-mixin.js`

**Архитектурные правила**:
- Mixin расширяет парадигму переключения представлений, используя централизованное состояние `activeTab`
- Конфигурация колонок через `columnVisibilityConfig` в `data()` компонента
- Мгновенное переключение через CSS классы на `<col>`, `<th>` и `<td>` элементах
- Автоматический расчет ширины колонок на основе числа видимых колонок

**Детали реализации**: См. раздел "Управление видимостью колонок таблицы через вкладки" в `ui/guide-ii.md`.

Технические ограничения
- **⚠️ Порядок загрузки x-template шаблонов**: При использовании `<script type="text/x-template">` для Vue компонентов - шаблон **ОБЯЗАТЕЛЬНО** должен быть в DOM **ДО** загрузки Vue.js и компонентов, которые его используют. Правильный порядок в `index.html`: 1) Bootstrap JS, 2) x-template шаблоны, 3) Vue.js, 4) компоненты, 5) app-ui-root.js. Нарушение порядка приводит к тому, что Vue не находит шаблон при монтировании компонента, и компонент не отображается.
- **Размещение компонентов**: Vue-монтирует только то, что находится в пределах `#app`, поэтому сплэш-экраны, модалки, новые UI-блоки и контейнеры должны рендериться внутри `<div id="app">`.
- **Внешние запросы**: Не запускать внешние HTTP-запросы (CoinGecko, CDN и т.п.) или иные операции вне `#app`, пока сплэш экран не разблокирован.

### Проверка актуальности зависимостей

**Принцип**: Ежедневная проверка актуальности версий основных библиотек проекта для обеспечения использования последних стабильных версий.

**Регламент**:
- **Ежедневно, в начале каждого дня**: Проверять актуальность свежих версий Vue.js и Bootstrap
- Использовать веб-поиск для проверки последних стабильных версий
- Сравнивать текущие версии в проекте с последними доступными версиями
- **Немедленно предлагать миграцию и адаптацию** при обнаружении новых версий
- При миграции проверять breaking changes и обновлять код соответственно
- Обновлять CDN ссылки в HTML файлах
- Тестировать работоспособность после обновления


### ⚠️ Проблемы миграции математической модели

**Назначение**: Временная секция для отслеживания проблем и решений в процессе миграции математической модели из старого приложения.

**Связь с планом миграции**: См. файл `migration-plan.md` в корне проекта для подробного плана миграции и текущего статуса.

**Текущие проблемы**:

1. **Изменение интервалов времени**:
   - **Описание**: Интервалы изменились с `[1h, 24h, 7d, 30d, 60d, 90d]` на `[1h, 24h, 7d, 14d, 30d, 200d]`
   - **Влияние**: Требуется пересмотр весов и коэффициентов в функциях расчета (PRC-веса, веса для CPT, CD, CGR, пороги в MDN)
   - **Статус**: ⚠️ Требует анализа и пересмотра
   - **Решение**: См. раздел "Проблема 1" в `migration-plan.md`

2. **Зависимость от рыночных индикаторов**:
   - **Описание**: DIN и MDN зависят от рыночных индикаторов (FGI, VIX, BTC Dom, OI, FR, LSR)
   - **Статус**: ✅ Решение найдено (использование `core/api/market-metrics.js`)
   - **Решение**: См. раздел "Проблема 2" в `migration-plan.md`

3. **Корреляция с BTC**:
   - **Описание**: DIN использует корреляцию монеты с BTC для адаптации веса BTC-индикаторов
   - **Статус**: ⚠️ Требует реализации
   - **Решение**: См. раздел "Проблема 3" в `migration-plan.md`

4. **Независимость MDN от пользовательского горизонта**:
   - **Описание**: MDN должен быть независим от пользовательского горизонта прогноза (horizonDays)
   - **Статус**: ⚠️ Требует внимательной реализации
   - **Решение**: См. раздел "Проблема 4" в `migration-plan.md`

**Примечание**: Эта секция будет удалена после завершения миграции математической модели.

Принципы разработки

> **ВАЖНО**: Принципы разработки разделены по специализациям и хранятся в соответствующих документах:
> - **UI (интерфейс)** и **UX (паттерны взаимодействий)**: См. разделы "Interface (оформление)" и "Interaction (паттерны UX)" в `ui/guide-ii.md`
> - **MM (математическая модель)**: См. раздел "MM (математическая модель)" в этом документе

### UI (интерфейс) и UX (паттерны взаимодействий)

См. разделы "Interface (оформление)" и "Interaction (паттерны UX)" в `ui/guide-ii.md`.

**Примечание**: UX (User Experience) является неотъемлемой частью UI - веб-компоненты содержат и визуальное оформление, и логику взаимодействия одновременно. Поэтому команды `UI:` и `UX:` обе обновляют соответствующие разделы в `ui/guide-ii.md`.

### MM (математическая модель)
*Принципы математической модели, расчетов и обработки данных*

**Архитектура математических моделей**:
- В приложении будет **несколько математических моделей** (в отличие от старого приложения, где была только одна)
- Каждая модель имеет свою папку в структуре `mm/<название_модели>/` с подпапками `utils/`, `core/`, `metrics/`
- **Текущая модель**: "median" - модель расчета AGR по медианам (из старого приложения)
- **AGR (Aggregated Score)**: Конечный показатель пригодности монеты к торговле. В разных математических моделях AGR может иметь разные масштабы и размерности, но всегда служит для определения пригодности монеты к торговле
- Все функции модели экспортируются через `window.mm<НазваниеМодели>*` (например, `window.mmMedianCPT`, `window.mmMedianAGR`)

**Структура модели "median"**:
```
mm/
└── median/                    # Модель расчета AGR по медианам
    ├── utils/                 # Базовые математические утилиты
    ├── core/                  # Основные функции (PRC-веса, пересчет)
    └── metrics/                # Метрики (CPT, CD, CMD, CGR, DIN, AGR, MDN, медианы)
```

**План миграции**: См. файл `migration-plan.md` в корне проекта для подробного плана миграции математической модели из старого приложения.

- *(Принципы добавляются по командам MM: или ММ: от пользователя)*

### ⚠️ ПРАВИЛО: Обратная совместимость данных

**ОБЯЗАТЕЛЬНО**: См. раздел "Обратная совместимость данных" в `architect.md` - при изменении структуры сохраненных данных (localStorage, IndexedDB, JSON-файлы экспорта) **ВСЕГДА** предлагать пользователю реализацию обратной совместимости.

**Когда применять:**
- Переименование полей в JSON
- Изменение формата хранения (например: строка → объект)
- Миграция структуры localStorage/IndexedDB
- Обновление схемы экспорта/импорта
- Изменение версий API или форматов данных

**Что делать:**
1. **Предложить пользователю** добавить обратную совместимость
2. **Объяснить**, в чем будет состоять совместимость:
   - Какие старые форматы будут поддерживаться
   - Как будет происходить миграция данных
   - Какие риски при отсутствии совместимости (потеря данных, ошибки импорта и т.д.)
3. **Показать пример кода** для поддержки старого и нового формата
4. **Дать выбор пользователю**: делать совместимость сейчас или отложить

**Пример:**
```javascript
// Пользователь: "переименуй apiKey в apiKeyPerplexity"
// ИИ-агент должен предложить:

// Вариант 1: Без обратной совместимости (быстро, но может сломать существующие данные)
if (settings.secureData.apiKeyPerplexity) { ... }

// Вариант 2: С обратной совместимостью (медленнее, но безопасно)
if (settings.secureData.apiKeyPerplexity) {
  // Новый формат
} else if (settings.secureData.apiKey) {
  // Старый формат (для совместимости)
  // Автоматически мигрируем в новый
}
```

**Частые случаи:**
- **Экспорт/импорт настроек** - чаще всего требует совместимости
- **localStorage ключи** - при переименовании учитывать существующие данные
- **JSON-схемы** - версионировать (_version) и поддерживать старые версии
- **Миграция БД** - всегда с проверкой наличия данных в старом формате

**Исключения** (когда совместимость НЕ нужна):
- Проект на ранней стадии разработки (до первого релиза)
- Пользователь явно сказал "не надо обратной совместимости"
- Изменения не влияют на сохраненные данные (только UI/логика)

### ⚠️ Расширяемая система экспорта/импорта настроек

**Назначение**: Универсальная система экспорта/импорта всех настроек проекта, автоматически собирающая настройки из localStorage и поддерживающая расширение для будущих настроек.

**Реализация**: `ui/api/import-export.js`

**Принципы работы:**

1. **Автоматический сбор настроек**:
   - Система автоматически сканирует все ключи в `localStorage`
   - Разделяет настройки на две категории:
     - **Обычные настройки** (`regularSettings`) - хранятся напрямую в localStorage
     - **Обфусцированные настройки** (`secureData`) - хранятся через `securityObfuscate` (PIN, API-ключи)

2. **Расширяемость**:
   - При добавлении новой настройки в localStorage она **автоматически** попадает в экспорт/импорт
   - Не требуется изменять код экспорта/импорта для новых настроек
   - Исключения задаются через массив `EXCLUDED_KEYS` (служебные, временные ключи)

3. **Обфусцированные данные**:
   - Ключи обфусцированных данных задаются в массиве `SECURE_KEYS`
   - При экспорте сохраняются уже обфусцированные значения (не разворачиваются)
   - При импорте обфусцированные значения сохраняются как есть, разворачиваются только для UI

4. **Обратная совместимость**:
   - Поддерживаются форматы v1.0 (открытые данные), v2.0 (обфусцированные данные), v3.0 (универсальная система)
   - При импорте старых форматов автоматически выполняется миграция в новый формат

**Правила для разработчиков:**

1. **Добавление новой настройки**:
   - Если настройка хранится в `localStorage` - она автоматически экспортируется/импортируется
   - Если настройка чувствительная (PIN, API-ключ) - добавить ключ в массив `SECURE_KEYS` в `ui/api/import-export.js`
   - Если настройка служебная/временная - добавить ключ в массив `EXCLUDED_KEYS`

2. **Реактивные настройки Vue**:
   - Если настройка хранится в реактивном свойстве Vue (например, `this.theme`), но не в localStorage, добавить проверку в метод `collectAllSettings()`:
   ```javascript
   if (this.newSetting && !settings.regularSettings.newSetting) {
     settings.regularSettings.newSetting = this.newSetting;
   }
   ```

3. **Восстановление реактивных свойств при импорте**:
   - В методе `restoreAllSettings()` добавить обновление реактивного свойства:
   ```javascript
   if (key === 'newSetting' && this.newSetting !== undefined) {
     this.newSetting = value;
   }
   ```

4. **Версионирование формата**:
   - При изменении структуры экспорта/импорта увеличить `_version` в методе `collectAllSettings()`
   - Добавить поддержку старого формата в методе `restoreAllSettings()` для обратной совместимости

**Текущие настройки:**

- **Обычные настройки**: `theme`, `perplexityModel`, `cgCoins`, `cgLastUpdated`, `cgSelectedCoins`, `cgFavoriteCoins`, `activeTab` (и все остальные из localStorage)
- **Обфусцированные настройки**: `app-pin`, `perplexity-api-key`
- **Исключенные ключи**: `skipSplash` (sessionStorage, служебный), `cgIconsCache`, `cgIconsCacheTimestamp`, `marketMetricsCache`, `marketMetricsCacheTimestamp` (кэши, не экспортируются)

**Формат экспорта (v3.0):**
```json
{
  "_version": "3.0",
  "_obfuscated": true,
  "regularSettings": {
    "theme": "light",
    "perplexityModel": "sonar-pro"
  },
  "secureData": {
    "pin": "обфусцированное_значение",
    "apiKeyPerplexity": "обфусцированное_значение"
  }
}
```

### ⚠️ Система кэширования данных

**Назначение**: Оптимизация работы с внешними API через кэширование данных с временными ограничениями.

**Реализация**:
- **Иконки монет**: `ui/api/coins-manager.js` - метод `cacheCoinsIcons()`
- **Метрики рынка**: `ui/interaction/footer.js` - метод `fetchMarketIndices()`

**Принципы работы**:

1. **Кэширование иконок монет**:
   - Ключи localStorage: `cgIconsCache` (объект с URL иконок), `cgIconsCacheTimestamp` (время последнего обновления)
   - Интервал обновления: не чаще 1 раза в час (60 минут)
   - Логика: обновление только если прошло больше часа с последнего обновления
   - Хранение: объект `{coinId: iconUrl}` в localStorage

2. **Кэширование метрик рынка**:
   - Ключи localStorage: `marketMetricsCache` (объект с метриками), `marketMetricsCacheTimestamp` (время последнего обновления)
   - Интервал обновления: не чаще 1 раза в час (60 минут)
   - Фильтрация символов анимации: символы `|`, `/`, `-`, `\` заменяются на `"—"` перед сохранением в кэш
   - Валидация: кэшируются только успешно загруженные метрики с реальными значениями (не `"—"`, не `null`, не `undefined`)
   - Логика загрузки: если в кэше есть неопределенные метрики (`"—"`), они продолжают загружаться из API с показом анимации

3. **Правила кэширования**:
   - Пустые значения не кэшируются
   - Символы анимации фильтруются перед сохранением
   - При повреждении кэша (ошибка парсинга) - кэш удаляется и данные загружаются заново
   - При первом запуске (когда кэша нет) - данные загружаются сразу

**Текущие кэшируемые данные**:
- Иконки монет CoinGecko (`cgIconsCache`)
- Метрики рынка: FGI, VIX, BTC Dominance, Open Interest, Funding Rate, Long/Short Ratio (`marketMetricsCache`)

### ⚠️ Адаптивный таймаут для обработки rate limiting API

**Назначение**: Автоматическая адаптация задержек между запросами к внешним API для предотвращения блокировки из-за rate limiting (превышения лимита запросов).

**Реализация**: `ui/api/coins-manager.js` - методы `increaseAdaptiveTimeout()`, `decreaseAdaptiveTimeout()`, `resetAdaptiveTimeout()`

**Принципы работы**:

1. **Базовые параметры**:
   - Базовое значение таймаута: `300ms` (`adaptiveTimeoutBase`)
   - Максимальное значение таймаута: `10000ms` (10 секунд) (`adaptiveTimeoutMax`)
   - Текущий таймаут: `adaptiveTimeout` (начинается с базового значения)

2. **Увеличение таймаута при ошибках**:
   - При получении HTTP 429 (Too Many Requests) таймаут удваивается
   - Формула: `adaptiveTimeout = min(adaptiveTimeout * 2, adaptiveTimeoutMax)`
   - Логирование увеличения для отладки

3. **Уменьшение таймаута при успешных запросах**:
   - При успешных запросах и если прошло более 5 секунд без ошибок - таймаут уменьшается на 20%
   - Формула: `adaptiveTimeout = max(adaptiveTimeout * 0.8, adaptiveTimeoutBase)`
   - Постепенное восстановление до базового значения при стабильной работе

4. **Сброс таймаута**:
   - При начале нового процесса (например, добавления монет списком) таймаут сбрасывается к базовому значению
   - Метод `resetAdaptiveTimeout()` устанавливает `adaptiveTimeout = adaptiveTimeoutBase`

5. **Применение**:
   - Таймаут применяется во всех местах, где выполняются запросы к CoinGecko API
   - Используется как задержка между последовательными запросами в очереди добавления монет
   - Задержка между повторными попытками неудачных тикеров также использует адаптивный таймаут

**Обработка ошибок**:
- Все методы API (`fetchCoinGecko()`, `getCoinIdBySymbol()`, `searchCoins()`, `archiveFailedTicker()`) проверяют статус ответа
- При получении 429 ошибки вызывается `increaseAdaptiveTimeout()` перед повторной попыткой
- При успешных запросах вызывается `decreaseAdaptiveTimeout()` для постепенного восстановления

**Цель**: Автоматическое предотвращение блокировки API при массовых операциях (например, добавление большого списка монет), обеспечение стабильной работы при различных нагрузках.

### ⚠️ КРИТИЧЕСКИ ВАЖНО - Разделение ответственности между `core/api/` и `ui/api/`

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен контролировать правильное размещение файлов для работы с внешними API. См. раздел "Разделение ответственности между `core/api/` и `ui/api/`" в `architect.md` (раздел "Стандарты разработки").

**Краткое правило**:
- **`core/api/`** — утилиты (не Vue компоненты): чистые функции для запросов к API, экспорт через `window.*API`
- **`ui/api/`** — Vue компоненты: компоненты с UI, используют утилиты из `core/api/` для запросов

**При создании нового функционала для работы с API**:
1. Если нужна только функция запроса → создавать в `core/api/`
2. Если нужен UI компонент → создавать в `ui/api/` или `ui/interaction/`
3. Vue компонент должен использовать утилиту из `core/api/`, а не делать `fetch` напрямую
4. Если в Vue компоненте есть прямая логика `fetch` к API → вынести её в утилиту в `core/api/`

### ⚠️ Хранилище избранного и работа с таблицей монет

**Назначение**: Избранное - это хранилище избранных монет (любого избранного, но пока только монеты). Монета может одновременно присутствовать в таблице и в избранном. Избранное не удаляется при добавлении монеты в таблицу.

**Реализация**: `ui/api/coins-manager.js` - методы `syncCoinWithFavorites()`, `syncAllCoinsWithFavorites()`, `addFavoriteToTableById()`

**Принципы работы**:

1. **Хранилище избранного**: Избранное (`cgFavoriteCoins`) - это хранилище избранного. Монета может быть одновременно в таблице и в избранном.

2. **Метод `syncCoinWithFavorites(coinId, action)`**:
   - `action === 'add'`: При добавлении монеты в таблицу - НЕ удаляет её из избранного (избранное - хранилище)
   - `action === 'remove'`: При удалении монеты из таблицы - удаляет её из таблицы, но добавляет в избранное (если ещё нет)

3. **Метод `syncAllCoinsWithFavorites()`**:
   - НЕ удаляет из избранного монеты, которые есть в таблице (избранное - хранилище)
   - Вызывается при монтировании компонента (`mounted()`)

4. **Методы работы с избранным**:
   - `addFavoriteToTableById(coinId)` - добавление монеты из избранного в таблицу. Если монета уже в таблице - просто закрывает dropdown (отметка показывается в UI)
   - `toggleFavorite(coinId)` - переключение статуса избранного (добавление/удаление из избранного)
   - `isFavorite(coinId)` - проверка, является ли монета избранной

5. **Восстановление автоматически добавленных монет (failed-{ticker})**:
   - Монеты с ID `failed-{ticker}` при добавлении в таблицу автоматически находят реальный CoinGecko ID по тикеру
   - Если монета не найдена или попытка добавления не удалась - монета остается в избранном с оригинальным ID
   - При успешном добавлении проверяется наличие монеты в таблице, при ошибке - откат изменений

6. **Миграция данных**:
   - При загрузке приложения проверяются оба ключа: `cgArchivedCoins` (старый) и `cgFavoriteCoins` (новый)
   - Если есть старый ключ, но нет нового - данные мигрируются в новый ключ
   - Старый ключ `cgFavoriteCoinIds` также мигрируется в `cgFavoriteCoins` при первом запуске

**Цель**: Обеспечение единого хранилища избранного, возможность одновременного присутствия монеты в таблице и избранном, удобное управление избранными монетами.

### ⚠️ Отслеживание согласованности архитектурных правил

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен поддерживать согласованность между `.cursorrules`, `architect.md` и `ui/guide-ii.md`:

1. **Архитектурные правила** (принципы разработки, стандарты, технические ограничения, обратная совместимость данных, протоколирование, синхронизация настроек) хранятся в `architect.md`
2. **Правила UI/UX** (оформление, паттерны взаимодействий) хранятся в `ui/guide-ii.md`
3. **Правила поведения ИИ-агента** (работа с Git, обработка команд, контроль качества) остаются в `.cursorrules`
4. **Ссылки на правила**: В `.cursorrules` важные правила представлены как ссылки на соответствующие разделы в `architect.md` и `ui/guide-ii.md`
5. **При обновлении правил**: Если изменяется правило в одном документе, проверить, что ссылки в других документах актуальны и указывают на правильные разделы
6. **При добавлении новых правил**: Добавлять их в соответствующий документ (UI/UX → `ui/guide-ii.md`, архитектура → `architect.md`), а в `.cursorrules` оставлять ссылку на соответствующий раздел

**Цель**: Разделение ответственности:
- `architect.md` содержит архитектурные решения проекта, принципы математической модели, технические стандарты и процессы (протоколирование, синхронизация настроек)
- `ui/guide-ii.md` содержит принципы интерфейса и паттерны взаимодействий
- `.cursorrules` содержит только принципиальные правила работы ИИ-агента с ссылками на детали в других документах

Структура проекта
```
Root/
├── index.html          # Главный HTML файл
├── review-app.html     # Страница статистики проекта (рейтинг файлов, диаграммы, метрики)
├── review-app-stats.js # Скрипт для подсчета и отображения статистики проекта
├── .git/              # Git репозиторий
├── .vscode/           # Настройки VS Code (для совместимости с Cursor)
│   ├── settings.json  # Настройки проекта (синхронизируются с Cursor)
│   ├── extensions.json # Рекомендуемые расширения
│   ├── cspell-dict.txt # Пользовательский словарь для проверки орфографии
│   └── README.md      # Документация по настройкам
├── core/              # Ядро приложения
│   ├── cfg-app.js     # Конфиг приложения
│   ├── api/           # Утилиты для работы с внешними API
│   │   ├── coingecko.js      # Утилиты для CoinGecko API
│   │   ├── market-metrics.js # Утилиты для метрик рынка
│   │   └── perplexity.js     # Утилиты для Perplexity API
│   └── security/      # Безопасность
│       └── u-sec-obfuscate.js
├── ui/                # UI компоненты
│   ├── api/           # Компоненты для работы с API
│   │   ├── import-export.js
│   │   ├── perplexity.js
│   │   └── coins-manager.js
│   ├── interaction/   # Компоненты взаимодействия
│   │   ├── splash.js
│   │   ├── theme.js
│   │   ├── chat.js
│   │   ├── header.js
│   │   ├── footer.js
│   │   └── review-messages.html  # Каталог шаблонов сообщений Bootstrap
│   ├── styles/        # Стили компонентов
│   │   ├── header.css
│   │   ├── footer.css
│   │   ├── splash.css
│   │   ├── dropdown.css
│   │   ├── layout.css
│   │   ├── chat.css
│   │   ├── theme-colors.css
│   │   ├── z-index.css
│   │   ├── icons.css
│   │   ├── button.css
│   │   └── review-colors.html  # Каталог цветовых переменных проекта
│   ├── config/        # Конфигурационные файлы
│   │   ├── ui-element-mapping.json
│   │   └── table-columns-config.js
│   ├── assets/        # Ресурсы (иконки, изображения)
│   │   ├── icons/     # SVG-иконки проекта
│   │   │   └── icon-cross.svg
│   │   └── review-icons.html  # Каталог иконок проекта
│   ├── review-manager.js  # Единый менеджер для всех review-файлов (хедер с вкладками, навигация)
│   ├── review-styles.css  # Единые стили для всех review-файлов
│   ├── components/    # Переиспользуемые компоненты
│   │   ├── button.js
│   │   ├── dropdown-menu.js
│   │   ├── header-coins.js
│   │   ├── sortable-header.js
│   │   ├── table-coin-row.js
│   │   ├── cell-num.js
│   │   ├── cell-row-select.js
│   │   ├── cell-coin.js
│   │   ├── header-cell.js
│   │   ├── header-cell-check.js
│   │   ├── table-data.js
│   │   ├── menu-item.js
│   │   └── horizon-input.js
│   ├── utils/         # Утилиты
│   │   ├── table-sort-mixin.js
│   │   ├── column-visibility-mixin.js
│   │   ├── pluralize.js
│   │   ├── ui-element-helper.js
│   │   ├── hash-generator.js
│   │   ├── coins-cd-helpers.js
│   │   └── coins-favorites-helpers.js
│   └── guide-ii.md    # Руководство по интерфейсу и взаимодействию
├── app/               # Точка входа приложения
│   └── app-ui-root.js
├── mm/                # Математические модели
│   └── median/        # Математическая модель "median"
│       ├── median.md  # Документация модели
│       ├── utils/     # Базовые утилиты
│       │   └── math-helpers.js
│       ├── core/      # Ядро модели
│       │   ├── prc-weights.js
│       │   └── pv1h-clip.js
│       └── metrics/  # Метрики
│           ├── cpt.js
│           └── cd.js
├── architect.md       # Архитектурный план (этот файл)
├── .cursorrules       # Правила работы ИИ-агента


```
