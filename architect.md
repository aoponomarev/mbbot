# Архитектурный план

Цели: запуск без бэкенда (CDN Vue + локальные файлы), работа из папки/`file://`, получение данных из публичных API (CoinGecko и др.), всё состояние и история — локально (localStorage/IndexedDB).

Слои
- core/: конфиг, fetch-обёртка (таймауты/ретраи), абстракция хранения (localStorage/IndexedDB), общие расчётные хелперы, схемы валидации входящих данных.
  - core/security/: утилиты обфускации, валидация ключей, безопасное хранение чувствительных данных (PIN-коды, API-ключи).
  - core/api/: утилиты для работы с внешними API (не Vue компоненты). Независимые модули, экспортируют функции через `window`.
- domain/:
  - entities/: asset, metric, index, strategy, portfolio, history (временные ряды), correlation.
  - services/: calculator (метрики/индексы), portfolio-builder (weights/стратегии), backtest, correlation.
- features/ (feature-first):
  - markets: загрузка и отображение рынка (цены, проценты, объёмы).
  - metrics: расчёт/просмотр метрик по периодам.
  - indices: конструирование пользовательских индексов/скорингов.
  - portfolios: конструктор портфелей под стратегии, предпросмотр метрик.
  - strategies: пресеты правил (ребаланс, лимиты веса, фильтры).
  - correlations: матрицы корреляций для активов/портфелей.
  - history: загрузка, кэширование и просмотр временных рядов.
  - import-export: JSON экспорт/импорт настроек, стратегий, портфелей.
  - settings: тема, API-ключи, периодичность обновлений.
- ui/: переиспользуемые компоненты (таблицы, карточки, формы, графики), layout, тема/токены (через Bootstrap-утилиты).
  - ui/api/: Vue компоненты для работы с внешними API (Perplexity, CoinGecko, импорт/экспорт). Используют утилиты из `core/api/`.
  - ui/interaction/: компоненты взаимодействия с пользователем (сплэш, тема, чат).
- tests/: unit (расчёты), integration (сценарии сборки портфелей, импорт/экспорт).

Текущее размещение файлов
- **core/cfg-app.js** — конфиг приложения (defaults, модели).
- **core/security/u-sec-obfuscate.js** — утилиты обфускации для безопасного хранения PIN и API-ключей.
- **core/api/market-metrics.js** — утилита для получения метрик рынка (FGI, VIX, BTC Dominance, Open Interest, Funding Rate, Long/Short Ratio). Независимый модуль, экспортирует функции через `window.marketMetrics`.
- **ui/api/import-export.js** — экспорт/импорт настроек.
- **ui/api/perplexity.js** (или **ui/api/settings.js**) — компонент общих настроек проекта (включая Perplexity AI).
- **ui/api/coingecko.js** — компонент виджета CoinGecko с поиском монет, архивом, сортировкой таблиц, кэшированием иконок, добавлением топ N монет по капитализации и объему.
- **ui/interaction/splash.js** — сплэш-экран с защитой PIN-кодом и настройкой API-ключа.
- **ui/interaction/theme.js** — применение темы.
- **ui/interaction/chat.js** — чат Perplexity.
- **ui/interaction/header.js** — компонент хедера с гамбургер-меню, селектом математической модели, вкладками отображения и кнопками управления.
- **ui/interaction/footer.js** — компонент футера с индексами рынка и версиями фреймворков.
- **ui/styles/header.css** — стили компонента хедера.
- **ui/styles/footer.css** — стили компонента футера.
- **ui/styles/splash.css** — стили компонента сплэш-экрана.
- **ui/styles/dropdown.css** — стили dropdown меню (Material Design).
- **ui/styles/layout.css** — общие стили layout (контейнеры, отступы).
- **ui/styles/chat.css** — стили компонента чата.
- **ui/guide-ii.md** — руководство по интерфейсу и взаимодействию (принципы оформления и UX паттерны).
- **app/app-ui-root.js** — сборка и монтирование Vue-приложения.
- **index.html** — корневой HTML, подключает скрипты через CDN + локальные, подключает CSS файлы из `ui/styles/`.
- **ui/utils/table-sort-mixin.js** — глобальный Vue mixin для циклической сортировки таблиц (null → asc → desc → null).
- **ui/utils/pluralize.js** — утилита для склонения русских числительных (форма 1, форма 2, форма 5).
- **ui/utils/icons-helper.js** — утилита для работы с иконками на основе централизованного JSON файла соответствий.
- **ui/config/icons-mapping.json** — JSON файл с соответствиями иконок и команд, разделенными по категориям (actions, navigation, status, metrics, frameworks, other).
- **ui/components/header-coins.js** — компонент хедера для карточек с индикатором монет. Является эталонным примером паттерна создания хедеров карточек: изначально создается с простым заголовком, затем дополняется специфичными контролами.

Структура папок по специализации
- Папки специализации (`<сектор>/<специализация>/`) создаются по мере накопления файлов однородного назначения.
- Примеры: `ui/api/` (компоненты для работы с API), `ui/interaction/` (компоненты взаимодействия), `mm/` (математическая модель).
- Имена файлов без префиксов — специализация определяется из пути папки.

Ключевые сущности
- Asset: {id, symbol, name}.
- Metric: {assetId, period, kind, value}; источник — data-sources → calculator.
- Index: агрегированные скоры/метрики из набора Metric + формула.
- Strategy: правила (лимиты веса, фильтры волатильности/ликвидности, ребаланс).
- Portfolio: {strategyId, weights{assetId: number}, derivedMetrics, rebalance rules}.
- History: таймсерии цен/метрик/портфелей для backtest/корреляций.
- Correlation: матрицы между Asset/Portfolio на базе History.

Поток данных
Fetch (ui/api) → Validate/Normalize (schemas) → Compute (calculator/indices) → Build (portfolio-builder/strategy) → Persist (storage/IndexedDB) → Render (ui/api, ui/interaction).

Хранение и оффлайн
- Настройки и ключи: localStorage.
- История цен/метрик/портфелей: IndexedDB (поэтапная загрузка, при необходимости дельта-сжатие или RLE-кодирование).
- Экспорт/импорт: JSON для настроек, стратегий, портфелей, исторических срезов.

Библиотеки (при необходимости через CDN)
- Vue (уже есть), Chart.js или Lightweight Charts для графиков, zod (или легковесная своя валидация) для схем, idb-keyval для удобной работы с IndexedDB.

Стандарты разработки
- **Кодировка файлов**: UTF-8
- **Окончания строк**: CRLF (Windows), но Git настроен на автоматическое преобразование
- **HTML**: Минимальная валидная HTML5 разметка, язык по умолчанию `ru`, кодировка UTF-8, viewport meta для адаптивности
- **Стилизация**: Приоритет использования Bootstrap классов и утилит для стилизации интерфейса. Минимизировать кастомные CSS стили, inline стили и секции `<style>` в HTML файлах. При необходимости кастомизации предпочитать Bootstrap утилиты и модификаторы классов. Избегать создания собственных CSS правил, если аналогичная функциональность доступна через Bootstrap
- **⚠️ Вынесение стилей в отдельные CSS файлы**: Все кастомные CSS стили должны выноситься в отдельные файлы в структуре `ui/styles/`. Стили группируются по компонентам для уменьшения связанности и улучшения переиспользования: `ui/styles/header.css` (стили хедера), `ui/styles/footer.css` (стили футера), `ui/styles/splash.css` (стили сплэш-экрана), `ui/styles/dropdown.css` (стили dropdown меню), `ui/styles/layout.css` (общие стили layout) и т.д. Inline стили (`style="..."`) и блоки `<style>` в HTML файлах должны заменяться на CSS классы в соответствующих файлах. Это уменьшает связанность кода, улучшает переиспользование и упрощает возможную инкапсуляцию компонентов. Динамические стили в JavaScript (например, вычисляемые значения ширины, анимации) могут оставаться в JS, но базовые стили должны быть в CSS файлах.
- **⚠️ Цветовая модель HSL/HSLA**: Проект использует цветовую модель **HSL (Hue, Saturation, Lightness)** с альфа-каналом (**HSLA**) как основу для всех цветовых определений. Это архитектурное решение обеспечивает консистентность, удобство настройки и поддержки цветовой схемы. Все цвета определяются через HSL/HSLA переменные в `ui/styles/theme-colors.css`. Структура переменных позволяет переиспользовать общие значения (Hue, Saturation) для создания семейств связанных цветов. Избегать использования `rgba()`, `rgb()`, hex-кодов в CSS правилах. Подробнее см. раздел "Цветовая модель HSL/HSLA" в `ui/guide-ii.md`.
- **⚠️ Система z-index слоев**: Все значения `z-index` определяются через CSS переменные в `ui/styles/z-index.css` и связаны с Bootstrap z-index переменными для консистентности. Система обеспечивает централизованное управление слоями наложения элементов, предотвращает конфликты z-index и упрощает поддержку. Все z-index значения должны использовать переменные из `z-index.css`, избегать хардкодных значений в CSS правилах и inline стилях. Переменные связаны с Bootstrap (`--bs-zindex-dropdown`, `--bs-zindex-modal` и т.д.) для совместимости с компонентами Bootstrap. Подробнее см. раздел "Система z-index слоев" ниже.
- **⚠️ Система иконок**: Архитектурный принцип централизованного управления иконками через декларативную конфигурацию (JSON) и стили через CSS переменные, зарутованные от Bootstrap. Соответствия иконок и команд централизованы в JSON файле `ui/config/icons-mapping.json`. Стили иконок определяются через CSS переменные в `ui/styles/icons.css` и зарутованы от Bootstrap переменных для консистентности. Утилита `ui/utils/icons-helper.js` предоставляет функции для получения иконок по категориям (actions, navigation, status, metrics, frameworks, other). Система обеспечивает единую точку управления иконками, упрощает добавление новых иконок, обеспечивает консистентность стилей и автоматическую адаптацию к темам. Это архитектурный принцип проекта, аналогичный цветовой модели HSL/HSLA и системе z-index слоев. Подробнее см. раздел "Система иконок" ниже.
- **⚠️ Маркировка контейнеров**: Система автоматической маркировки контейнеров через CSS классы для навигации в коде. См. раздел "Маркировка контейнеров" ниже.

### Маркировка контейнеров

**Назначение**: Автоматическая маркировка значимых контейнеров через CSS классы для удобной навигации в коде через DevTools и указания агенту места в разметке.

**Формат автоматической маркировки**:
- Префикс: `avto-`
- Формат: `avto-{Base58_8символов}`
- Примеры: `avto-X7pL2nQ`, `avto-K9mP4rT`
- Признак: класс начинается с `avto-` → чистый контейнер без JS/CSS зависимостей

**Правила применения**:

1. **Маркировать автоматическим классом** (`avto-{hash}`):
   - Основные секции (`<main>`, `<section>`, корневые `.container-fluid`)
   - Функциональные блоки (`.card`, корневые контейнеры виджетов)
   - Корневые контейнеры компонентов без JS-зависимостей

2. **НЕ маркировать**:
   - Мелкие обертки (`.mb-3`, `.input-group`, `.d-flex` без функционального значения)
   - Части компонентов (`.card-header`, `.card-body` внутри `.card`)
   - Элементы только для сетки (`.row`, `.col-*`)

3. **Осмысленные ID** (не `avto-*`):
   - Элементы с JS-зависимостями (`getElementById`, `querySelector`, `ref`)
   - Элементы с CSS-селекторами по ID
   - Элементы форм, привязанные к JS (`v-model`, обработчики)

**Изоляция**:
- Классы `avto-*` используются только для маркировки, не используются в JS/CSS
- ID используются только для JS-зависимых элементов (стандартная практика)
- Полная изоляция: классы = маркировка, ID = функциональность

**Примеры**:
```html
<!-- ✅ Автоматическая маркировка через класс -->
<div class="container-fluid app-main-container avto-X7pL2nQ">
  <main class="avto-K9mP4rT row justify-content-center">
    <div class="col-12 col-lg-4 mb-4">
      <div class="card avto-M3nP8qW">
        <!-- Контент -->
      </div>
    </div>
    <div class="col-12 mb-4">
      <div class="card avto-B7fN2kT">
        <!-- Контент -->
      </div>
    </div>
  </main>
</div>

<!-- ✅ Маркировка header и footer -->
<header class="position-fixed top-0 start-0 w-100 app-header avto-vn6jdk3M">
  <!-- Контент хедера -->
</header>
<footer class="position-fixed bottom-0 start-0 w-100 bg-body app-footer avto-3B8RpMhu">
  <!-- Контент футера -->
</footer>

<!-- ✅ JS-зависимый элемент через ID (не маркируется avto-) -->
<div id="splash-screen" class="app-splash-screen">
  <!-- Splash screen имеет ID и используется в JS через getElementById -->
</div>
<input id="apiKey" class="form-control" v-model="perplexityApiKey">
```

**Цель**: Удобная навигация в DevTools и указание агенту места в коде через инспектор.

**⚠️ Терминология**: Под словом "страница" пользователь всегда имеет в виду контейнер с классом `avto-X7pL2nQ` (корневой контейнер контента приложения). ИИ-агент должен понимать, что когда пользователь говорит "страница", речь идет именно об этом контейнере.

### Система z-index слоев

**Принцип**: Все значения `z-index` определяются через CSS переменные в `ui/styles/z-index.css` и связаны с Bootstrap z-index переменными для обеспечения консистентности и совместимости с компонентами Bootstrap.

**Преимущества централизованной системы z-index:**
- **Единая точка управления**: Все z-index значения находятся в одном файле, что упрощает настройку и поддержку слоев наложения.
- **Совместимость с Bootstrap**: Переменные связаны с Bootstrap z-index переменными (`--bs-zindex-dropdown`, `--bs-zindex-modal` и т.д.), что обеспечивает корректное взаимодействие с компонентами Bootstrap.
- **Предотвращение конфликтов**: Централизованное управление предотвращает случайные конфликты z-index и обеспечивает правильный порядок наложения элементов.
- **Легкость изменения**: Изменение z-index значения в одном месте автоматически применяется ко всем элементам, использующим соответствующую переменную.

**Структура переменных:**
- `--z-index-dropdown`: Dropdown меню (совпадает с `--bs-zindex-dropdown: 1000`)
- `--z-index-splash`: Сплэш-экран - самый верхний слой (9999)
- `--z-index-overlay`: Элементы внутри контейнеров, например, текст поверх SVG (1)
- `--z-index-footer`: Футер - фиксированный внизу (1000, совпадает с Bootstrap dropdown)
- `--z-index-header`: Хедер - фиксированный сверху (1050, совпадает с Bootstrap modal)

**Правила использования:**
- Все z-index значения должны использовать переменные из `ui/styles/z-index.css`.
- Избегать хардкодных значений `z-index` в CSS правилах и inline стилях.
- При необходимости нового z-index слоя - добавить переменную в `z-index.css` с учетом иерархии Bootstrap.
- Значения должны быть связаны с Bootstrap переменными где возможно для обеспечения совместимости.

**Связь с Bootstrap:**
Bootstrap 5 определяет следующие z-index переменные:
- `--bs-zindex-dropdown: 1000`
- `--bs-zindex-sticky: 1020`
- `--bs-zindex-fixed: 1030`
- `--bs-zindex-modal-backdrop: 1040`
- `--bs-zindex-modal: 1050`
- `--bs-zindex-popover: 1070`
- `--bs-zindex-tooltip: 1080`

Кастомные переменные проекта используют эти значения как основу, обеспечивая правильный порядок наложения элементов относительно компонентов Bootstrap.

### Система иконок

**Принцип**: Архитектурный принцип централизованного управления иконками через декларативную конфигурацию (JSON) и стили через CSS переменные, зарутованные от Bootstrap. Соответствия иконок и команд централизованы в JSON файле `ui/config/icons-mapping.json`. Стили иконок определяются через CSS переменные в `ui/styles/icons.css` и зарутованы от Bootstrap переменных для консистентности. Утилита `ui/utils/icons-helper.js` предоставляет функции для получения иконок по категориям.

**Концепт централизованного управления иконками:**
Система иконок построена на принципе разделения ответственности:
- **Декларативная конфигурация** (JSON): Все соответствия иконок и команд описаны в структурированном JSON файле, что обеспечивает единую точку истины для всех иконок в приложении.
- **Стили через CSS переменные**: Все стили иконок определяются через CSS переменные, зарутованные от Bootstrap переменных, что обеспечивает автоматическую адаптацию к темам и консистентность с остальными элементами интерфейса.
- **Программный доступ**: Утилита предоставляет функции для получения иконок по категориям, что упрощает использование в компонентах и обеспечивает типобезопасность через структурированные категории.

**Преимущества централизованной системы иконок:**
- **Единая точка управления**: Все соответствия иконок и команд находятся в одном JSON файле, что упрощает настройку и поддержку.
- **Консистентность стилей**: Стили иконок определяются через CSS переменные, зарутованные от Bootstrap переменных (`--bs-body-color`, `--bs-primary`, `--bs-secondary` и т.д.), что обеспечивает автоматическую адаптацию к темам.
- **Легкость добавления новых иконок**: Добавление новой иконки требует только обновления JSON файла и при необходимости CSS переменных.
- **Централизованное управление цветами**: Цвета иконок фреймворков и статусов определяются через CSS переменные, что упрощает настройку и поддержку.

**Структура системы:**
- **JSON файл соответствий** (`ui/config/icons-mapping.json`): Содержит соответствия иконок и команд, разделенные по категориям:
  - `actions`: Действия (refresh, theme, settings, export, import, select-all, deselect-all, delete, archive, save, eye, eye-slash, stop)
  - `navigation`: Навигация (move-to-start, move-up, move-down, move-to-end, sort, sort-up, sort-down)
  - `status`: Статусы (warning, error, success, check, spinner)
  - `metrics`: Метрики (bitcoin, fgi, vix, oi, fr, lsr)
  - `frameworks`: Фреймворки (vuejs, bootstrap)
  - `other`: Другие элементы (robot, database, hamburger)
- **CSS файл стилей** (`ui/styles/icons.css`): Определяет CSS переменные для цветов иконок:
  - `--icon-vuejs-color`: Цвет иконки Vue.js (hsl(152, 48%, 53%))
  - `--icon-bootstrap-color`: Цвет иконки Bootstrap (hsl(264, 45%, 47%))
  - `--icon-status-warning-color`: Цвет иконки предупреждения
  - `--icon-status-error-color`: Цвет иконки ошибки
  - `--icon-status-success-color`: Цвет иконки успеха
  - `--icon-action-color`: Цвет иконок действий (зарутован от `--bs-body-color`)
  - `--icon-action-hover-color`: Цвет иконок действий при hover (зарутован от `--bs-primary`)
  - `--icon-action-disabled-color`: Цвет иконок действий в disabled состоянии (зарутован от `--bs-secondary`)
- **Утилита** (`ui/utils/icons-helper.js`): Предоставляет функции для получения иконок:
  - `getActionIcon(action)`: Получить иконку для действия
  - `getNavigationIcon(navigation)`: Получить иконку для навигации
  - `getStatusIcon(status)`: Получить иконку для статуса
  - `getMetricIcon(metric)`: Получить иконку для метрики
  - `getFrameworkIcon(framework)`: Получить иконку для фреймворка
  - `getOtherIcon(other)`: Получить иконку для другого элемента
  - `getThemeIcon(theme)`: Получить иконку темы в зависимости от текущей темы
  - `getIconTitle(category, name)`: Получить title (подсказку) для иконки
  - `getIconDescription(category, name)`: Получить описание для иконки
  - `getFrameworkColor(framework)`: Получить цвет для иконки фреймворка

**Правила использования:**
- Все соответствия иконок и команд должны быть описаны в `ui/config/icons-mapping.json`.
- Стили иконок должны использовать CSS переменные из `ui/styles/icons.css`, избегать хардкодных цветов в CSS правилах и inline стилях.
- При добавлении новой иконки - добавить соответствие в JSON файл и при необходимости CSS переменную.
- Цвета иконок должны быть зарутованы от Bootstrap переменных для автоматической адаптации к темам.

**Связь с Bootstrap:**
CSS переменные иконок используют Bootstrap переменные как основу:
- `--icon-action-color: var(--bs-body-color)`
- `--icon-action-hover-color: var(--bs-primary)`
- `--icon-action-disabled-color: var(--bs-secondary)`
- `--icon-status-warning-color`: Использует Bootstrap warning цвет
- `--icon-status-error-color`: Использует Bootstrap danger цвет
- `--icon-status-success-color`: Использует Bootstrap success цвет

Это обеспечивает автоматическую адаптацию цветов иконок к темам приложения (light/dark) и консистентность с остальными элементами интерфейса.

### Паттерн создания хедеров карточек

**Принцип**: Все хедеры карточек изначально создаются подобно `ui/components/header-coins.js` - сначала просто с заголовком, но потом дополняются набором специфичных своих контролов.

**Эталонный пример**: Компонент `ui/components/header-coins.js` является эталонным примером этого паттерна. Он демонстрирует структуру и подход к созданию хедеров карточек.

**Преимущества паттерна:**
- **Единообразие структуры**: Все хедеры карточек следуют единому паттерну, что упрощает понимание и поддержку кода.
- **Постепенное наращивание функциональности**: Хедер начинается с простого заголовка, затем дополняется специфичными контролами по мере необходимости.
- **Переиспользование**: Общие элементы (заголовок, базовые контролы) могут быть переиспользованы в разных хедерах.
- **Упрощение поддержки**: Единая структура упрощает поиск и исправление проблем в хедерах карточек.

**Структура компонента хедера карточки:**
- **Props**: Принимает данные от родительского компонента (счетчики, состояние, данные для отображения).
- **Emits**: Эмитит события для взаимодействия с родительским компонентом (переключение dropdown, выбор, поиск, архивирование и т.д.).
- **Methods**: Содержит методы для обработки событий и форматирования данных (форматирование дат, получение данных из архива, проверка состояний).
- **Template**: Использует x-template шаблон для разделения логики и разметки.

**Правила создания хедеров карточек:**
- Начинать с простого заголовка и базовой структуры.
- Добавлять специфичные контролы постепенно, по мере необходимости.
- Использовать props для получения данных от родительского компонента.
- Использовать emits для взаимодействия с родительским компонентом.
- Следовать структуре и паттернам, используемым в `header-coins.js`.

Технические ограничения
- **⚠️ Порядок загрузки x-template шаблонов**: При использовании `<script type="text/x-template">` для Vue компонентов - шаблон **ОБЯЗАТЕЛЬНО** должен быть в DOM **ДО** загрузки Vue.js и компонентов, которые его используют. Правильный порядок в `index.html`: 1) Bootstrap JS, 2) x-template шаблоны, 3) Vue.js, 4) компоненты, 5) app-ui-root.js. Нарушение порядка приводит к тому, что Vue не находит шаблон при монтировании компонента, и компонент не отображается.
- **Размещение компонентов**: Vue-монтирует только то, что находится в пределах `#app`, поэтому сплэш-экраны, модалки, новые UI-блоки и контейнеры должны рендериться внутри `<div id="app">`.
- **Внешние запросы**: Не запускать внешние HTTP-запросы (CoinGecko, CDN и т.п.) или иные операции вне `#app`, пока сплэш экран не разблокирован.

Принципы разработки

> **ВАЖНО**: Принципы разработки разделены по специализациям и хранятся в соответствующих документах:
> - **UI (интерфейс)** и **UX (паттерны взаимодействий)**: См. разделы "Interface (оформление)" и "Interaction (паттерны UX)" в `ui/guide-ii.md`
> - **MM (математическая модель)**: См. раздел "MM (математическая модель)" в этом документе

### UI (интерфейс) и UX (паттерны взаимодействий)

См. разделы "Interface (оформление)" и "Interaction (паттерны UX)" в `ui/guide-ii.md`.

**Примечание**: UX (User Experience) является неотъемлемой частью UI - веб-компоненты содержат и визуальное оформление, и логику взаимодействия одновременно. Поэтому команды `UI:` и `UX:` обе обновляют соответствующие разделы в `ui/guide-ii.md`.

### MM (математическая модель)
*Принципы математической модели, расчетов и обработки данных*

- *(Принципы добавляются по командам MM: или ММ: от пользователя)*

Обратная совместимость данных

**ОБЯЗАТЕЛЬНО**: При изменении структуры сохраненных данных (localStorage, IndexedDB, JSON-файлы экспорта) - **ВСЕГДА** предлагать пользователю реализацию обратной совместимости.

**Когда применять:**
- Переименование полей в JSON
- Изменение формата хранения (например: строка → объект)
- Миграция структуры localStorage/IndexedDB
- Обновление схемы экспорта/импорта
- Изменение версий API или форматов данных

**Что делать:**
1. **Предложить пользователю** добавить обратную совместимость
2. **Объяснить**, в чем будет состоять совместимость:
   - Какие старые форматы будут поддерживаться
   - Как будет происходить миграция данных
   - Какие риски при отсутствии совместимости (потеря данных, ошибки импорта и т.д.)
3. **Показать пример кода** для поддержки старого и нового формата
4. **Дать выбор пользователю**: делать совместимость сейчас или отложить

**Пример:**
```javascript
// Пользователь: "переименуй apiKey в apiKeyPerplexity"
// ИИ-агент должен предложить:

// Вариант 1: Без обратной совместимости (быстро, но может сломать существующие данные)
if (settings.secureData.apiKeyPerplexity) { ... }

// Вариант 2: С обратной совместимостью (медленнее, но безопасно)
if (settings.secureData.apiKeyPerplexity) {
  // Новый формат
} else if (settings.secureData.apiKey) {
  // Старый формат (для совместимости)
  // Автоматически мигрируем в новый
}
```

**Частые случаи:**
- **Экспорт/импорт настроек** - чаще всего требует совместимости
- **localStorage ключи** - при переименовании учитывать существующие данные
- **JSON-схемы** - версионировать (_version) и поддерживать старые версии
- **Миграция БД** - всегда с проверкой наличия данных в старом формате

**Исключения** (когда совместимость НЕ нужна):
- Проект на ранней стадии разработки (до первого релиза)
- Пользователь явно сказал "не надо обратной совместимости"
- Изменения не влияют на сохраненные данные (только UI/логика)

### ⚠️ Расширяемая система экспорта/импорта настроек

**Назначение**: Универсальная система экспорта/импорта всех настроек проекта, автоматически собирающая настройки из localStorage и поддерживающая расширение для будущих настроек.

**Реализация**: `ui/api/import-export.js`

**Принципы работы:**

1. **Автоматический сбор настроек**:
   - Система автоматически сканирует все ключи в `localStorage`
   - Разделяет настройки на две категории:
     - **Обычные настройки** (`regularSettings`) - хранятся напрямую в localStorage
     - **Обфусцированные настройки** (`secureData`) - хранятся через `securityObfuscate` (PIN, API-ключи)

2. **Расширяемость**:
   - При добавлении новой настройки в localStorage она **автоматически** попадает в экспорт/импорт
   - Не требуется изменять код экспорта/импорта для новых настроек
   - Исключения задаются через массив `EXCLUDED_KEYS` (служебные, временные ключи)

3. **Обфусцированные данные**:
   - Ключи обфусцированных данных задаются в массиве `SECURE_KEYS`
   - При экспорте сохраняются уже обфусцированные значения (не разворачиваются)
   - При импорте обфусцированные значения сохраняются как есть, разворачиваются только для UI

4. **Обратная совместимость**:
   - Поддерживаются форматы v1.0 (открытые данные), v2.0 (обфусцированные данные), v3.0 (универсальная система)
   - При импорте старых форматов автоматически выполняется миграция в новый формат

**Правила для разработчиков:**

1. **Добавление новой настройки**:
   - Если настройка хранится в `localStorage` - она автоматически экспортируется/импортируется
   - Если настройка чувствительная (PIN, API-ключ) - добавить ключ в массив `SECURE_KEYS` в `ui/api/import-export.js`
   - Если настройка служебная/временная - добавить ключ в массив `EXCLUDED_KEYS`

2. **Реактивные настройки Vue**:
   - Если настройка хранится в реактивном свойстве Vue (например, `this.theme`), но не в localStorage, добавить проверку в метод `collectAllSettings()`:
   ```javascript
   if (this.newSetting && !settings.regularSettings.newSetting) {
     settings.regularSettings.newSetting = this.newSetting;
   }
   ```

3. **Восстановление реактивных свойств при импорте**:
   - В методе `restoreAllSettings()` добавить обновление реактивного свойства:
   ```javascript
   if (key === 'newSetting' && this.newSetting !== undefined) {
     this.newSetting = value;
   }
   ```

4. **Версионирование формата**:
   - При изменении структуры экспорта/импорта увеличить `_version` в методе `collectAllSettings()`
   - Добавить поддержку старого формата в методе `restoreAllSettings()` для обратной совместимости

**Текущие настройки:**

- **Обычные настройки**: `theme`, `perplexityModel`, `cgCoins`, `cgLastUpdated`, `cgSelectedCoins`, `cgArchivedCoins`, `activeTab` (и все остальные из localStorage)
- **Обфусцированные настройки**: `app-pin`, `perplexity-api-key`
- **Исключенные ключи**: `skipSplash` (sessionStorage, служебный), `cgIconsCache`, `cgIconsCacheTimestamp`, `marketMetricsCache`, `marketMetricsCacheTimestamp` (кэши, не экспортируются)

**Формат экспорта (v3.0):**
```json
{
  "_version": "3.0",
  "_obfuscated": true,
  "regularSettings": {
    "theme": "light",
    "perplexityModel": "sonar-pro"
  },
  "secureData": {
    "pin": "обфусцированное_значение",
    "apiKeyPerplexity": "обфусцированное_значение"
  }
}
```

### ⚠️ Система кэширования данных

**Назначение**: Оптимизация работы с внешними API через кэширование данных с временными ограничениями.

**Реализация**:
- **Иконки монет**: `ui/api/coingecko.js` - метод `cacheCoinsIcons()`
- **Метрики рынка**: `ui/interaction/footer.js` - метод `fetchMarketIndices()`

**Принципы работы**:

1. **Кэширование иконок монет**:
   - Ключи localStorage: `cgIconsCache` (объект с URL иконок), `cgIconsCacheTimestamp` (время последнего обновления)
   - Интервал обновления: не чаще 1 раза в час (60 минут)
   - Логика: обновление только если прошло больше часа с последнего обновления
   - Хранение: объект `{coinId: iconUrl}` в localStorage

2. **Кэширование метрик рынка**:
   - Ключи localStorage: `marketMetricsCache` (объект с метриками), `marketMetricsCacheTimestamp` (время последнего обновления)
   - Интервал обновления: не чаще 1 раза в час (60 минут)
   - Фильтрация символов анимации: символы `|`, `/`, `-`, `\` заменяются на `"—"` перед сохранением в кэш
   - Валидация: кэшируются только успешно загруженные метрики с реальными значениями (не `"—"`, не `null`, не `undefined`)
   - Логика загрузки: если в кэше есть неопределенные метрики (`"—"`), они продолжают загружаться из API с показом анимации

3. **Правила кэширования**:
   - Пустые значения не кэшируются
   - Символы анимации фильтруются перед сохранением
   - При повреждении кэша (ошибка парсинга) - кэш удаляется и данные загружаются заново
   - При первом запуске (когда кэша нет) - данные загружаются сразу

**Текущие кэшируемые данные**:
- Иконки монет CoinGecko (`cgIconsCache`)
- Метрики рынка: FGI, VIX, BTC Dominance, Open Interest, Funding Rate, Long/Short Ratio (`marketMetricsCache`)

### ⚠️ Адаптивный таймаут для обработки rate limiting API

**Назначение**: Автоматическая адаптация задержек между запросами к внешним API для предотвращения блокировки из-за rate limiting (превышения лимита запросов).

**Реализация**: `ui/api/coingecko.js` - методы `increaseAdaptiveTimeout()`, `decreaseAdaptiveTimeout()`, `resetAdaptiveTimeout()`

**Принципы работы**:

1. **Базовые параметры**:
   - Базовое значение таймаута: `300ms` (`adaptiveTimeoutBase`)
   - Максимальное значение таймаута: `10000ms` (10 секунд) (`adaptiveTimeoutMax`)
   - Текущий таймаут: `adaptiveTimeout` (начинается с базового значения)

2. **Увеличение таймаута при ошибках**:
   - При получении HTTP 429 (Too Many Requests) таймаут удваивается
   - Формула: `adaptiveTimeout = min(adaptiveTimeout * 2, adaptiveTimeoutMax)`
   - Логирование увеличения для отладки

3. **Уменьшение таймаута при успешных запросах**:
   - При успешных запросах и если прошло более 5 секунд без ошибок - таймаут уменьшается на 20%
   - Формула: `adaptiveTimeout = max(adaptiveTimeout * 0.8, adaptiveTimeoutBase)`
   - Постепенное восстановление до базового значения при стабильной работе

4. **Сброс таймаута**:
   - При начале нового процесса (например, добавления монет списком) таймаут сбрасывается к базовому значению
   - Метод `resetAdaptiveTimeout()` устанавливает `adaptiveTimeout = adaptiveTimeoutBase`

5. **Применение**:
   - Таймаут применяется во всех местах, где выполняются запросы к CoinGecko API
   - Используется как задержка между последовательными запросами в очереди добавления монет
   - Задержка между повторными попытками неудачных тикеров также использует адаптивный таймаут

**Обработка ошибок**:
- Все методы API (`fetchCoinGecko()`, `getCoinIdBySymbol()`, `searchCoins()`, `archiveFailedTicker()`) проверяют статус ответа
- При получении 429 ошибки вызывается `increaseAdaptiveTimeout()` перед повторной попыткой
- При успешных запросах вызывается `decreaseAdaptiveTimeout()` для постепенного восстановления

**Цель**: Автоматическое предотвращение блокировки API при массовых операциях (например, добавление большого списка монет), обеспечение стабильной работы при различных нагрузках.

### ⚠️ Синхронизация данных между таблицей и архивом монет

**Назначение**: Обеспечение целостности данных - монета не может одновременно присутствовать в таблице и архиве.

**Реализация**: `ui/api/coingecko.js` - методы `syncCoinWithArchive()`, `syncAllCoinsWithArchive()`

**Принципы работы**:

1. **Приоритет**: Таблица (активное состояние) важнее архива. При конфликте монета остается в таблице, удаляется из архива.

2. **Метод `syncCoinWithArchive(coinId, action)`**:
   - `action === 'add'`: При добавлении монеты в таблицу - удаляет её из архива (если есть)
   - `action === 'archive'`: При архивировании монеты - удаляет её из таблицы (если есть)

3. **Метод `syncAllCoinsWithArchive()`**:
   - Проверяет и очищает дубликаты при загрузке приложения
   - Удаляет из архива все монеты, присутствующие в таблице
   - Вызывается при монтировании компонента (`mounted()`)

4. **Места применения синхронизации**:
   - `addCoin(coinId)` - при добавлении через поиск
   - `processTickersQueue()` - при добавлении через парсинг тикеров
   - `archiveCoin()` - при архивировании через контекстное меню
   - `archiveSelectedCoins()` - при массовом архивировании
   - `restoreFromArchiveById(coinId)` - при восстановлении из архива

5. **Восстановление автоматически заархивированных монет**:
   - Монеты с ID `failed-{ticker}` при восстановлении автоматически находят реальный CoinGecko ID по тикеру
   - Если монета не найдена или попытка добавления не удалась - монета возвращается обратно в архив с оригинальным ID
   - При успешном восстановлении проверяется наличие монеты в таблице, при ошибке - откат изменений

**Цель**: Обеспечение согласованности данных, предотвращение дублирования монет, автоматическое разрешение конфликтов между таблицей и архивом.

### ⚠️ Отслеживание согласованности архитектурных правил

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен поддерживать согласованность между `.cursorrules`, `architect.md` и `ui/guide-ii.md`:

1. **Архитектурные правила** (принципы разработки, стандарты, технические ограничения, обратная совместимость данных) хранятся в `architect.md`
2. **Правила UI/UX** (оформление, паттерны взаимодействий) хранятся в `ui/guide-ii.md`
3. **Правила поведения ИИ-агента** (работа с Git, протоколирование, синхронизация настроек) остаются в `.cursorrules`
4. **Ссылки на правила**: В `.cursorrules` и `architect.md` важные правила представлены как ссылки на соответствующие разделы в других документах
5. **При обновлении правил**: Если изменяется правило в одном документе, проверить, что ссылки в других документах актуальны и указывают на правильные разделы
6. **При добавлении новых правил**: Добавлять их в соответствующий документ (UI/UX → `ui/guide-ii.md`, архитектура → `architect.md`), а в других документах оставлять ссылку на соответствующий раздел

**Цель**: Разделение ответственности:
- `architect.md` содержит архитектурные решения проекта и принципы математической модели
- `ui/guide-ii.md` содержит принципы интерфейса и паттерны взаимодействий
- `.cursorrules` содержит правила работы ИИ-агента с ссылками на архитектуру и UI/UX

Структура проекта
```
Root/
├── index.html          # Главный HTML файл
├── .git/              # Git репозиторий
├── .vscode/           # Настройки VS Code (для совместимости с Cursor)
│   ├── settings.json  # Настройки проекта (синхронизируются с Cursor)
│   ├── extensions.json # Рекомендуемые расширения
│   ├── cspell-dict.txt # Пользовательский словарь для проверки орфографии
│   └── README.md      # Документация по настройкам
├── history/           # Логи чата
│   └── YYYY/          # Папки по годам
│       └── MM-DD.txt  # Дневные логи (например: 12-09.txt)
├── core/              # Ядро приложения
│   ├── cfg-app.js     # Конфиг приложения
│   └── security/      # Безопасность
│       └── u-sec-obfuscate.js
├── ui/                # UI компоненты
│   ├── api/           # Компоненты для работы с API
│   │   ├── import-export.js
│   │   ├── perplexity.js
│   │   └── coingecko.js
│   ├── interaction/   # Компоненты взаимодействия
│   │   ├── splash.js
│   │   ├── theme.js
│   │   ├── chat.js
│   │   ├── header.js
│   │   └── footer.js
│   ├── styles/        # Стили компонентов
│   │   ├── header.css
│   │   ├── footer.css
│   │   ├── splash.css
│   │   ├── dropdown.css
│   │   ├── layout.css
│   │   ├── chat.css
│   │   ├── theme-colors.css
│   │   ├── z-index.css
│   │   └── icons.css
│   ├── config/        # Конфигурационные файлы
│   │   └── icons-mapping.json
│   ├── utils/         # Утилиты
│   │   ├── table-sort-mixin.js
│   │   ├── pluralize.js
│   │   └── icons-helper.js
│   └── guide-ii.md    # Руководство по интерфейсу и взаимодействию
├── app/               # Точка входа приложения
│   └── app-ui-root.js
├── architect.md       # Архитектурный план (этот файл)
├── .cursorrules       # Правила работы ИИ-агента


```
