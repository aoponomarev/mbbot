# Архитектурный план

Цели: запуск без бэкенда (CDN Vue + локальные файлы), работа из папки/`file://`, получение данных из публичных API (CoinGecko и др.), всё состояние и история — локально (localStorage/IndexedDB).

Слои
- core/: конфиг, fetch-обёртка (таймауты/ретраи), абстракция хранения (localStorage/IndexedDB), общие расчётные хелперы, схемы валидации входящих данных.
  - core/security/: утилиты обфускации, валидация ключей, безопасное хранение чувствительных данных (PIN-коды, API-ключи).
  - core/api/: утилиты для работы с внешними API (не Vue компоненты). Независимые модули, экспортируют функции через `window`.
- domain/:
  - entities/: asset, metric, index, strategy, portfolio, history (временные ряды), correlation.
  - services/: calculator (метрики/индексы), portfolio-builder (weights/стратегии), backtest, correlation.
- features/ (feature-first):
  - markets: загрузка и отображение рынка (цены, проценты, объёмы).
  - metrics: расчёт/просмотр метрик по периодам.
  - indices: конструирование пользовательских индексов/скорингов.
  - portfolios: конструктор портфелей под стратегии, предпросмотр метрик.
  - strategies: пресеты правил (ребаланс, лимиты веса, фильтры).
  - correlations: матрицы корреляций для активов/портфелей.
  - history: загрузка, кэширование и просмотр временных рядов.
  - import-export: JSON экспорт/импорт настроек, стратегий, портфелей.
  - settings: тема, API-ключи, периодичность обновлений.
- ui/: переиспользуемые компоненты (таблицы, карточки, формы, графики), layout, тема/токены (через Bootstrap-утилиты).
  - ui/api/: Vue компоненты для работы с внешними API (Perplexity, CoinGecko, импорт/экспорт). Используют утилиты из `core/api/`.
  - ui/interaction/: компоненты взаимодействия с пользователем (сплэш, тема, чат).
- tests/: unit (расчёты), integration (сценарии сборки портфелей, импорт/экспорт).

Текущее размещение файлов
- **core/cfg-app.js** — конфиг приложения (defaults, модели).
- **core/security/u-sec-obfuscate.js** — утилиты обфускации для безопасного хранения PIN и API-ключей.
- **core/api/market-metrics.js** — утилита для получения метрик рынка (FGI, VIX, BTC Dominance, Open Interest, Funding Rate, Long/Short Ratio). Независимый модуль, экспортирует функции через `window.marketMetrics`.
- **ui/api/import-export.js** — экспорт/импорт настроек.
- **ui/api/perplexity.js** (или **ui/api/settings.js**) — компонент общих настроек проекта (включая Perplexity AI).
- **ui/api/coingecko.js** — компонент виджета CoinGecko с поиском монет, избранным (хранилище избранного), сортировкой таблиц, кэшированием иконок, добавлением топ N монет по капитализации и объему.
- **ui/interaction/splash.js** — сплэш-экран с защитой PIN-кодом и настройкой API-ключа.
- **ui/interaction/theme.js** — применение темы.
- **ui/interaction/chat.js** — чат Perplexity.
- **ui/interaction/header.js** — компонент хедера с гамбургер-меню, селектом математической модели, вкладками отображения и кнопками управления.
- **ui/interaction/footer.js** — компонент футера с индексами рынка и версиями фреймворков.
- **ui/styles/header.css** — стили компонента хедера.
- **ui/styles/footer.css** — стили компонента футера.
- **ui/styles/splash.css** — стили компонента сплэш-экрана.
- **ui/styles/dropdown.css** — стили dropdown меню (Material Design).
- **ui/styles/layout.css** — общие стили layout (контейнеры, отступы).
- **ui/styles/chat.css** — стили компонента чата.
- **ui/guide-ii.md** — руководство по интерфейсу и взаимодействию (принципы оформления и UX паттерны).
- **app/app-ui-root.js** — сборка и монтирование Vue-приложения.
- **index.html** — корневой HTML, подключает скрипты через CDN + локальные, подключает CSS файлы из `ui/styles/`.
- **ui/utils/table-sort-mixin.js** — глобальный Vue mixin для циклической сортировки таблиц (desc → asc → null → desc). Первый клик по несортированной колонке начинается с сортировки по убыванию (desc).
- **ui/utils/column-visibility-mixin.js** — переиспользуемый Vue mixin для управления видимостью колонок таблицы через вкладки. Поддерживает конфигурацию скрытия колонок в зависимости от активной вкладки, префиксное совпадение классов (например, 'col-percent' скрывает все 'col-percent-*'), мгновенное переключение через CSS классы на `<col>`, `<th>` и `<td>` элементах.
- **ui/utils/pluralize.js** — утилита для склонения русских числительных (форма 1, форма 2, форма 5).
- **ui/utils/ui-element-helper.js** — утилита для работы с UI элементами (иконки, кнопки, меню) на основе централизованного JSON файла соответствий.
- **ui/utils/hash-generator.js** — утилита для генерации детерминированных Base58 хэшей из строк. Используется для создания стабильных уникальных классов маркировки (`avto-{hash}`) для экземпляров компонентов. Обеспечивает, что один и тот же идентификатор всегда дает один и тот же хэш, что позволяет стилизовать конкретные экземпляры компонентов через их уникальные классы.
- **mm/median/utils/math-helpers.js** — базовые математические утилиты (clamp, safeNumber, tanh, median) для математической модели "median". Все модули изолированы через IIFE для предотвращения конфликтов имен.
- **mm/median/core/prc-weights.js** — расчет PRC-весов (Proximity Relevance Coefficients) для заданного горизонта прогноза, обновленные timeFramesDays для новых интервалов CoinGecko `[1/24, 1, 7, 14, 30, 200]`.
- **mm/median/core/pv1h-clip.js** — клиппинг PV1h (расчет порога клиппинга и сглаживание экстремальных значений). Константа EPSILON для порога чувствительности.
- **mm/median/metrics/cpt.js** — расчет CPT (Coin Potential) - потенциала монеты для краткосрочной торговли. Функции `computeEnhancedCPT` и `formatEnhancedCPT`. Базовые веса адаптированы для новых интервалов CoinGecko.
- **ui/config/ui-element-mapping.json** — JSON файл с соответствиями иконок и команд, разделенными по категориям (actions, navigation, status, metrics, frameworks, other).
- **ui/components/header-coins.js** — компонент хедера для карточек с индикатором монет. Является эталонным примером паттерна создания хедеров карточек: изначально создается с простым заголовком, затем дополняется специфичными контролами.
- **ui/components/sortable-header.js** — переиспользуемый Vue компонент для сортируемых заголовков таблиц. Отображает заголовок колонки с иконкой сортировки (fas fa-sort, fas fa-sort-up, fas fa-sort-down) в зависимости от состояния (null, asc, desc). Эмитит событие `sort` при клике для обработки родительским компонентом. Используется в таблицах для единообразного отображения сортируемых заголовков. Имеет детерминированный `instanceHash` на основе `field` prop.
- **ui/components/table-coin-row.js** — переиспользуемый Vue компонент для первых двух колонок таблицы (№ и Тикер). Обеспечивает единообразие отображения первых двух колонок во всех таблицах вкладок математической модели Median. Содержит методы для получения ссылки на Bybit и тикера монеты. Используется для синхронизации отображения и поведения на всех вкладках. Имеет детерминированный `instanceHash` на основе `coin.id` или комбинации `coin.symbol` и `index`.
- **ui/components/cell-num.js** — переиспользуемый Vue компонент для форматирования и отображения числовых значений в ячейках таблицы. Обеспечивает гибкое форматирование чисел с поддержкой различных типов (integer, decimal, fraction), способов округления (precision, significant, step), разделителей, цветовых секторов, префиксов и единиц измерения, локализации и tooltip с полным значением. Используется для единообразного отображения числовых данных во всех таблицах. Имеет детерминированный `instanceHash` на основе `cellId` prop (опционально).
- **ui/components/cell-row-select.js** — переиспользуемый Vue компонент для ячейки выбора строки таблицы. Обеспечивает чекбокс с поддержкой indeterminate состояния, статусы строки (badges), номер строки, индикатор группы, разные типы строк (header, summary, warning, error) и разные режимы выбора (single, multiple, group). Используется для управления выбором строк в таблицах. Имеет детерминированный `instanceHash` на основе `rowId` prop.
- **ui/components/cell-coin.js** — переиспользуемый Vue компонент для отображения монеты в ячейке таблицы. Обеспечивает отображение иконки монеты, тикера, полного названия во всплывающей подсказке (title), обработку кликов и контекстного меню, кастомизацию через CSS-классы. Эмитит событие `context-menu` для открытия контекстного меню родительским компонентом. Используется для единообразного отображения монет во всех таблицах. Имеет детерминированный `instanceHash` на основе `coinId` prop.
- **ui/components/header-cell.js** — переиспользуемый Vue компонент для заголовков колонок таблицы с выпадающим меню и опциональной сортировкой. Обеспечивает единообразное поведение для всех типов заголовков. Имеет детерминированный `instanceHash` на основе `sortField` или `label` prop.
- **ui/components/header-cell-check.js** — переиспользуемый Vue компонент для мультичекбокса "выбрать все" в заголовке таблицы. Поддерживает неопределенное состояние (indeterminate). Имеет детерминированный `instanceHash` на основе статического идентификатора `'header-cell-check-all'`.
- **ui/components/table-data.js** — переиспользуемый Vue компонент для отображения таблиц с конфигурацией колонок. Обеспечивает централизованное управление колонками, поддержку специальных типов колонок, автоматическое форматирование и сортировку. Использует статический хэш `avto-4WpN9rS` (компонент-контейнер, используется один раз).
- **ui/components/button.js** — универсальный компонент кнопки с иконкой, текстом и индикатором. Основан на `uiElementHelper` для получения конфигурации (иконки, labels, tooltips). Обеспечивает полную UI-совместимость с Bootstrap (variants, sizes), раздельные tooltips для основной части и индикатора, перенос паддингов Bootstrap на дочерние элементы для корректной работы tooltips. Имеет детерминированный `instanceHash` на основе `buttonId`, `iconCommand` или `label` prop.
- **ui/components/menu-item.js** — переиспользуемый Vue компонент для пунктов меню с иконкой, командой и отметкой/указателем. Обеспечивает интеграцию с системой UI элементов через `uiElementHelper` (загрузка иконок из `ui-element-mapping.json`), отображение текста команды (label из mapping), универсальный индикатор для статусов (selected, disabled, loading, warning, error) или язычков переходов (submenu, external, modal), раздельные tooltips для основной части и индикатора. Используется для единообразного отображения пунктов меню во всех выпадающих списках. Имеет детерминированный `instanceHash` на основе `itemId`, `iconCommand` или `label` prop. Подробнее см. раздел "Паттерны универсальных компонентов" ниже.
- **ui/components/dropdown-menu.js** — переиспользуемый Vue компонент для универсального выпадающего меню. Обеспечивает единообразное поведение для всех выпадающих меню в приложении: позиционирование (absolute/fixed), размещение (bottom-start, bottom-end, top-start, top-end), клавиатурную навигацию (Escape, стрелки, Home/End), автофокус на первом элементе, закрытие по клику вне меню, управление курсором триггера через `trigger-selector` prop. Используется для всех выпадающих меню (счетчик, поиск, избранное, контекстное меню, меню сортировки). Имеет детерминированный `instanceHash` на основе `instanceId` prop. Подробнее см. раздел "Паттерны универсальных компонентов" ниже.

Структура папок по специализации
- Папки специализации (`<сектор>/<специализация>/`) создаются по мере накопления файлов однородного назначения.
- Примеры: `ui/api/` (компоненты для работы с API), `ui/interaction/` (компоненты взаимодействия), `mm/` (математическая модель).
- Имена файлов без префиксов — специализация определяется из пути папки.

Ключевые сущности
- Asset: {id, symbol, name}.
- Metric: {assetId, period, kind, value}; источник — data-sources → calculator.
- Index: агрегированные скоры/метрики из набора Metric + формула.
- Strategy: правила (лимиты веса, фильтры волатильности/ликвидности, ребаланс).
- Portfolio: {strategyId, weights{assetId: number}, derivedMetrics, rebalance rules}.
- History: таймсерии цен/метрик/портфелей для backtest/корреляций.
- Correlation: матрицы между Asset/Portfolio на базе History.

Поток данных
Fetch (ui/api) → Validate/Normalize (schemas) → Compute (calculator/indices) → Build (portfolio-builder/strategy) → Persist (storage/IndexedDB) → Render (ui/api, ui/interaction).

Хранение и оффлайн
- Настройки и ключи: localStorage.
- История цен/метрик/портфелей: IndexedDB (поэтапная загрузка, при необходимости дельта-сжатие или RLE-кодирование).
- Экспорт/импорт: JSON для настроек, стратегий, портфелей, исторических срезов.

Библиотеки (при необходимости через CDN)
- Vue (уже есть), Chart.js или Lightweight Charts для графиков, zod (или легковесная своя валидация) для схем, idb-keyval для удобной работы с IndexedDB.

Стандарты разработки
- **Кодировка файлов**: UTF-8
- **Окончания строк**: CRLF (Windows), но Git настроен на автоматическое преобразование
- **HTML**: Минимальная валидная HTML5 разметка, язык по умолчанию `ru`, кодировка UTF-8, viewport meta для адаптивности
- **Стилизация**: Приоритет использования Bootstrap классов и утилит для стилизации интерфейса. Минимизировать кастомные CSS стили, inline стили и секции `<style>` в HTML файлах. При необходимости кастомизации предпочитать Bootstrap утилиты и модификаторы классов. Избегать создания собственных CSS правил, если аналогичная функциональность доступна через Bootstrap
- **⚠️ Вынесение стилей в отдельные CSS файлы**: Все кастомные CSS стили должны выноситься в отдельные файлы в структуре `ui/styles/`. Стили группируются по компонентам для уменьшения связанности и улучшения переиспользования: `ui/styles/header.css` (стили хедера), `ui/styles/footer.css` (стили футера), `ui/styles/splash.css` (стили сплэш-экрана), `ui/styles/dropdown.css` (стили dropdown меню), `ui/styles/layout.css` (общие стили layout) и т.д. Inline стили (`style="..."`) и блоки `<style>` в HTML файлах должны заменяться на CSS классы в соответствующих файлах. Это уменьшает связанность кода, улучшает переиспользование и упрощает возможную инкапсуляцию компонентов. Динамические стили в JavaScript (например, вычисляемые значения ширины, анимации) могут оставаться в JS, но базовые стили должны быть в CSS файлах.
- **⚠️ Цветовая модель HSL/HSLA**: Проект использует цветовую модель **HSL (Hue, Saturation, Lightness)** с альфа-каналом (**HSLA**) как основу для всех цветовых определений. Это архитектурное решение обеспечивает консистентность, удобство настройки и поддержки цветовой схемы. Все цвета определяются через HSL/HSLA переменные в `ui/styles/theme-colors.css`. Структура переменных позволяет переиспользовать общие значения (Hue, Saturation) для создания семейств связанных цветов. Избегать использования `rgba()`, `rgb()`, hex-кодов в CSS правилах. Подробнее см. раздел "Цветовая модель HSL/HSLA" в `ui/guide-ii.md`.
- **⚠️ Система z-index слоев**: Все значения `z-index` определяются через CSS переменные в `ui/styles/z-index.css` и связаны с Bootstrap z-index переменными для консистентности. Система обеспечивает централизованное управление слоями наложения элементов, предотвращает конфликты z-index и упрощает поддержку. Все z-index значения должны использовать переменные из `z-index.css`, избегать хардкодных значений в CSS правилах и inline стилях. Переменные связаны с Bootstrap (`--bs-zindex-dropdown`, `--bs-zindex-modal` и т.д.) для совместимости с компонентами Bootstrap. Подробнее см. раздел "Система z-index слоев" ниже.
- **⚠️ Система UI элементов (ui-element-helper)**: Архитектурный принцип централизованного управления UI элементами (иконки, кнопки, меню) через декларативную конфигурацию (JSON) и стили через CSS переменные, зарутованные от Bootstrap. Соответствия иконок и команд централизованы в JSON файле `ui/config/ui-element-mapping.json`. Стили иконок определяются через CSS переменные в `ui/styles/icons.css` и зарутованы от Bootstrap переменных для консистентности. Утилита `ui/utils/ui-element-helper.js` предоставляет функции для получения конфигурации UI элементов (иконки, labels, tooltips) по категориям (actions, navigation, status, metrics, frameworks, other). Система обеспечивает единую точку управления UI элементами, упрощает добавление новых элементов, обеспечивает консистентность стилей и автоматическую адаптацию к темам. Это архитектурный принцип проекта, аналогичный цветовой модели HSL/HSLA и системе z-index слоев. Подробнее см. раздел "Система UI элементов" ниже.
- **⚠️ Стандартные размеры чекбоксов**: Все чекбоксы в проекте должны иметь единый стандартный размер 13x13px. Размеры фиксируются через глобальное CSS правило в `ui/styles/layout.css` для класса `.form-check-input` с использованием `!important` для предотвращения переопределения. ИИ-агент должен отслеживать расхождение габаритов чекбоксов от стандартных 13x13px и соблюдать стандартные размеры при создании или изменении компонентов с чекбоксами.
- **⚠️ Маркировка контейнеров**: Система автоматической маркировки контейнеров через CSS классы для навигации в коде. См. раздел "Маркировка контейнеров" ниже.

### Маркировка контейнеров

**Назначение**: Автоматическая маркировка значимых контейнеров через CSS классы для удобной навигации в коде через DevTools и указания агенту места в разметке.

**Формат автоматической маркировки**:
- Префикс: `avto-`
- Формат: `avto-{Base58_8символов}`
- Примеры: `avto-X7pL2nQ`, `avto-K9mP4rT`
- Признак: класс начинается с `avto-` → чистый контейнер без JS/CSS зависимостей

**Правила применения**:

1. **Маркировать автоматическим классом** (`avto-{hash}`):
   - Основные секции (`<main>`, `<section>`, корневые `.container-fluid`)
   - Функциональные блоки (`.card`, корневые контейнеры виджетов)
   - Корневые контейнеры компонентов без JS-зависимостей

2. **НЕ маркировать**:
   - Мелкие обертки (`.mb-3`, `.input-group`, `.d-flex` без функционального значения)
   - Части компонентов (`.card-header`, `.card-body` внутри `.card`)
   - Элементы только для сетки (`.row`, `.col-*`)

3. **Осмысленные ID** (не `avto-*`):
   - Элементы с JS-зависимостями (`getElementById`, `querySelector`, `ref`)
   - Элементы с CSS-селекторами по ID
   - Элементы форм, привязанные к JS (`v-model`, обработчики)

**Изоляция**:
- Классы `avto-*` используются только для маркировки, не используются в JS/CSS
- ID используются только для JS-зависимых элементов (стандартная практика)
- Полная изоляция: классы = маркировка, ID = функциональность

**⚠️ ОБЯЗАТЕЛЬНОЕ ПРАВИЛО: Детерминированные хэши для экземпляров компонентов**

Все экземпляры переиспользуемых компонентов должны иметь детерминированные уникальные хэши для возможности кастомной стилизации конкретных экземпляров.

**Требования**:
- Каждый экземпляр компонента должен иметь computed свойство `instanceHash`, которое генерирует детерминированный Base58 хэш на основе уникального идентификатора экземпляра
- Хэш должен быть стабильным между сессиями - один и тот же идентификатор всегда дает один и тот же хэш
- Хэш генерируется через утилиту `window.hashGenerator.generateMarkupClass(uniqueId)`
- Уникальный идентификатор берется из props компонента (например, `coinId`, `rowId`, `cellId`, `field` и т.д.)

**Примеры**:
- `cell-coin`: `instanceHash` на основе `coinId` prop
- `cell-row-select`: `instanceHash` на основе `rowId` prop
- `cell-num`: `instanceHash` на основе `cellId` prop (опционально)
- `header-cell`: `instanceHash` на основе `sortField` или `label` prop
- `sortable-header`: `instanceHash` на основе `field` prop

**Использование в шаблонах**:
```html
<div :class="[instanceHash, cssClasses.cell]">
  <!-- контент компонента -->
</div>
```

**Исключения**:
- Компоненты-контейнеры, которые используются только один раз в приложении (например, `table-data`, `header-coins`) - могут использовать статический хэш или не иметь хэша
- Компоненты без уникальных идентификаторов - могут не иметь `instanceHash` (но рекомендуется добавить prop для идентификации)

**Примеры**:
```html
<!-- ✅ Автоматическая маркировка через класс -->
<div class="container-fluid app-main-container avto-X7pL2nQ">
  <main class="avto-K9mP4rT row justify-content-center">
    <div class="col-12 col-lg-4 mb-4">
      <div class="card avto-M3nP8qW">
        <!-- Контент -->
      </div>
    </div>
    <div class="col-12 mb-4">
      <div class="card avto-B7fN2kT">
        <!-- Контент -->
      </div>
    </div>
  </main>
</div>

<!-- ✅ Маркировка header и footer -->
<header class="position-fixed top-0 start-0 w-100 app-header avto-vn6jdk3M">
  <!-- Контент хедера -->
</header>
<footer class="position-fixed bottom-0 start-0 w-100 bg-body app-footer avto-3B8RpMhu">
  <!-- Контент футера -->
</footer>

<!-- ✅ JS-зависимый элемент через ID (не маркируется avto-) -->
<div id="splash-screen" class="app-splash-screen">
  <!-- Splash screen имеет ID и используется в JS через getElementById -->
</div>
<input id="apiKey" class="form-control" v-model="perplexityApiKey">
```

**Цель**: Удобная навигация в DevTools и указание агенту места в коде через инспектор.

**⚠️ Терминология**: Под словом "страница" пользователь всегда имеет в виду контейнер с классом `avto-X7pL2nQ` (корневой контейнер контента приложения). ИИ-агент должен понимать, что когда пользователь говорит "страница", речь идет именно об этом контейнере.

### Система z-index слоев

**Принцип**: Все значения `z-index` определяются через CSS переменные в `ui/styles/z-index.css` и связаны с Bootstrap z-index переменными для обеспечения консистентности и совместимости с компонентами Bootstrap.

**Преимущества централизованной системы z-index:**
- **Единая точка управления**: Все z-index значения находятся в одном файле, что упрощает настройку и поддержку слоев наложения.
- **Совместимость с Bootstrap**: Переменные связаны с Bootstrap z-index переменными (`--bs-zindex-dropdown`, `--bs-zindex-modal` и т.д.), что обеспечивает корректное взаимодействие с компонентами Bootstrap.
- **Предотвращение конфликтов**: Централизованное управление предотвращает случайные конфликты z-index и обеспечивает правильный порядок наложения элементов.
- **Легкость изменения**: Изменение z-index значения в одном месте автоматически применяется ко всем элементам, использующим соответствующую переменную.

**Структура переменных:**
- `--z-index-dropdown`: Dropdown меню (совпадает с `--bs-zindex-dropdown: 1000`)
- `--z-index-splash`: Сплэш-экран - самый верхний слой (9999)
- `--z-index-overlay`: Элементы внутри контейнеров, например, текст поверх SVG (1)
- `--z-index-footer`: Футер - фиксированный внизу (1000, совпадает с Bootstrap dropdown)
- `--z-index-header`: Хедер - фиксированный сверху (1050, совпадает с Bootstrap modal)

**Правила использования:**
- Все z-index значения должны использовать переменные из `ui/styles/z-index.css`.
- Избегать хардкодных значений `z-index` в CSS правилах и inline стилях.
- При необходимости нового z-index слоя - добавить переменную в `z-index.css` с учетом иерархии Bootstrap.
- Значения должны быть связаны с Bootstrap переменными где возможно для обеспечения совместимости.

**Связь с Bootstrap:**
Bootstrap 5 определяет следующие z-index переменные:
- `--bs-zindex-dropdown: 1000`
- `--bs-zindex-sticky: 1020`
- `--bs-zindex-fixed: 1030`
- `--bs-zindex-modal-backdrop: 1040`
- `--bs-zindex-modal: 1050`
- `--bs-zindex-popover: 1070`
- `--bs-zindex-tooltip: 1080`

Кастомные переменные проекта используют эти значения как основу, обеспечивая правильный порядок наложения элементов относительно компонентов Bootstrap.

### Система иконок

**Принцип**: Архитектурный принцип централизованного управления UI элементами (иконки, кнопки, меню) через декларативную конфигурацию (JSON) и стили через CSS переменные, зарутованные от Bootstrap. Соответствия иконок и команд централизованы в JSON файле `ui/config/ui-element-mapping.json`. Стили иконок определяются через CSS переменные в `ui/styles/icons.css` и зарутованы от Bootstrap переменных для консистентности. Утилита `ui/utils/ui-element-helper.js` предоставляет функции для получения конфигурации UI элементов (иконки, labels, tooltips) по категориям.

**Концепт централизованного управления UI элементами:**
Система UI элементов построена на принципе разделения ответственности:
- **Декларативная конфигурация** (JSON): Все соответствия иконок и команд описаны в структурированном JSON файле, что обеспечивает единую точку истины для всех UI элементов в приложении.
- **Стили через CSS переменные**: Все стили иконок определяются через CSS переменные, зарутованные от Bootstrap переменных, что обеспечивает автоматическую адаптацию к темам и консистентность с остальными элементами интерфейса.
- **Программный доступ**: Утилита предоставляет функции для получения конфигурации UI элементов (иконки, labels, tooltips) по категориям, что упрощает использование в компонентах и обеспечивает типобезопасность через структурированные категории.

**Преимущества централизованной системы UI элементов:**
- **Единая точка управления**: Все соответствия иконок и команд находятся в одном JSON файле, что упрощает настройку и поддержку.
- **Консистентность стилей**: Стили иконок определяются через CSS переменные, зарутованные от Bootstrap переменных (`--bs-body-color`, `--bs-primary`, `--bs-secondary` и т.д.), что обеспечивает автоматическую адаптацию к темам.
- **Легкость добавления новых элементов**: Добавление нового UI элемента требует только обновления JSON файла и при необходимости CSS переменных.
- **Централизованное управление цветами**: Цвета иконок фреймворков и статусов определяются через CSS переменные, что упрощает настройку и поддержку.
- **Раздельные tooltips**: Система поддерживает раздельные tooltips для основной части (иконка + текст) и индикатора в компонентах button и menu-item, что обеспечивает более точное описание функциональности.

**Структура системы:**
- **JSON файл соответствий** (`ui/config/ui-element-mapping.json`): Содержит схему соответствий:
  - **Новая схема `icons` (одна иконка → много команд)**: Позволяет одной иконке соответствовать нескольким командам. Например, иконка `fas fa-star` может использоваться для команд `favorite`, `add-to-favorites`, `remove-from-favorites`. Структура:
    ```json
    "icons": {
      "fas fa-star": {
        "commands": {
          "favorite": { "category": "actions", "label": "Избранное", "tooltip": "Выбрать избранное" },
          "add-to-favorites": { "category": "actions", "label": "В избранное", "tooltip": "Добавить в избранное" },
          "remove-from-favorites": { "category": "actions", "label": "Убрать из избранного", "tooltip": "Убрать из избранного" }
        },
        "defaultCommand": "favorite",
        "baseIcon": "fas fa-star"
      }
    }
    ```
  - **Индикаторы**: Индикаторы (статусы и навигационные указатели) также хранятся в схеме `icons` как команды с `category: "indicators"`. Примеры: `selected`, `disabled`, `loading`, `warning`, `error`, `favorite`, `not-favorite`, `submenu`, `external`, `modal`
- **CSS файл стилей** (`ui/styles/icons.css`): Определяет CSS переменные для цветов иконок:
  - `--icon-vuejs-color`: Цвет иконки Vue.js (hsl(152, 48%, 53%))
  - `--icon-bootstrap-color`: Цвет иконки Bootstrap (hsl(264, 45%, 47%))
  - `--icon-status-warning-color`: Цвет иконки предупреждения
  - `--icon-status-error-color`: Цвет иконки ошибки
  - `--icon-status-success-color`: Цвет иконки успеха
  - `--icon-action-color`: Цвет иконок действий (зарутован от `--bs-body-color`)
  - `--icon-action-hover-color`: Цвет иконок действий при hover (зарутован от `--bs-primary`)
  - `--icon-action-disabled-color`: Цвет иконок действий в disabled состоянии (зарутован от `--bs-secondary`)
- **Утилита** (`ui/utils/ui-element-helper.js`): Предоставляет функции для получения конфигурации UI элементов:
  - **Основные функции схемы "одна иконка → много команд"**:
    - `getIconCommands(iconClass)`: Получить все команды для иконки
    - `getIconByCommand(command)`: Получить базовую иконку для команды
    - `getCommandData(command)`: Получить данные команды (category, label, tooltip)
    - `getIconForCommand(category, command)`: Получить иконку для команды
  - **Функции для категорий** (используют `getIconForCommand` внутри):
    - `getActionIcon(action)`: Получить иконку для действия
    - `getNavigationIcon(navigation)`: Получить иконку для навигации
    - `getStatusIcon(status)`: Получить иконку для статуса
    - `getMetricIcon(metric)`: Получить иконку для метрики
    - `getFrameworkIcon(framework)`: Получить иконку для фреймворка
    - `getOtherIcon(other)`: Получить иконку для другого элемента
    - `getThemeIcon(theme)`: Получить иконку темы в зависимости от текущей темы
    - `getIconLabel(category, name)`: Получить label (текст для UI) для иконки
    - `getIconTooltip(category, name)`: Получить tooltip (подсказку) для иконки
    - `getFrameworkColor(framework)`: Получить цвет для иконки фреймворка
  - **Функции для индикаторов**:
    - `getIndicatorIcon(type, value)`: Получить иконку для indicator
    - `getIndicatorLabel(type, value)`: Получить label для indicator
    - `getIndicatorTooltip(type, value)`: Получить tooltip для indicator

**Правила использования:**
- **Единая схема "одна иконка → много команд"**: Все иконки и команды хранятся в схеме `icons`. Даже если у иконки только одна команда, она все равно должна быть в этой схеме для единообразия.
- **Все соответствия иконок и команд должны быть описаны в `ui/config/ui-element-mapping.json`**: При добавлении нового UI элемента добавить в секцию `icons` с соответствующими командами.
- **Индикаторы хранятся как команды с `category: "indicators"`**: Индикаторы (статусы и навигационные указатели) хранятся в той же схеме `icons`, но имеют `category: "indicators"` и дополнительные поля `type` и `value`.
- **Стили иконок должны использовать CSS переменные из `ui/styles/icons.css`**: Избегать хардкодных цветов в CSS правилах и inline стилях.
- **Цвета иконок должны быть зарутованы от Bootstrap переменных**: Для автоматической адаптации к темам.
- **Компоненты `button` и `menu-item` используют схему `icons`**: При указании `icon-command` компоненты ищут команду в схеме `icons` через `uiElementHelper`.
- **Раздельные tooltips**: Компоненты `button` и `menu-item` поддерживают раздельные tooltips для основной части (иконка + текст) и индикатора. Паддинги Bootstrap переносятся на дочерние элементы (`.button-main`, `.button-indicator`, `.menu-item-main`, `.menu-item-indicator`) для корректной работы tooltips.

**Связь с Bootstrap:**
CSS переменные иконок используют Bootstrap переменные как основу:
- `--icon-action-color: var(--bs-body-color)`
- `--icon-action-hover-color: var(--bs-primary)`
- `--icon-action-disabled-color: var(--bs-secondary)`
- `--icon-status-warning-color`: Использует Bootstrap warning цвет
- `--icon-status-error-color`: Использует Bootstrap danger цвет
- `--icon-status-success-color`: Использует Bootstrap success цвет

Это обеспечивает автоматическую адаптацию цветов иконок к темам приложения (light/dark) и консистентность с остальными элементами интерфейса.

### Паттерн создания хедеров карточек

**Принцип**: Все хедеры карточек изначально создаются подобно `ui/components/header-coins.js` - сначала просто с заголовком, но потом дополняются набором специфичных своих контролов.

**Эталонный пример**: Компонент `ui/components/header-coins.js` является эталонным примером этого паттерна. Он демонстрирует структуру и подход к созданию хедеров карточек.

**Преимущества паттерна:**
- **Единообразие структуры**: Все хедеры карточек следуют единому паттерну, что упрощает понимание и поддержку кода.
- **Постепенное наращивание функциональности**: Хедер начинается с простого заголовка, затем дополняется специфичными контролами по мере необходимости.
- **Переиспользование**: Общие элементы (заголовок, базовые контролы) могут быть переиспользованы в разных хедерах.
- **Упрощение поддержки**: Единая структура упрощает поиск и исправление проблем в хедерах карточек.

**Структура компонента хедера карточки:**
- **Props**: Принимает данные от родительского компонента (счетчики, состояние, данные для отображения).
- **Emits**: Эмитит события для взаимодействия с родительским компонентом (переключение dropdown, выбор, поиск, удаление из таблицы и т.д.).
- **Methods**: Содержит методы для обработки событий и форматирования данных (форматирование дат, получение данных из избранного, проверка состояний).
- **Template**: Использует x-template шаблон для разделения логики и разметки.

**Правила создания хедеров карточек:**
- Начинать с простого заголовка и базовой структуры.
- Добавлять специфичные контролы постепенно, по мере необходимости.
- Использовать props для получения данных от родительского компонента.
- Использовать emits для взаимодействия с родительским компонентом.
- Следовать структуре и паттернам, используемым в `header-coins.js`.

### Парадигма переключения представлений (View Switching Pattern)

**Принцип**: Централизованное управление состоянием активного представления (view) через единую точку истины в корневом компоненте приложения. Парадигма обеспечивает реактивное распространение состояния между компонентами и синхронизацию UI элементов с активным представлением.

**Архитектурная модель**: Single Source of Truth (SSOT) для состояния представления с реактивным распространением через Vue.js реактивную систему.

**Компоненты парадигмы**:

1. **Централизованное состояние** (`app/app-ui-root.js`):
   - `activeTab`: Реактивное свойство корневого компонента, хранящее идентификатор активного представления
   - Персистентность: Сохранение состояния в `localStorage` через Vue watcher для восстановления при перезагрузке
   - Инициализация: Загрузка сохраненного состояния из `localStorage` при монтировании приложения

2. **Управление переключением** (`ui/interaction/header.js`):
   - `switchTab(tabId)`: Метод переключения активного представления, обновляющий `activeTab` в корневом компоненте
   - `displayTabs`: Конфигурация доступных представлений (массив объектов с `id` и `label`)
   - Побочные эффекты: Автоматическое управление видимостью компонентов (например, закрытие панели настроек при переключении на определенные представления)

3. **Реактивное распространение состояния**:
   - Доступ к состоянию: Компоненты получают `activeTab` через `this.$root.activeTab` или `window.appRoot.activeTab`
   - Computed свойства: Компоненты могут определять computed свойства, зависящие от `activeTab`, для автоматического обновления при изменении
   - Условный рендеринг: Использование `v-if` и `v-show` для условного отображения компонентов в зависимости от активного представления

4. **UI компоненты переключения**:
   - Десктоп: Bootstrap `btn-group` с радиокнопками (`btn-check`) для визуального переключения
   - Мобильные устройства: Bootstrap dropdown для компактного отображения списка представлений
   - Визуальная обратная связь: Выделение активного представления через CSS классы (`app-header-tab-active`)

**Преимущества парадигмы**:
- **Единая точка истины**: Состояние активного представления хранится в одном месте, исключая рассинхронизацию
- **Реактивность**: Автоматическое обновление всех зависимых компонентов при изменении активного представления
- **Персистентность**: Сохранение выбранного представления между сессиями пользователя
- **Расширяемость**: Легкое добавление новых представлений через конфигурацию `displayTabs`
- **Разделение ответственности**: Логика переключения изолирована в компоненте хедера, состояние управляется корневым компонентом

**Структура данных**:
```javascript
// Корневой компонент (app-ui-root.js)
data() {
  return {
    activeTab: 'percent' // Идентификатор активного представления
  };
},
watch: {
  activeTab(newTab) {
    localStorage.setItem('activeTab', newTab); // Персистентность
  }
}

// Компонент хедера (header.js)
displayTabs: [
  { id: 'percent', label: '%' },
  { id: 'complex-deltas', label: 'Компл. дельты' },
  { id: 'gradients', label: 'Градиенты' },
  // ... другие представления
]
```

**Правила использования**:
- Все компоненты должны получать `activeTab` из корневого компонента, не хранить локальную копию
- Переключение представлений должно происходить только через метод `switchTab()` компонента хедера
- Новые представления добавляются в массив `displayTabs` компонента хедера
- Компоненты, зависящие от активного представления, должны использовать computed свойства для реактивности

**Связь с другими паттернами**:
- **Условный рендеринг**: Использование `v-if="activeTab === 'percent'"` для отображения компонентов
- **Column Visibility Management**: Использование `activeTab` для управления видимостью колонок таблиц (см. раздел "Переиспользуемая фича: Управление видимостью колонок таблицы через вкладки")
- **State Management**: Парадигма является частью общей архитектуры управления состоянием приложения

### Переиспользуемая фича: Управление видимостью колонок таблицы через вкладки

**Принцип**: Переиспользуемый Vue mixin для управления видимостью колонок таблицы на основе активного представления (active view). Реализует паттерн View-based Column Visibility Management, интегрируясь с парадигмой переключения представлений через реактивное отслеживание `activeTab` из корневого компонента.

**Файл**: `ui/utils/column-visibility-mixin.js`

**Архитектурная интеграция**: Mixin является расширением парадигмы переключения представлений (View Switching Pattern), используя централизованное состояние `activeTab` для управления видимостью колонок таблиц. Это обеспечивает синхронизацию отображения данных с активным представлением пользователя.

**Использование**:
1. Подключить mixin к компоненту: `mixins: [window.columnVisibilityMixin]`
2. Определить конфигурацию колонок в `data()`: `columnVisibilityConfig`
3. Добавить `<colgroup>` с `<col>` тегами в таблицу
4. Добавить классы к `<th>` и `<td>` элементам
5. Опционально: определить метод `getColumnClasses()` для явного указания всех классов колонок

**Пример конфигурации**:
```javascript
columnVisibilityConfig: {
  'percent': { hide: ['col-cd'] },           // На вкладке "%" скрыть колонки CD
  'complex-deltas': { hide: ['col-percent'] } // На вкладке "Компл. дельты" скрыть колонки процентов
}
```

**Преимущества**:
- **Переиспользуемость**: Один mixin для всех таблиц с переключением видимости колонок
- **Гибкость конфигурации**: Поддержка префиксного совпадения классов (например, 'col-percent' скрывает все 'col-percent-*')
- **Мгновенное переключение**: Использование CSS классов на `<col>`, `<th>` и `<td>` для мгновенного скрытия/показа без перерисовки таблицы
- **Автоматическое определение активной вкладки**: Получение активной вкладки из корневого компонента через `$root` или `window.appRoot`

**Структура mixin**:
- **Computed свойства**:
  - `activeTab()`: Реактивное computed свойство, получающее идентификатор активного представления из корневого компонента через `this.$root.activeTab` или `window.appRoot.activeTab`. Обеспечивает автоматическое обновление при изменении активного представления.
  - `columnVisibilityClasses()`: Реактивное computed свойство, возвращающее объект с CSS классами видимости для каждой колонки. Ключи объекта соответствуют классам колонок, значения - `'col-hidden'` для скрытых колонок или пустая строка для видимых. Вычисляется на основе `activeTab` и конфигурации `columnVisibilityConfig`.
  - `visibleColumnsCount()`: Реактивное computed свойство, подсчитывающее число видимых колонок на текущей вкладке через DOM (подсчет `<col>` элементов без класса `col-hidden`). Используется для автоматического расчета ширины колонок. Подсчет через DOM обеспечивает учет динамических колонок, генерируемых через `v-for`.
- **Watchers**:
  - `visibleColumnsCount`: Отслеживает изменение числа видимых колонок и автоматически вызывает `updateColumnWidths()` для пересчета ширины колонок при изменении видимости. Использует `$nextTick()` для гарантии обновления DOM.
  - `activeTab`: Отслеживает изменение активной вкладки и автоматически пересчитывает ширину колонок при переключении представлений через `$nextTick()` для гарантии обновления DOM.
- **Methods**:
  - `updateColumnWidths(visibleCount)`: Метод для автоматического расчета и установки ширины колонок на основе числа видимых колонок. Находит таблицу через `this.$el.querySelector('table')`, получает все видимые колонки из `<colgroup>`, рассчитывает ширину как `100% / число видимых колонок` и устанавливает её для каждой видимой колонки через `style.width`. Обеспечивает равномерное распределение ширины колонок при переключении вкладок.
- **Hooks**:
  - `mounted()`: Вызывает `updateColumnWidths()` через `$nextTick()` после монтирования компонента для инициализации ширины колонок при первой загрузке.

**CSS правила** (в `ui/styles/layout.css`):
- `col.col-hidden { width: 0; }` - скрытие колонки через colgroup
- `table th.col-hidden, table td.col-hidden { display: none; }` - универсальное правило для скрытия ячеек

**Правила использования**:
- Конфигурация должна быть определена в `data()` компонента как `columnVisibilityConfig`
- Классы колонок должны быть добавлены к `<col>`, `<th>` и `<td>` элементам
- Для префиксного совпадения использовать базовый класс (например, 'col-percent' для 'col-percent-1h', 'col-percent-24h' и т.д.)
- Опционально определить метод `getColumnClasses()` для явного указания всех классов колонок (если не определен, используются классы из конфигурации)

**Пример использования в компоненте**:
```javascript
window.cmpMyTable = {
  template: '#my-table-template',
  mixins: [window.columnVisibilityMixin],
  data() {
    return {
      columnVisibilityConfig: {
        'tab1': { hide: ['col-secondary'] },
        'tab2': { hide: ['col-primary'] }
      }
    };
  },
  methods: {
    getColumnClasses() {
      return ['col-primary', 'col-secondary', 'col-tertiary'];
    }
  }
};
```

**Интеграция с парадигмой переключения представлений**:
- **Зависимость от централизованного состояния**: Mixin использует `activeTab` из корневого компонента, обеспечивая синхронизацию с парадигмой переключения представлений
- **Реактивное обновление**: При изменении `activeTab` в корневом компоненте, computed свойство `columnVisibilityClasses()` автоматически пересчитывается, обновляя видимость колонок
- **Конфигурация представлений**: Каждое представление (tab) может иметь свою конфигурацию скрываемых колонок через `columnVisibilityConfig`
- **Мгновенное переключение**: Использование CSS классов обеспечивает мгновенное скрытие/показ колонок без перерисовки таблицы, что критично для плавного UX при переключении представлений

**Автоматический расчет ширины колонок**:
- Mixin автоматически рассчитывает и устанавливает ширину колонок на основе числа видимых колонок на текущей вкладке
- Ширина рассчитывается как `100% / число видимых колонок` для равномерного распределения пространства между видимыми колонками
- Пересчет происходит автоматически при:
  - Переключении вкладок (через watcher `activeTab`)
  - Изменении видимости колонок (через watcher `visibleColumnsCount`)
  - Монтировании компонента (через hook `mounted()`)
- Реализация использует DOM для точного подсчета видимых колонок, что учитывает динамические колонки, генерируемые через `v-for` (например, колонки CD)
- Ширина устанавливается через inline стили (`style.width`) для мгновенного применения без перерисовки таблицы

**Связь с другими фичами**:
- Используется вместе с `table-sort-mixin.js` для полнофункциональных таблиц с сортировкой и переключением видимости колонок
- CSS правила универсальны и работают с любыми таблицами, не привязаны к конкретным классам
- Является частью общей архитектуры управления состоянием представлений (View State Management)
- Автоматический расчет ширины колонок обеспечивает оптимальное использование пространства при переключении между представлениями с разным числом видимых колонок

Технические ограничения
- **⚠️ Порядок загрузки x-template шаблонов**: При использовании `<script type="text/x-template">` для Vue компонентов - шаблон **ОБЯЗАТЕЛЬНО** должен быть в DOM **ДО** загрузки Vue.js и компонентов, которые его используют. Правильный порядок в `index.html`: 1) Bootstrap JS, 2) x-template шаблоны, 3) Vue.js, 4) компоненты, 5) app-ui-root.js. Нарушение порядка приводит к тому, что Vue не находит шаблон при монтировании компонента, и компонент не отображается.
- **Размещение компонентов**: Vue-монтирует только то, что находится в пределах `#app`, поэтому сплэш-экраны, модалки, новые UI-блоки и контейнеры должны рендериться внутри `<div id="app">`.
- **Внешние запросы**: Не запускать внешние HTTP-запросы (CoinGecko, CDN и т.п.) или иные операции вне `#app`, пока сплэш экран не разблокирован.

### ⚠️ Проблемы миграции математической модели

**Назначение**: Временная секция для отслеживания проблем и решений в процессе миграции математической модели из старого приложения.

**Связь с планом миграции**: См. файл `migration-plan.md` в корне проекта для подробного плана миграции и текущего статуса.

**Текущие проблемы**:

1. **Изменение интервалов времени**:
   - **Описание**: Интервалы изменились с `[1h, 24h, 7d, 30d, 60d, 90d]` на `[1h, 24h, 7d, 14d, 30d, 200d]`
   - **Влияние**: Требуется пересмотр весов и коэффициентов в функциях расчета (PRC-веса, веса для CPT, CD, CGR, пороги в MDN)
   - **Статус**: ⚠️ Требует анализа и пересмотра
   - **Решение**: См. раздел "Проблема 1" в `migration-plan.md`

2. **Зависимость от рыночных индикаторов**:
   - **Описание**: DIN и MDN зависят от рыночных индикаторов (FGI, VIX, BTC Dom, OI, FR, LSR)
   - **Статус**: ✅ Решение найдено (использование `core/api/market-metrics.js`)
   - **Решение**: См. раздел "Проблема 2" в `migration-plan.md`

3. **Корреляция с BTC**:
   - **Описание**: DIN использует корреляцию монеты с BTC для адаптации веса BTC-индикаторов
   - **Статус**: ⚠️ Требует реализации
   - **Решение**: См. раздел "Проблема 3" в `migration-plan.md`

4. **Независимость MDN от пользовательского горизонта**:
   - **Описание**: MDN должен быть независим от пользовательского горизонта прогноза (horizonDays)
   - **Статус**: ⚠️ Требует внимательной реализации
   - **Решение**: См. раздел "Проблема 4" в `migration-plan.md`

**Примечание**: Эта секция будет удалена после завершения миграции математической модели.

Принципы разработки

> **ВАЖНО**: Принципы разработки разделены по специализациям и хранятся в соответствующих документах:
> - **UI (интерфейс)** и **UX (паттерны взаимодействий)**: См. разделы "Interface (оформление)" и "Interaction (паттерны UX)" в `ui/guide-ii.md`
> - **MM (математическая модель)**: См. раздел "MM (математическая модель)" в этом документе

### UI (интерфейс) и UX (паттерны взаимодействий)

См. разделы "Interface (оформление)" и "Interaction (паттерны UX)" в `ui/guide-ii.md`.

**Примечание**: UX (User Experience) является неотъемлемой частью UI - веб-компоненты содержат и визуальное оформление, и логику взаимодействия одновременно. Поэтому команды `UI:` и `UX:` обе обновляют соответствующие разделы в `ui/guide-ii.md`.

### MM (математическая модель)
*Принципы математической модели, расчетов и обработки данных*

**Архитектура математических моделей**:
- В приложении будет **несколько математических моделей** (в отличие от старого приложения, где была только одна)
- Каждая модель имеет свою папку в структуре `mm/<название_модели>/` с подпапками `utils/`, `core/`, `metrics/`
- **Текущая модель**: "median" - модель расчета AGR по медианам (из старого приложения)
- **AGR (Aggregated Score)**: Конечный показатель пригодности монеты к торговле. В разных математических моделях AGR может иметь разные масштабы и размерности, но всегда служит для определения пригодности монеты к торговле
- Все функции модели экспортируются через `window.mm<НазваниеМодели>*` (например, `window.mmMedianCPT`, `window.mmMedianAGR`)

**Структура модели "median"**:
```
mm/
└── median/                    # Модель расчета AGR по медианам
    ├── utils/                 # Базовые математические утилиты
    ├── core/                  # Основные функции (PRC-веса, пересчет)
    └── metrics/                # Метрики (CPT, CD, CMD, CGR, DIN, AGR, MDN, медианы)
```

**План миграции**: См. файл `migration-plan.md` в корне проекта для подробного плана миграции математической модели из старого приложения.

- *(Принципы добавляются по командам MM: или ММ: от пользователя)*

Обратная совместимость данных

**ОБЯЗАТЕЛЬНО**: При изменении структуры сохраненных данных (localStorage, IndexedDB, JSON-файлы экспорта) - **ВСЕГДА** предлагать пользователю реализацию обратной совместимости.

**Когда применять:**
- Переименование полей в JSON
- Изменение формата хранения (например: строка → объект)
- Миграция структуры localStorage/IndexedDB
- Обновление схемы экспорта/импорта
- Изменение версий API или форматов данных

**Что делать:**
1. **Предложить пользователю** добавить обратную совместимость
2. **Объяснить**, в чем будет состоять совместимость:
   - Какие старые форматы будут поддерживаться
   - Как будет происходить миграция данных
   - Какие риски при отсутствии совместимости (потеря данных, ошибки импорта и т.д.)
3. **Показать пример кода** для поддержки старого и нового формата
4. **Дать выбор пользователю**: делать совместимость сейчас или отложить

**Пример:**
```javascript
// Пользователь: "переименуй apiKey в apiKeyPerplexity"
// ИИ-агент должен предложить:

// Вариант 1: Без обратной совместимости (быстро, но может сломать существующие данные)
if (settings.secureData.apiKeyPerplexity) { ... }

// Вариант 2: С обратной совместимостью (медленнее, но безопасно)
if (settings.secureData.apiKeyPerplexity) {
  // Новый формат
} else if (settings.secureData.apiKey) {
  // Старый формат (для совместимости)
  // Автоматически мигрируем в новый
}
```

**Частые случаи:**
- **Экспорт/импорт настроек** - чаще всего требует совместимости
- **localStorage ключи** - при переименовании учитывать существующие данные
- **JSON-схемы** - версионировать (_version) и поддерживать старые версии
- **Миграция БД** - всегда с проверкой наличия данных в старом формате

**Исключения** (когда совместимость НЕ нужна):
- Проект на ранней стадии разработки (до первого релиза)
- Пользователь явно сказал "не надо обратной совместимости"
- Изменения не влияют на сохраненные данные (только UI/логика)

### ⚠️ Расширяемая система экспорта/импорта настроек

**Назначение**: Универсальная система экспорта/импорта всех настроек проекта, автоматически собирающая настройки из localStorage и поддерживающая расширение для будущих настроек.

**Реализация**: `ui/api/import-export.js`

**Принципы работы:**

1. **Автоматический сбор настроек**:
   - Система автоматически сканирует все ключи в `localStorage`
   - Разделяет настройки на две категории:
     - **Обычные настройки** (`regularSettings`) - хранятся напрямую в localStorage
     - **Обфусцированные настройки** (`secureData`) - хранятся через `securityObfuscate` (PIN, API-ключи)

2. **Расширяемость**:
   - При добавлении новой настройки в localStorage она **автоматически** попадает в экспорт/импорт
   - Не требуется изменять код экспорта/импорта для новых настроек
   - Исключения задаются через массив `EXCLUDED_KEYS` (служебные, временные ключи)

3. **Обфусцированные данные**:
   - Ключи обфусцированных данных задаются в массиве `SECURE_KEYS`
   - При экспорте сохраняются уже обфусцированные значения (не разворачиваются)
   - При импорте обфусцированные значения сохраняются как есть, разворачиваются только для UI

4. **Обратная совместимость**:
   - Поддерживаются форматы v1.0 (открытые данные), v2.0 (обфусцированные данные), v3.0 (универсальная система)
   - При импорте старых форматов автоматически выполняется миграция в новый формат

**Правила для разработчиков:**

1. **Добавление новой настройки**:
   - Если настройка хранится в `localStorage` - она автоматически экспортируется/импортируется
   - Если настройка чувствительная (PIN, API-ключ) - добавить ключ в массив `SECURE_KEYS` в `ui/api/import-export.js`
   - Если настройка служебная/временная - добавить ключ в массив `EXCLUDED_KEYS`

2. **Реактивные настройки Vue**:
   - Если настройка хранится в реактивном свойстве Vue (например, `this.theme`), но не в localStorage, добавить проверку в метод `collectAllSettings()`:
   ```javascript
   if (this.newSetting && !settings.regularSettings.newSetting) {
     settings.regularSettings.newSetting = this.newSetting;
   }
   ```

3. **Восстановление реактивных свойств при импорте**:
   - В методе `restoreAllSettings()` добавить обновление реактивного свойства:
   ```javascript
   if (key === 'newSetting' && this.newSetting !== undefined) {
     this.newSetting = value;
   }
   ```

4. **Версионирование формата**:
   - При изменении структуры экспорта/импорта увеличить `_version` в методе `collectAllSettings()`
   - Добавить поддержку старого формата в методе `restoreAllSettings()` для обратной совместимости

**Текущие настройки:**

- **Обычные настройки**: `theme`, `perplexityModel`, `cgCoins`, `cgLastUpdated`, `cgSelectedCoins`, `cgFavoriteCoins`, `activeTab` (и все остальные из localStorage)
- **Обфусцированные настройки**: `app-pin`, `perplexity-api-key`
- **Исключенные ключи**: `skipSplash` (sessionStorage, служебный), `cgIconsCache`, `cgIconsCacheTimestamp`, `marketMetricsCache`, `marketMetricsCacheTimestamp` (кэши, не экспортируются)

**Формат экспорта (v3.0):**
```json
{
  "_version": "3.0",
  "_obfuscated": true,
  "regularSettings": {
    "theme": "light",
    "perplexityModel": "sonar-pro"
  },
  "secureData": {
    "pin": "обфусцированное_значение",
    "apiKeyPerplexity": "обфусцированное_значение"
  }
}
```

### ⚠️ Система кэширования данных

**Назначение**: Оптимизация работы с внешними API через кэширование данных с временными ограничениями.

**Реализация**:
- **Иконки монет**: `ui/api/coingecko.js` - метод `cacheCoinsIcons()`
- **Метрики рынка**: `ui/interaction/footer.js` - метод `fetchMarketIndices()`

**Принципы работы**:

1. **Кэширование иконок монет**:
   - Ключи localStorage: `cgIconsCache` (объект с URL иконок), `cgIconsCacheTimestamp` (время последнего обновления)
   - Интервал обновления: не чаще 1 раза в час (60 минут)
   - Логика: обновление только если прошло больше часа с последнего обновления
   - Хранение: объект `{coinId: iconUrl}` в localStorage

2. **Кэширование метрик рынка**:
   - Ключи localStorage: `marketMetricsCache` (объект с метриками), `marketMetricsCacheTimestamp` (время последнего обновления)
   - Интервал обновления: не чаще 1 раза в час (60 минут)
   - Фильтрация символов анимации: символы `|`, `/`, `-`, `\` заменяются на `"—"` перед сохранением в кэш
   - Валидация: кэшируются только успешно загруженные метрики с реальными значениями (не `"—"`, не `null`, не `undefined`)
   - Логика загрузки: если в кэше есть неопределенные метрики (`"—"`), они продолжают загружаться из API с показом анимации

3. **Правила кэширования**:
   - Пустые значения не кэшируются
   - Символы анимации фильтруются перед сохранением
   - При повреждении кэша (ошибка парсинга) - кэш удаляется и данные загружаются заново
   - При первом запуске (когда кэша нет) - данные загружаются сразу

**Текущие кэшируемые данные**:
- Иконки монет CoinGecko (`cgIconsCache`)
- Метрики рынка: FGI, VIX, BTC Dominance, Open Interest, Funding Rate, Long/Short Ratio (`marketMetricsCache`)

### ⚠️ Адаптивный таймаут для обработки rate limiting API

**Назначение**: Автоматическая адаптация задержек между запросами к внешним API для предотвращения блокировки из-за rate limiting (превышения лимита запросов).

**Реализация**: `ui/api/coingecko.js` - методы `increaseAdaptiveTimeout()`, `decreaseAdaptiveTimeout()`, `resetAdaptiveTimeout()`

**Принципы работы**:

1. **Базовые параметры**:
   - Базовое значение таймаута: `300ms` (`adaptiveTimeoutBase`)
   - Максимальное значение таймаута: `10000ms` (10 секунд) (`adaptiveTimeoutMax`)
   - Текущий таймаут: `adaptiveTimeout` (начинается с базового значения)

2. **Увеличение таймаута при ошибках**:
   - При получении HTTP 429 (Too Many Requests) таймаут удваивается
   - Формула: `adaptiveTimeout = min(adaptiveTimeout * 2, adaptiveTimeoutMax)`
   - Логирование увеличения для отладки

3. **Уменьшение таймаута при успешных запросах**:
   - При успешных запросах и если прошло более 5 секунд без ошибок - таймаут уменьшается на 20%
   - Формула: `adaptiveTimeout = max(adaptiveTimeout * 0.8, adaptiveTimeoutBase)`
   - Постепенное восстановление до базового значения при стабильной работе

4. **Сброс таймаута**:
   - При начале нового процесса (например, добавления монет списком) таймаут сбрасывается к базовому значению
   - Метод `resetAdaptiveTimeout()` устанавливает `adaptiveTimeout = adaptiveTimeoutBase`

5. **Применение**:
   - Таймаут применяется во всех местах, где выполняются запросы к CoinGecko API
   - Используется как задержка между последовательными запросами в очереди добавления монет
   - Задержка между повторными попытками неудачных тикеров также использует адаптивный таймаут

**Обработка ошибок**:
- Все методы API (`fetchCoinGecko()`, `getCoinIdBySymbol()`, `searchCoins()`, `archiveFailedTicker()`) проверяют статус ответа
- При получении 429 ошибки вызывается `increaseAdaptiveTimeout()` перед повторной попыткой
- При успешных запросах вызывается `decreaseAdaptiveTimeout()` для постепенного восстановления

**Цель**: Автоматическое предотвращение блокировки API при массовых операциях (например, добавление большого списка монет), обеспечение стабильной работы при различных нагрузках.

### ⚠️ Хранилище избранного и работа с таблицей монет

**Назначение**: Избранное - это хранилище избранных монет (любого избранного, но пока только монеты). Монета может одновременно присутствовать в таблице и в избранном. Избранное не удаляется при добавлении монеты в таблицу.

**Реализация**: `ui/api/coingecko.js` - методы `syncCoinWithFavorites()`, `syncAllCoinsWithFavorites()`, `addFavoriteToTableById()`

**Принципы работы**:

1. **Хранилище избранного**: Избранное (`cgFavoriteCoins`) - это хранилище избранного. Монета может быть одновременно в таблице и в избранном.

2. **Метод `syncCoinWithFavorites(coinId, action)`**:
   - `action === 'add'`: При добавлении монеты в таблицу - НЕ удаляет её из избранного (избранное - хранилище)
   - `action === 'remove'`: При удалении монеты из таблицы - удаляет её из таблицы, но добавляет в избранное (если ещё нет)

3. **Метод `syncAllCoinsWithFavorites()`**:
   - НЕ удаляет из избранного монеты, которые есть в таблице (избранное - хранилище)
   - Вызывается при монтировании компонента (`mounted()`)

4. **Методы работы с избранным**:
   - `addFavoriteToTableById(coinId)` - добавление монеты из избранного в таблицу. Если монета уже в таблице - просто закрывает dropdown (отметка показывается в UI)
   - `toggleFavorite(coinId)` - переключение статуса избранного (добавление/удаление из избранного)
   - `isFavorite(coinId)` - проверка, является ли монета избранной

5. **Восстановление автоматически добавленных монет (failed-{ticker})**:
   - Монеты с ID `failed-{ticker}` при добавлении в таблицу автоматически находят реальный CoinGecko ID по тикеру
   - Если монета не найдена или попытка добавления не удалась - монета остается в избранном с оригинальным ID
   - При успешном добавлении проверяется наличие монеты в таблице, при ошибке - откат изменений

6. **Миграция данных**:
   - При загрузке приложения проверяются оба ключа: `cgArchivedCoins` (старый) и `cgFavoriteCoins` (новый)
   - Если есть старый ключ, но нет нового - данные мигрируются в новый ключ
   - Старый ключ `cgFavoriteCoinIds` также мигрируется в `cgFavoriteCoins` при первом запуске

**Цель**: Обеспечение единого хранилища избранного, возможность одновременного присутствия монеты в таблице и избранном, удобное управление избранными монетами.

### ⚠️ Отслеживание согласованности архитектурных правил

**ОБЯЗАТЕЛЬНО**: ИИ-агент должен поддерживать согласованность между `.cursorrules`, `architect.md` и `ui/guide-ii.md`:

1. **Архитектурные правила** (принципы разработки, стандарты, технические ограничения, обратная совместимость данных) хранятся в `architect.md`
2. **Правила UI/UX** (оформление, паттерны взаимодействий) хранятся в `ui/guide-ii.md`
3. **Правила поведения ИИ-агента** (работа с Git, протоколирование, синхронизация настроек) остаются в `.cursorrules`
4. **Ссылки на правила**: В `.cursorrules` и `architect.md` важные правила представлены как ссылки на соответствующие разделы в других документах
5. **При обновлении правил**: Если изменяется правило в одном документе, проверить, что ссылки в других документах актуальны и указывают на правильные разделы
6. **При добавлении новых правил**: Добавлять их в соответствующий документ (UI/UX → `ui/guide-ii.md`, архитектура → `architect.md`), а в других документах оставлять ссылку на соответствующий раздел

**Цель**: Разделение ответственности:
- `architect.md` содержит архитектурные решения проекта и принципы математической модели
- `ui/guide-ii.md` содержит принципы интерфейса и паттерны взаимодействий
- `.cursorrules` содержит правила работы ИИ-агента с ссылками на архитектуру и UI/UX

Структура проекта
```
Root/
├── index.html          # Главный HTML файл
├── .git/              # Git репозиторий
├── .vscode/           # Настройки VS Code (для совместимости с Cursor)
│   ├── settings.json  # Настройки проекта (синхронизируются с Cursor)
│   ├── extensions.json # Рекомендуемые расширения
│   ├── cspell-dict.txt # Пользовательский словарь для проверки орфографии
│   └── README.md      # Документация по настройкам
├── history/           # Логи чата
│   └── YYYY/          # Папки по годам
│       └── MM-DD.txt  # Дневные логи (например: 12-09.txt)
├── core/              # Ядро приложения
│   ├── cfg-app.js     # Конфиг приложения
│   └── security/      # Безопасность
│       └── u-sec-obfuscate.js
├── ui/                # UI компоненты
│   ├── api/           # Компоненты для работы с API
│   │   ├── import-export.js
│   │   ├── perplexity.js
│   │   └── coingecko.js
│   ├── interaction/   # Компоненты взаимодействия
│   │   ├── splash.js
│   │   ├── theme.js
│   │   ├── chat.js
│   │   ├── header.js
│   │   └── footer.js
│   ├── styles/        # Стили компонентов
│   │   ├── header.css
│   │   ├── footer.css
│   │   ├── splash.css
│   │   ├── dropdown.css
│   │   ├── layout.css
│   │   ├── chat.css
│   │   ├── theme-colors.css
│   │   ├── z-index.css
│   │   └── icons.css
│   ├── config/        # Конфигурационные файлы
│   │   └── ui-element-mapping.json
│   ├── components/    # Переиспользуемые компоненты
│   │   ├── header-coins.js
│   │   ├── sortable-header.js
│   │   ├── table-coin-row.js
│   │   ├── cell-num.js
│   │   ├── cell-row-select.js
│   │   ├── cell-coin.js
│   │   ├── header-cell.js
│   │   ├── header-cell-check.js
│   │   ├── table-data.js
│   │   └── menu-item.js
│   ├── utils/         # Утилиты
│   │   ├── table-sort-mixin.js
│   │   ├── column-visibility-mixin.js
│   │   ├── pluralize.js
│   │   ├── ui-element-helper.js
│   │   └── hash-generator.js
│   └── guide-ii.md    # Руководство по интерфейсу и взаимодействию
├── app/               # Точка входа приложения
│   └── app-ui-root.js
├── architect.md       # Архитектурный план (этот файл)
├── .cursorrules       # Правила работы ИИ-агента


```
