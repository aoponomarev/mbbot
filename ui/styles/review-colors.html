<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Каталог цветов проекта</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <!-- Material Symbols (Sharp): для иконок collapse в карточках -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Sharp:opsz,wght,FILL,GRAD@20..48,400,0,0" />
    <!-- Единые стили для всех review -->
    <link rel="stylesheet" href="../../ui/review-styles.css">
    <!-- Общие стили приложения (нужны для единого компонента сообщений) -->
    <link rel="stylesheet" href="../../ui/styles/layout.css">
    <!-- Стили иконок (нужны для одинакового вида иконок сообщений) -->
    <link rel="stylesheet" href="../../ui/styles/icons.css">
    <!-- Единый менеджер для всех review (хедер с вкладками) - загружаем в head для ранней инициализации -->
    <script src="../../ui/review-manager.js"></script>
</head>
<body>
    <!-- Хедер с вкладками будет вставлен здесь через review-manager.js -->
    
    <div id="app" class="container-fluid">
        <!-- Фильтры -->
        <div class="filter-controls">
            <div class="row g-3">
                <div class="col-md-3">
                    <label class="form-label">Категория</label>
                    <select class="form-select form-select-sm" id="filter-category">
                        <option value="">Все категории</option>
                        <option value="bootstrap">Bootstrap</option>
                        <option value="danger">Danger</option>
                        <option value="success">Success</option>
                        <option value="theme">Theme</option>
                        <option value="ui">UI элементы</option>
                        <option value="header">Header</option>
                        <option value="dropdown">Dropdown</option>
                        <option value="other">Other</option>
                    </select>
                </div>
                <div class="col-md-9">
                    <label class="form-label">Поиск</label>
                    <input type="text" class="form-control form-control-sm" id="filter-search" placeholder="Поиск по имени переменной, использованию, файлу...">
                </div>
            </div>
        </div>

        <!-- Контейнер для таблиц по секциям -->
        <div id="colors-container"></div>
    </div>

    <!-- Подключаем CSS файлы для получения переменных -->
    <link rel="stylesheet" href="../../ui/styles/theme-colors.css">
    <link rel="stylesheet" href="../../ui/styles/layout.css">
    <link rel="stylesheet" href="../../ui/styles/dropdown.css">
    <link rel="stylesheet" href="../../ui/styles/icons.css">
    <link rel="stylesheet" href="../../ui/styles/header.css">
    <link rel="stylesheet" href="../../ui/styles/splash.css">
    <link rel="stylesheet" href="../../ui/styles/z-index.css">
    
    <script>
        // Каталог цветов строится автоматически через ReviewDataPipeline.scanColors()
        // (fallback FS/GitHub/DepGraph + кэш). Статическая часть сведена к минимуму.

        const categoryNames = {
            'bootstrap': 'Bootstrap',
            'danger': 'Danger',
            'success': 'Success',
            'theme': 'Theme',
            'ui': 'UI элементы',
            'header': 'Header',
            'dropdown': 'Dropdown',
            'other': 'Other'
        };

        // Получает цвет из CSS переменной (реальное значение в текущем контексте страницы)
        function getColorValue(varName) {
            const root = document.documentElement;
            const value = getComputedStyle(root).getPropertyValue(varName).trim();
            return value || null;
        }

        // Парсит HSL строку
        function parseHSL(hslString) {
            if (!hslString) return null;
            const match = hslString.match(/hsla?\((\d+),\s*(\d+(?:\.\d+)?)%,\s*(\d+(?:\.\d+)?)%(?:,\s*([\d.]+))?\)/);
            if (match) {
                return {
                    h: parseInt(match[1]),
                    s: parseFloat(match[2]),
                    l: parseFloat(match[3]),
                    a: match[4] ? parseFloat(match[4]) : 1
                };
            }
            return null;
        }

        // Конвертирует HSL в RGB для отображения
        function hslToRgb(h, s, l) {
            h = h / 360;
            s = s / 100;
            l = l / 100;
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function getColorForPreview(color) {
            const cssValue = getColorValue(color.identifier);
            if (cssValue) return cssValue;
            if (color.rawValue) return color.rawValue;
            return '#ccc';
        }

        function renderColorPreview(color) {
            const cell = document.createElement('td');
            cell.className = 'color-preview-cell';
            const preview = document.createElement('div');
            preview.className = 'color-preview';
            preview.style.backgroundColor = getColorForPreview(color);
            cell.appendChild(preview);
            return cell;
        }

        function renderIdentifierCell(color) {
            const cell = document.createElement('td');
            cell.className = 'identifier-cell';
            const code = document.createElement('code');
            code.textContent = color.identifier;
            cell.appendChild(code);
            return cell;
        }

        function renderValueCell(color, type) {
            const cell = document.createElement('td');
            cell.className = 'value-cell';
            const cssValue = getColorValue(color.identifier);
            
            let value = cssValue || color.rawValue || '—';
            if (type === 'rgb' && cssValue?.includes('hsl')) {
                const hsl = parseHSL(cssValue);
                if (hsl) {
                    const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
                    value = `rgb(${rgb.join(', ')})`;
                }
            }
            if (type === 'hsl' && cssValue?.includes('rgb')) {
                // если значение rgb — оставляем как есть, не конвертируем в hsl (не требуется для review)
                value = cssValue;
            }
            
            const code = document.createElement('code');
            code.textContent = value;
            cell.appendChild(code);
            return cell;
        }

        function renderUsageCell(color) {
            const cell = document.createElement('td');
            cell.className = 'usage-cell';
            const usage = Array.isArray(color.usage) ? color.usage : [];
            if (usage.length === 0) return cell;

            if (usage.length > 1) {
                const select = document.createElement('select');
                select.className = 'form-select form-select-sm';
                select.style.width = 'auto';
                select.style.display = 'inline-block';
                select.style.minWidth = '150px';
                select.style.fontSize = '0.85rem';
                usage.forEach(u => {
                    const option = document.createElement('option');
                    option.value = u;
                    option.textContent = u;
                    select.appendChild(option);
                });
                cell.appendChild(select);
            } else {
                const span = document.createElement('span');
                span.textContent = usage[0];
                span.style.fontSize = '0.85rem';
                cell.appendChild(span);
            }
            return cell;
        }

        function renderTableRow(color) {
            const row = document.createElement('tr');
            row.appendChild(renderIdentifierCell(color));
            row.appendChild(renderColorPreview(color));
            row.appendChild(renderValueCell(color, 'hsl'));
            row.appendChild(renderValueCell(color, 'rgb'));
            row.appendChild(renderUsageCell(color));
            return row;
        }

        function groupColorsByCategory(colors) {
            const grouped = {};
            colors.forEach(color => {
                const category = color.category || 'other';
                if (!grouped[category]) grouped[category] = [];
                grouped[category].push(color);
            });
            return grouped;
        }

        function renderSectionTable(category, colors, container) {
            if (colors.length === 0) return;
            
            const table = document.createElement('table');
            table.className = 'table table-sm review-table table-colors';
            
            const headerRow = document.createElement('tr');
            headerRow.className = 'section-header';
            const headerCell = document.createElement('td');
            headerCell.colSpan = 5;
            headerCell.textContent = categoryNames[category] || category;
            headerRow.appendChild(headerCell);
            
            const thead = document.createElement('thead');
            const headerTr = document.createElement('tr');
            const headers = [
                { text: 'Идентификатор', col: 'identifier', sortable: true },
                { text: 'Цвет', col: 'color', sortable: false },
                { text: 'HSL', col: 'hsl', sortable: false },
                { text: 'RGB', col: 'rgb', sortable: false },
                { text: 'Использование', col: 'usage', sortable: false }
            ];
            
            headers.forEach(h => {
                const th = document.createElement('th');
                th.textContent = h.text;
                if (h.col === 'color') th.className = 'color-header';
                headerTr.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            thead.appendChild(headerTr);
            
            const tbody = document.createElement('tbody');
            colors.forEach(color => tbody.appendChild(renderTableRow(color)));
            
            table.appendChild(thead);
            table.appendChild(tbody);
            container.appendChild(table);
        }

        function renderTables(colors) {
            const container = document.getElementById('colors-container');
            container.innerHTML = '';

            if (!colors || colors.length === 0) {
                container.innerHTML = '<p class="text-center text-muted">Цвета не найдены</p>';
                return;
            }

            const grouped = groupColorsByCategory(colors);
            const categoryOrder = ['bootstrap', 'danger', 'success', 'theme', 'ui', 'header', 'dropdown', 'other'];
            categoryOrder.forEach(category => {
                if (grouped[category]) renderSectionTable(category, grouped[category], container);
            });
        }

        // Фильтрация
        let allColors = [];
        function applyFilters() {
            const categoryFilter = document.getElementById('filter-category').value;
            const searchFilter = document.getElementById('filter-search').value.toLowerCase();

            let filtered = allColors;
            if (categoryFilter) filtered = filtered.filter(c => c.category === categoryFilter);

            if (searchFilter) {
                filtered = filtered.filter(c => {
                    const searchText = (
                        c.identifier + ' ' +
                        (c.rawValue || '') + ' ' +
                        (c.usage?.join(' ') || '') + ' ' +
                        (c.file || '')
                    ).toLowerCase();
                    return searchText.includes(searchFilter);
                });
            }

            renderTables(filtered);
        }

        async function loadAllColors() {
            const pipeline = window.ReviewManager?.ReviewDataPipeline;
            if (!pipeline?.scanColors) return [];
            const res = await pipeline.scanColors();
            const raw = res?.colors || [];
            // Нормализуем в формат, ожидаемый UI
            return raw.map(c => ({
                category: c.category || 'other',
                identifier: c.identifier,
                rawValue: c.rawValue || null,
                usage: Array.isArray(c.usageFiles) ? c.usageFiles : [],
                file: c.file || ''
            }));
        }

        document.addEventListener('DOMContentLoaded', async function() {
            try {
                allColors = await loadAllColors();
            renderTables(allColors);
            } catch (e) {
                console.error(e);
                window.ReviewManager?.ReviewSystemMessages?.post?.('colors.error', {
                    id: 'colors-load',
                    details: String(e?.message || e)
                });
            }

            document.getElementById('filter-category').addEventListener('change', applyFilters);
            document.getElementById('filter-search').addEventListener('input', applyFilters);
        });
    </script>

    <!-- Bootstrap JS (нужен для collapse в карточках review) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

