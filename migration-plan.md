# План миграции математической модели

> **ВАЖНО**: Этот документ описывает процесс миграции математической модели из старого приложения (`old_app_not_write/`) в новое приложение. Документ обновляется по мере прогресса миграции.

> **Связь с правилами**: См. раздел "Работа с папкой old_app_not_write" в `.cursorrules` и раздел "Проблемы миграции" в `architect.md`.

## Текущий статус миграции

**Дата начала**: 2025-12-11  
**Текущий этап**: Этап 4 - CMD (Composite Market Delta)  
**Прогресс**: ✅ Этап 1 (PV) - Завершено | ✅ Этап 2 (CPT) - Завершено | ✅ Этап 3 (CD) - Завершено

## Обзор математической модели

### Иерархия метрик (от исходных данных к финальным индексам)

```
PV (Price Variations) [1h, 24h, 7d, 14d, 30d, 200d]
  ↓
PRC Weights (Proximity Relevance Coefficients)
  ↓
┌─────────────────┬─────────────────┬─────────────────┐
│                 │                 │                 │
CPT              CD                CGR
(Coin Potential) (Cumulative Delta) (Coin Gradient)
│                 │                 │
│                 ↓                 │
│              CDH                 │
│         (CD на горизонте)        │
│                 │                 │
│                 ↓                 │
│              CMD                 │
│    (Composite Market Delta)      │
│                 │                 │
└─────────────────┼─────────────────┴─────────────────┘
                  │
                  ↓
                DIN
         (Divergence Index)
                  │
                  ↓
                AGR
      (Aggregated Score - A.I.R.)
                  │
                  ↓
                MDN
    (Market Direction Now)
```

### Ключевые зависимости

1. **Исходные данные**: PV (Price Variations) - массив из 6 элементов
2. **Базовые производные**: PRC Weights, PV1h Clip, CPT, CD, CDH
3. **Рыночные производные**: CMD (медианный фон рынка)
4. **Индивидуальные производные**: CGR, DIN
5. **Агрегированные метрики**: AGR, MDN

### Важные изменения интервалов

**Старое приложение**: `[1h, 24h, 7d, 30d, 60d, 90d]`  
**Новое приложение**: `[1h, 24h, 7d, 14d, 30d, 200d]`

**Изменения**:
- `pvs[3]`: было 30d → стало 14d (НОВЫЙ интервал)
- `pvs[4]`: было 60d → стало 30d (сдвинут с индекса 3)
- `pvs[5]`: было 90d → стало 200d (НОВЫЙ интервал, заменяет 60d и 90d)

**⚠️ ВАЖНО**: Замененные интервалы потребуют анализа и пересмотра весов и коэффициентов в математической модели (см. предостережение в `.cursorrules`).

## Пошаговый план миграции

### Этап 0.1: Декомпозиция компонента менеджера монет (ui/api/coins-manager.js) ✅ ЗАВЕРШЕНО

**Цель**: Вынести крупные функциональные блоки из компонента в отдельные модули для улучшения поддерживаемости и читаемости кода

**Статус**: ✅ **ЗАВЕРШЕНО** - Вынесены блоки 1, 2, 3. Блок 4 пропущен (методы остаются в компоненте).

**Анализ блоков для декомпозиции**:
1. **Блок 1: Методы работы с CD** (~158 строк, строки 612-770)
   - Методы: `getCDH()`, `getCDHRaw()`, `getCD()`, `getCDRaw()`, `getCDValue()`, `getCDTooltip()`, `cgFormatCD()`, `getCDField()`
   - Зависимости: Используется в методах форматирования колонок (`getColumnFormatProps`)
   - Файл: `ui/utils/coins-cd-helpers.js`

2. **Блок 2: Конфигурация колонок таблицы** (~197 строк, строки 217-414)
   - Данные: `tableColumns` - статический объект конфигурации
   - Зависимости: Используется в computed properties (`staticColumns`, `dynamicColumns`, `allColumns`)
   - Файл: `ui/config/table-columns-config.js`

3. ✅ **Блок 3: Методы работы с избранным** (~460 строк, строки 1790-2250)
   - Методы: `isFavorite()`, `toggleFavorite()`, `removeFavoriteFromFavorites()`, `getFavoriteCoinName()`, `getFavoriteCoinSymbol()`, `getFavoriteCoinId()`, `getFavoriteCoinIcon()`, `isFailedFavoriteCoin()`, `archiveFailedTicker()`
   - Зависимости: Использует `window.coinGeckoAPI.searchCoins()` для `archiveFailedTicker()`
   - Файл: `ui/utils/coins-favorites-helpers.js`
   - **Статус**: ✅ Завершено

4. ⏭️ **Блок 4: Методы работы с поиском и тикерами** (~403 строки, строки 1168-1571)
   - Методы: `parseTickersFromString()`, `isParseMode()`, `getCoinIdBySymbol()`, `parseAndAddTickers()`, `stopAddingTickers()`, `processTickersQueue()`, `updateDisplayPendingTickers()`, `searchCoins()`
   - Зависимости: Тесно связаны с состоянием компонента и логикой обработки
   - Файл: **НЕ СОЗДАН** - методы остаются в компоненте
   - **Статус**: ⏭️ Пропущен - методы остаются в компоненте для сохранения связности логики

**Порядок выноса** (с учетом зависимостей):
1. ✅ **Блок 1 (CD методы)** - наименее зависимый, используется только для форматирования
2. ✅ **Блок 2 (конфигурация колонок)** - статический объект, используется в computed
3. ✅ **Блок 3 (избранное)** - методы работы с избранным, `archiveFailedTicker` вынесен в этот блок
4. ⏭️ **Блок 4 (поиск и тикеры)** - **ПРОПУЩЕН**: методы остаются в компоненте, так как тесно связаны с логикой компонента и состоянием

**ВАЖНО - Решение циклической зависимости**:
- `archiveFailedTicker` был вынесен в блок 3 (методы работы с избранным), так как он по сути работает с избранным
- Блок 3 использует `getCoinIdBySymbol()` из компонента (не из блока 4), что решает зависимость
- Блок 4 не выносится, методы остаются в компоненте для сохранения связности логики

**Шаги для каждого блока**:
1. Создать файл утилиты с функциями
2. Экспортировать функции через `window.coins*Helpers.*` (отдельные объекты для каждого блока)
3. Обновить `ui/api/coins-manager.js` для использования утилит (заменить методы на вызовы утилит)
4. Подключить новый файл в `index.html` перед `ui/api/coins-manager.js`
5. Протестировать работоспособность (проверить консоль, функциональность)
6. Обновить документацию (`architect.md` - структура проекта)

**Детали по каждому блоку**:

**Блок 1 (CD методы)**:
- Функции принимают `coin` объект и возвращают значения
- Не требуют доступа к `this` компонента
- Экспорт: `window.coinsCDHelpers = { getCDH, getCDHRaw, getCD, getCDRaw, getCDValue, getCDTooltip, formatCD, getCDField }`

**Блок 2 (конфигурация колонок)**:
- Статический объект конфигурации
- Экспорт: `window.tableColumnsConfig = { tableColumns }`
- Используется в `data()` компонента

**Блок 3 (избранное)**:
- Функции работают с `cgFavoriteCoins` (передается как параметр)
- `archiveFailedTicker` вынесен в этот блок (использует методы избранного)
- Экспорт: `window.coinsFavoritesHelpers = { isFavorite, toggleFavorite, removeFavoriteFromFavorites, addFavoriteToTableById, getFavoriteCoinName, getFavoriteCoinSymbol, getFavoriteCoinId, getFavoriteCoinIcon, isFailedFavoriteCoin, archiveFailedTicker }`

**Блок 4 (поиск и тикеры)** - ⏭️ ПРОПУЩЕН:
- Методы остаются в компоненте, так как тесно связаны с состоянием и логикой компонента
- `archiveFailedTicker` вынесен в блок 3
- Методы `parseTickersFromString()`, `isParseMode()`, `getCoinIdBySymbol()`, `searchCoins()` и другие остаются в `ui/api/coins-manager.js`

**Проверка**:
- После каждого блока: проверить работоспособность приложения
- Проверить консоль на ошибки
- Проверить функциональность, связанную с вынесенным блоком

**Статус**: ✅ **ЗАВЕРШЕНО** - Вынесены блоки 1, 2, 3. Блок 4 пропущен (методы остаются в компоненте).

---

### Этап 0: Подготовка данных ✅ ЗАВЕРШЕНО

**Цель**: Обеспечить преемственность переменных и структуры данных

**Шаги**:
1. ✅ Создать функцию `transformCoinGeckoToPV()` для трансформации данных CoinGecko
2. ✅ Применить трансформацию во всех местах получения данных от CoinGecko API
3. ✅ Обеспечить обратную совместимость при загрузке из localStorage

**Проверка**:
- Открыть DevTools → Console
- Проверить объект монеты: должен содержать `pvs`, `PV1h`, `PV24h`, `PV7d`, `PV14d`, `PV30d`, `PV200d`
- Проверить массив `pvs`: должен содержать 6 элементов (числа)

**Следующий элемент интерфейса для проверки**: Таблица монет должна отображать данные без ошибок

---

### Этап 1: Утилиты и базовые функции ✅ ЗАВЕРШЕНО

**Цель**: Мигрировать базовые математические утилиты и функции расчета PRC-весов

**Шаги**:
1. ✅ Создать файл `mm/median/utils/math-helpers.js` с утилитами:
   - `clamp(x, min, max)` - ограничение значения в диапазоне
   - `safeNumber(x, def)` - безопасное преобразование в число
   - `tanh(x)` - гиперболический тангенс
   - `median(arr)` - вычисление медианы массива
2. ✅ Создать файл `mm/median/core/prc-weights.js`:
   - Функция `computePRCWeights(hDays)` - расчет PRC-весов
   - Обновить `timeFramesDays` для новых интервалов: `[1/24, 1, 7, 14, 30, 200]`
   - Экспортировать через `window.mmMedianPRCWeights`
3. Создать файл `mm/median/core/pv1h-clip.js`:
   - Функция `computePV1hClipThreshold(coins)` - расчет порога клиппинга
   - Функция `smoothPV1h(pv1h)` - сглаживание PV1h
   - Экспортировать через `window.mmMedianPV1hClip`

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmMedianPRCWeights.computePRCWeights(7)` - должен вернуть массив из 6 весов
- Проверить, что сумма весов ≈ 1.0
- Вызвать `window.mmMedianPV1hClip.computePV1hClipThreshold([...])` - должен вернуть число

**Следующий элемент интерфейса для проверки**: Добавить отладочную панель с отображением PRC-весов для текущего горизонта прогноза

---

### Этап 2: CPT (Coin Potential) ✅ ЗАВЕРШЕНО

**Цель**: Мигрировать расчет потенциала монеты

**Шаги**:
1. ✅ Создать файл `mm/median/metrics/cpt.js`:
   - Функция `computeEnhancedCPT(values, hDays)` - расчет CPT
   - Функция `formatEnhancedCPT(value)` - форматирование CPT
   - **ВАЖНО**: Адаптировать базовые веса `baseW` для новых интервалов (14d, 200d вместо 60d, 90d)
   - Экспортировать через `window.mmMedianCPT`
2. ✅ Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateCPT()` в `ui/api/coins-manager.js`
   - Вызывать при обновлении данных монет (fetchCoinGecko, addTopCoinsByMarketCap, addTopCoinsByVolume)
   - Вызывать при загрузке из localStorage (если CPT еще не рассчитан)
   - Сохранять результат в `coin.enhancedCpt` и `coin.enhancedCptFormatted`

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmMedianCPT.computeEnhancedCPT([1, 2, 3, 4, 5, 6], 7)` - должен вернуть число
- Проверить объект монеты: должен содержать `enhancedCpt` и `enhancedCptFormatted`

**Следующий элемент интерфейса для проверки**: Добавить колонку "CPT" в таблицу монет с отображением `enhancedCptFormatted`

---

### Этап 3: CD (Cumulative Delta) ✅ Завершено

**Цель**: Мигрировать расчет накопительной дельты

**Шаги**:
1. ✅ Создать файл `mm/median/metrics/cd.js`:
   - ✅ Функция `calculateCDsWeighted(pvs, prcWeights)` - расчет CD (сырых и взвешенных)
     - Вычисляет накопительную сумму PV для каждого временного узла
     - Возвращает `{cdRaw: [...], cdW: [...]}` - массивы из 6 элементов
     - CD для новых интервалов (14d, 200d) вычисляются из реальных PV, без эмуляции старых интервалов
   - ✅ Функция `approximateCDHFromSeries(series, hDays)` - аппроксимация CDH
     - **ВАЖНО**: Интерполяция между двумя соседними CD значениями в зависимости от `hDays`
     - Адаптирована под новые временные узлы `[1/24, 1, 7, 14, 30, 200]`
     - Находит два соседних временных узла, между которыми находится `hDays`, и интерполирует между соответствующими CD
     - Примеры:
       * `hDays = 10 дней`: интерполяция между CD7 (индекс 2) и CD14 (индекс 3)
       * `hDays = 20 дней`: интерполяция между CD14 (индекс 3) и CD30 (индекс 4)
       * `hDays = 100 дней`: интерполяция между CD30 (индекс 4) и CD200 (индекс 5)
   - ✅ Экспортировать через `window.mmMedianCD`
2. ✅ Интегрировать в компонент CoinGecko:
   - ✅ Добавить метод `calculateCD()` в `ui/api/coins-manager.js`
   - ✅ Вызывать после расчета CPT в `fetchCoinGecko()`, `addCoinsFromSearch()`, `addCoinsFromFavorites()`
   - ✅ Обновить заглушки `getCDH()`, `getCD()`, `getCDValue()` для использования реальных данных
   - Сохранять результаты:
     - `coin.cd1`..`coin.cd6` (сырые CD)
     - `coin.cd1w`..`coin.cd6w` (взвешенные CD)
     - `coin.cdh` (CDH сырое)
     - `coin.cdhw` (CDH взвешенное)

**Проверка**:
- ✅ Открыть DevTools → Console
- ✅ Вызвать `window.mmMedianCD.calculateCDsWeighted([1, 2, 3, 4, 5, 6], [0.1, 0.2, 0.3, 0.2, 0.15, 0.05])`
- ✅ Вызвать `window.mmMedianCD.approximateCDHFromSeries([1, 2, 3, 4, 5, 6], 10)` - должен вернуть интерполированное значение между 3 и 4
- ✅ Проверить объект монеты: должен содержать `cd1`..`cd6`, `cd1w`..`cd6w`, `cdh`, `cdhw`
   - Проверено: CD рассчитан для всех 77 монет
   - Пример: BTC - CD1: -0.13, CD1w: -0.02, CD6: -28.74, CD6w: -2.83, CDH: -1.26, CDHw: -0.54

**Следующий элемент интерфейса для проверки**: Добавить колонки "CD1".."CD6" и "CDH" в таблицу монет (опционально, для визуальной проверки)

**Статус**: ✅ **ЗАВЕРШЕНО** - Все функции реализованы, протестированы и работают корректно. CD рассчитывается для всех 77 монет при загрузке данных. Проверено на примере BTC: CD1: -0.13, CD1w: -0.02, CD6: -28.74, CD6w: -2.83, CDH: -1.26, CDHw: -0.54

---

### Этап 4: CMD (Composite Market Delta)

**Цель**: Мигрировать расчет медианного фона рынка

**Шаги**:
1. Создать файл `mm/median/metrics/cmd.js`:
   - Функция `computeMDVectors(allCoins)` - расчет медианных PV по каждому временному узлу
   - Функция `computeCMDLevels(md, prcWeights)` - расчет уровней CMD
   - Экспортировать через `window.mmMedianCMD`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateCMD()` в `ui/api/coins-manager.js`
   - Вызывать после расчета CD для всех монет
   - Сохранять результат в `window.__CMDH__` (для использования в AGR)

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmMedianCMD.computeMDVectors([...])` с массивом монет
- Должен вернуть массив из 6 медианных PV
- Проверить `window.__CMDH__` - должно быть число (CDH от медианных PV)

**Следующий элемент интерфейса для проверки**: Добавить инфобокс с отображением CMD (медианный фон рынка)

---

### Этап 5: CGR (Coin Gradient)

**Цель**: Мигрировать расчет градиента монеты

**Шаги**:
1. Создать файл `mm/median/metrics/cgr.js`:
   - Функция `computeCGR(values, hDays)` - расчет CGR (углы и наклоны)
   - Функция `computeWeightedCGR(angles, slopes, hDays)` - агрегация CGR2..CGR6
   - **ВАЖНО**: Адаптировать индексы для новых интервалов (pvs[3] теперь 14d, pvs[4] - 30d, pvs[5] - 200d)
   - Экспортировать через `window.mmMedianCGR`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateCGR()` в `ui/api/coins-manager.js`
   - Вызывать после расчета CD
   - Сохранять результаты:
     - `coin.cgr2`..`coin.cgr6` (градусы)
     - `coin.cgrDeg` (агрегированные градусы)
     - `coin.cgrSlope` (агрегированный наклон)

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmMedianCGR.computeCGR([1, 2, 3, 4, 5, 6], 7)`
- Должен вернуть объект `{angles: [...], slopes: [...]}` с массивами из 5 элементов
- Проверить объект монеты: должен содержать `cgr2`..`cgr6`, `cgrDeg`, `cgrSlope`

**Следующий элемент интерфейса для проверки**: Добавить колонки "CGR2".."CGR6" и "CGR" в таблицу монет

---

### Этап 6: DIN (Divergence Index)

**Цель**: Мигрировать расчет индекса дивергенции

**Шаги**:
1. Создать файл `mm/median/metrics/din.js`:
   - Функция `calculateSimpleCorrelation(pvs1, pvs2)` - упрощенная корреляция по знакам
   - Функция `computeDivergenceIndices(allCoins, horizonDays, marketIndicators)` - расчет DIN для всех монет
   - **ВАЖНО**: Использовать рыночные индикаторы из `core/api/market-metrics.js`
   - Экспортировать через `window.mmMedianDIN`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateDIN()` в `ui/api/coins-manager.js`
   - Вызывать после расчета CMD и CGR
   - Сохранять результаты:
     - `coin.divergenceIndex` (сырой индекс)
     - `coin.divergenceAbs` (абсолютное значение для рейтингов)
     - `coin.btcCorrelation` (корреляция с BTC, если применимо)

**Проверка**:
- Открыть DevTools → Console
- Проверить, что рыночные индикаторы доступны (FGI, VIX, BTC Dom, OI, FR, LSR)
- Вызвать `window.mmMedianDIN.computeDivergenceIndices([...], 7, {...})`
- Проверить объект монеты: должен содержать `divergenceIndex`, `divergenceAbs`

**Следующий элемент интерфейса для проверки**: Добавить колонку "DIN" в таблицу монет

---

### Этап 7: AGR (Aggregated Score)

**Цель**: Мигрировать расчет комплексного скора монеты

**Шаги**:
1. Создать файл `mm/median/metrics/agr.js`:
   - Функция `calculateAGR(coin, CMD, medianDIN)` - базовый расчет AGR (A.I.R. модель)
   - Функция `formatAGRForDisplay(value)` - форматирование AGR
   - Функция `recalculateAGR(allCoins, CMD, medianDIN)` - пересчет AGR для всех монет
   - **ВАЖНО**: AGR - это конечный показатель пригодности монеты к торговле (в разных масштабах и размерностях для разных математических моделей)
   - **ВАЖНО**: AGR использует CDH, CMD, CGR, CPT, DIN, medianDIN
   - Экспортировать через `window.mmMedianAGR`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateAGR()` в `ui/api/coins-manager.js`
   - Вызывать после расчета DIN и вычисления medianDIN
   - Сохранять результаты:
     - `coin.AGR` (числовое значение)
     - `coin.AGR_formatted` (отформатированная строка)

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmMedianAGR.calculateAGR({...}, 10, 5)` с объектом монеты
- Должен вернуть объект `{raw: number, formatted: string}`
- Проверить объект монеты: должен содержать `AGR` и `AGR_formatted`

**Следующий элемент интерфейса для проверки**: Добавить колонку "AGR" в таблицу монет, добавить сортировку по AGR

---

### Этап 8: MDN (Market Direction Now)

**Цель**: Мигрировать расчет прогноза направления рынка

**Шаги**:
1. Создать файл `mm/median/metrics/mdn.js`:
   - Функция `calculateMDN(hours, allCoins, marketIndicators)` - расчет MDN для заданного горизонта
   - **ВАЖНО**: MDN независим от пользовательского горизонта прогноза (horizonDays)
   - **ВАЖНО**: Использует фиксированные временные окна для разных горизонтов (4h, 8h, 12h)
   - Экспортировать через `window.mmMedianMDN`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateMDN()` в `ui/api/coins-manager.js`
   - Вызывать после расчета всех метрик
   - Сохранять результаты в глобальной переменной или отдельном объекте

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmMedianMDN.calculateMDN(8, [...], {...})` для горизонта 8 часов
- Должен вернуть целое число от -100 до 100
- Проверить значения для всех горизонтов (4h, 8h, 12h)

**Следующий элемент интерфейса для проверки**: Добавить инфобокс с отображением MDN для всех горизонтов (4h, 8h, 12h)

---

### Этап 9: Медианы и сегментированный анализ

**Цель**: Мигрировать расчет медианных значений и сегментированного анализа

**Шаги**:
1. Создать файл `mm/median/metrics/medians.js`:
   - Функция `calculateAllMedians(allCoins, CMD)` - расчет всех медиан
   - Функция `calculateSegmentedMedians(allCoins, getValue)` - сегментированный анализ
   - Экспортировать через `window.mmMedianMedians`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateMedians()` в `ui/api/coins-manager.js`
   - Вызывать после расчета всех метрик
   - Сохранять результаты для отображения в инфобоксе

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmMedianMedians.calculateAllMedians([...], 10)`
- Должен вернуть объект с медианами и сегментами
- Проверить значения: `medianCD`, `medianCDH`, `medianCGR`, `medianAGR`

**Следующий элемент интерфейса для проверки**: Добавить инфобокс с отображением всех медиан и соотношений (CD, CDH, CGR, AGR)

---

### Этап 10: Главная функция пересчета

**Цель**: Создать главную функцию пересчета всех метрик

**Шаги**:
1. Создать файл `mm/median/core/recalculate-all.js`:
   - Функция `recalculateAllDerivedMath(allCoins, horizonDays, marketIndicators)` - главная функция пересчета
   - Последовательность вызовов:
     1. PRC Weights
     2. PV1h Clip
     3. CPT для каждой монеты
     4. CD для каждой монеты
     5. CMD (для всех монет)
     6. CGR для каждой монеты
     7. DIN для всех монет
     8. medianDIN
     9. AGR для всех монет (конечный показатель пригодности)
     10. MDN (опционально)
     11. Медианы
   - Экспортировать через `window.mmMedianRecalculate`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `recalculateAllMetrics()` в `ui/api/coins-manager.js`
   - Вызывать при обновлении данных монет или изменении горизонта прогноза
   - Обеспечить реактивность Vue для обновления интерфейса

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmMedianRecalculate.recalculateAllDerivedMath([...], 7, {...})`
- Проверить, что все метрики рассчитаны для всех монет
- Проверить производительность (время выполнения)

**Следующий элемент интерфейса для проверки**: Полная таблица монет со всеми метриками (CPT, CD, CDH, CGR, DIN, AGR)

---

### Этап 11: UI - Таблицы и отображение метрик

**Цель**: Создать интерфейс для отображения всех метрик

**Шаги**:
1. Создать компонент таблицы метрик:
   - Базовые колонки: Тикер, PV (1h, 24h, 7d, 14d, 30d, 200d)
   - Производные колонки: CPT, CD1..CD6, CDH, CGR2..CGR6, CGR, DIN, AGR
   - Сортировка по каждой колонке
2. Создать инфобокс с медианами:
   - Медианы: CD, CDH, CGR, AGR
   - Соотношения: CD, CDH, CGR, AGR
   - MDN для горизонтов: 4h, 8h, 12h
3. Создать настройки горизонта прогноза:
   - Поле ввода для `horizonDays` (1-90 дней)
   - Автоматический пересчет при изменении

**Проверка**:
- Открыть приложение
- Проверить отображение всех метрик в таблице
- Проверить корректность сортировки
- Проверить обновление при изменении горизонта прогноза

**Следующий элемент интерфейса для проверки**: Полный интерфейс с таблицами, инфобоксом и настройками

---

### Этап 12: Тестирование и валидация

**Цель**: Проверить корректность расчетов и сравнить со старым приложением

**Шаги**:
1. Создать тестовые данные:
   - Набор монет с известными значениями PV
   - Сравнить результаты расчетов со старым приложением
2. Валидация метрик:
   - Проверить диапазоны значений (CPT, CD, CGR, DIN, AGR, MDN)
   - Проверить корректность форматирования
   - Проверить обработку граничных случаев (null, undefined, 0)
3. Производительность:
   - Измерить время расчета для разного количества монет
   - Оптимизировать при необходимости

**Проверка**:
- Загрузить одинаковые данные в старое и новое приложение
- Сравнить результаты расчетов (допустимые отклонения из-за новых интервалов)
- Проверить производительность на большом количестве монет (100+)

**Следующий элемент интерфейса для проверки**: Полное тестирование всех функций интерфейса

---

## Проблемы и решения миграции

### Проблема 1: Изменение интервалов времени

**Описание**: Интервалы изменились с `[1h, 24h, 7d, 30d, 60d, 90d]` на `[1h, 24h, 7d, 14d, 30d, 200d]`

**Влияние**:
- Индекс `pvs[3]`: было 30d → стало 14d
- Индекс `pvs[4]`: было 60d → стало 30d
- Индекс `pvs[5]`: было 90d → стало 200d

**Требуемые изменения**:
- Обновить `timeFramesDays`: `[1/24, 1, 7, 14, 30, 200]` ✅ Выполнено
- Пересмотреть веса в `computeEnhancedCPT` (baseW для новых интервалов) ✅ Выполнено
- Пересмотреть веса в `computeWeightedCGR` (betas для новых интервалов) - будет выполнено на Этапе 5
- Пересмотреть пороги и коэффициенты в MDN (momentumThreshold, trendThreshold) - будет выполнено на Этапе 8
- Адаптировать интерполяцию CDH под новые временные узлы - будет выполнено на Этапе 3

**Статус**: ⚠️ Требует анализа и пересмотра

---

### Проблема 2: Зависимость от рыночных индикаторов

**Описание**: DIN и MDN зависят от рыночных индикаторов (FGI, VIX, BTC Dom, OI, FR, LSR)

**Решение**:
- Использовать существующий модуль `core/api/market-metrics.js`
- Обеспечить доступность индикаторов перед расчетом DIN и MDN
- Обработать случаи недоступности индикаторов (например, VIX)

**Статус**: ✅ Решение найдено

---

### Проблема 3: Корреляция с BTC

**Описание**: DIN использует корреляцию монеты с BTC для адаптации веса BTC-индикаторов

**Решение**:
- Найти BTC в массиве монет по тикеру 'BTC' или 'BTCUSDT'
- Вычислить упрощенную корреляцию по знакам направлений
- Применить адаптацию веса marketFactor в зависимости от корреляции

**Статус**: ⚠️ Требует реализации

---

### Проблема 4: Независимость MDN от пользовательского горизонта

**Описание**: MDN должен быть независим от пользовательского горизонта прогноза (horizonDays)

**Решение**:
- MDN использует фиксированные временные окна для разных горизонтов (4h, 8h, 12h)
- CGR для MDN вычисляется с фиксированным горизонтом 2 дня
- CD1 и CD2 - фиксированные интервалы (1 час и 24 часа)

**Статус**: ⚠️ Требует внимательной реализации

---

## Заметки для разработки

### Порядок расчета метрик

1. **Исходные данные**: PV (уже трансформированы в `pvs`)
2. **PRC Weights**: На основе `horizonDays`
3. **PV1h Clip**: Порог клиппинга для сглаживания
4. **CPT**: Для каждой монеты
5. **CD**: Для каждой монеты (сырые и взвешенные)
6. **CDH**: Для каждой монеты (интерполяция CD)
7. **CMD**: Для всех монет (медианный фон рынка)
8. **CGR**: Для каждой монеты (градиент)
9. **DIN**: Для всех монет (дивергенция, требует CMD и рыночные индикаторы)
10. **medianDIN**: Медиана всех DIN
11. **AGR**: Для всех монет (требует CDH, CMD, CGR, CPT, DIN, medianDIN)
12. **MDN**: Для всех горизонтов (4h, 8h, 12h)
13. **Медианы**: Для всех метрик

### Структура файлов математической модели

**ВАЖНО**: В приложении будет несколько математических моделей (в отличие от старого приложения, где была только одна). Каждая модель имеет свою папку с подпапками `utils/`, `core/`, `metrics/`.

**Текущая модель**: "median" - модель расчета AGR по медианам (из старого приложения)

```
mm/
└── median/                    # Модель расчета AGR по медианам
    ├── utils/
    │   └── math-helpers.js       # Базовые математические утилиты
    ├── core/
    │   ├── prc-weights.js         # PRC-веса
    │   ├── pv1h-clip.js          # Клиппинг PV1h
    │   └── recalculate-all.js    # Главная функция пересчета
    └── metrics/
        ├── cpt.js                 # Coin Potential
        ├── cd.js                  # Cumulative Delta
        ├── cmd.js                 # Composite Market Delta
        ├── cgr.js                 # Coin Gradient
        ├── din.js                 # Divergence Index
        ├── agr.js                 # Aggregated Score (конечный показатель пригодности)
        ├── mdn.js                 # Market Direction Now
        └── medians.js             # Медианы и сегментированный анализ
```

**Примечание**: В будущем могут быть добавлены другие модели (например, `mm/momentum/`, `mm/trend/` и т.д.), каждая со своей структурой и логикой расчета AGR.

### Интеграция с Vue компонентом

Все функции математической модели "median" должны быть доступны через `window.mmMedian*` для использования в Vue компонентах. Компонент `ui/api/coins-manager.js` будет вызывать эти функции и сохранять результаты в реактивные свойства Vue.

**Примечание**: В будущем, при добавлении других математических моделей, каждая модель будет иметь свой префикс (например, `window.mmMomentum*`, `window.mmTrend*` и т.д.).

---

## История изменений

- **2025-12-11**: Создан план миграции, завершен Этап 0 (трансформация данных CoinGecko)
- **2025-12-11**: Завершен Этап 1 (утилиты и базовые функции):
  - Создан `mm/median/utils/math-helpers.js` с базовыми утилитами (clamp, safeNumber, tanh, median)
  - Создан `mm/median/core/prc-weights.js` с функцией `computePRCWeights` и обновленными `timeFramesDays` для новых интервалов
  - Создан `mm/median/core/pv1h-clip.js` с функциями `computePV1hClipThreshold` и `smoothPV1h`
  - Все файлы подключены в `index.html` в правильном порядке
- **2025-12-11**: Завершен Этап 2 (CPT - Coin Potential):
  - Создан `mm/median/metrics/cpt.js` с функциями `computeEnhancedCPT` и `formatEnhancedCPT`
  - Адаптированы базовые веса `baseW` для новых интервалов CoinGecko (14d, 200d вместо 60d, 90d)
  - Интегрирован расчет CPT в компонент CoinGecko (метод `calculateCPT`)
  - CPT рассчитывается при обновлении данных монет и при загрузке из localStorage
  - Создана вкладка "Комплексные дельты" с заглушками для визуализации данных

---

## Осознанные расхождения со старым функционалом

> **ВАЖНО**: Этот раздел документирует намеренные изменения в поведении нового приложения по сравнению со старым. Все расхождения основаны на осознанном выборе и обоснованы.

### Отображение CD в таблице

**Старое приложение**:
- CD1-CD6: отображались **сырые** значения (`cd1`..`cd6`)
- CDH: отображалось **взвешенное** значение (`cdhw`)

**Новое приложение**:
- CD1-CD6: отображаются **взвешенные** значения (`cd1w`..`cd6w`)
- CDH: отображается **взвешенное** значение (`cdhw`)
- **Сырые значения** доступны в tooltip при наведении

**Обоснование**:
- Взвешенные значения используются в расчете AGR (более важны для анализа)
- Учитывают важность временных интервалов через PRC-веса
- Согласованы с отображением в портфолио (где использовались взвешенные с fallback на сырые)
- Сырые значения остаются доступными через tooltip для детального анализа

**Дата внесения**: 2025-12-14  
**Связанные файлы**: `ui/api/coins-manager.js` (методы `getCD()`, `getCDValue()`, `getCDTooltip()`), `mm/median.md` (раздел "Особенности реализации")

---

*Документ обновляется по мере прогресса миграции*

