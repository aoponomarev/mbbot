# План миграции математической модели

> **ВАЖНО**: Этот документ описывает процесс миграции математической модели из старого приложения (`old_app_not_write/`) в новое приложение. Документ обновляется по мере прогресса миграции.

> **Связь с правилами**: См. раздел "Работа с папкой old_app_not_write" в `.cursorrules` и раздел "Проблемы миграции" в `architect.md`.

## Текущий статус миграции

**Дата начала**: 2025-12-11  
**Текущий этап**: Подготовка - трансформация данных CoinGecko в формат со старыми переменными  
**Прогресс**: ✅ Завершено - данные CoinGecko трансформируются в формат `pvs` (PV1h, PV24h, PV7d, PV14d, PV30d, PV200d)

## Обзор математической модели

### Иерархия метрик (от исходных данных к финальным индексам)

```
PV (Price Variations) [1h, 24h, 7d, 14d, 30d, 200d]
  ↓
PRC Weights (Proximity Relevance Coefficients)
  ↓
┌─────────────────┬─────────────────┬─────────────────┐
│                 │                 │                 │
CPT              CD                CGR
(Coin Potential) (Cumulative Delta) (Coin Gradient)
│                 │                 │
│                 ↓                 │
│              CDH                 │
│         (CD на горизонте)        │
│                 │                 │
│                 ↓                 │
│              CMD                 │
│    (Composite Market Delta)      │
│                 │                 │
└─────────────────┼─────────────────┴─────────────────┘
                  │
                  ↓
                DIN
         (Divergence Index)
                  │
                  ↓
                AGR
      (Aggregated Score - A.I.R.)
                  │
                  ↓
                MDN
    (Market Direction Now)
```

### Ключевые зависимости

1. **Исходные данные**: PV (Price Variations) - массив из 6 элементов
2. **Базовые производные**: PRC Weights, PV1h Clip, CPT, CD, CDH
3. **Рыночные производные**: CMD (медианный фон рынка)
4. **Индивидуальные производные**: CGR, DIN
5. **Агрегированные метрики**: AGR, MDN

### Важные изменения интервалов

**Старое приложение**: `[1h, 24h, 7d, 30d, 60d, 90d]`  
**Новое приложение**: `[1h, 24h, 7d, 14d, 30d, 200d]`

**Изменения**:
- `pvs[3]`: было 30d → стало 14d (НОВЫЙ интервал)
- `pvs[4]`: было 60d → стало 30d (сдвинут с индекса 3)
- `pvs[5]`: было 90d → стало 200d (НОВЫЙ интервал, заменяет 60d и 90d)

**⚠️ ВАЖНО**: Замененные интервалы потребуют анализа и пересмотра весов и коэффициентов в математической модели (см. предостережение в `.cursorrules`).

## Пошаговый план миграции

### Этап 0: Подготовка данных ✅ ЗАВЕРШЕНО

**Цель**: Обеспечить преемственность переменных и структуры данных

**Шаги**:
1. ✅ Создать функцию `transformCoinGeckoToPV()` для трансформации данных CoinGecko
2. ✅ Применить трансформацию во всех местах получения данных от CoinGecko API
3. ✅ Обеспечить обратную совместимость при загрузке из localStorage

**Проверка**:
- Открыть DevTools → Console
- Проверить объект монеты: должен содержать `pvs`, `PV1h`, `PV24h`, `PV7d`, `PV14d`, `PV30d`, `PV200d`
- Проверить массив `pvs`: должен содержать 6 элементов (числа)

**Следующий элемент интерфейса для проверки**: Таблица монет должна отображать данные без ошибок

---

### Этап 1: Утилиты и базовые функции

**Цель**: Мигрировать базовые математические утилиты и функции расчета PRC-весов

**Шаги**:
1. Создать файл `mm/utils/math-helpers.js` с утилитами:
   - `clamp(x, min, max)` - ограничение значения в диапазоне
   - `safeNumber(x, def)` - безопасное преобразование в число
   - `tanh(x)` - гиперболический тангенс
   - `median(arr)` - вычисление медианы массива
2. Создать файл `mm/core/prc-weights.js`:
   - Функция `computePRCWeights(hDays)` - расчет PRC-весов
   - Обновить `timeFramesDays` для новых интервалов: `[1/24, 1, 7, 14, 30, 200]`
   - Экспортировать через `window.mmPRCWeights`
3. Создать файл `mm/core/pv1h-clip.js`:
   - Функция `computePV1hClipThreshold(coins)` - расчет порога клиппинга
   - Функция `smoothPV1h(pv1h)` - сглаживание PV1h
   - Экспортировать через `window.mmPV1hClip`

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmPRCWeights.computePRCWeights(7)` - должен вернуть массив из 6 весов
- Проверить, что сумма весов ≈ 1.0
- Вызвать `window.mmPV1hClip.computePV1hClipThreshold([...])` - должен вернуть число

**Следующий элемент интерфейса для проверки**: Добавить отладочную панель с отображением PRC-весов для текущего горизонта прогноза

---

### Этап 2: CPT (Coin Potential)

**Цель**: Мигрировать расчет потенциала монеты

**Шаги**:
1. Создать файл `mm/metrics/cpt.js`:
   - Функция `computeEnhancedCPT(values, hDays)` - расчет CPT
   - Функция `formatEnhancedCPT(value)` - форматирование CPT
   - **ВАЖНО**: Адаптировать базовые веса `baseW` для новых интервалов (14d, 200d вместо 60d, 90d)
   - Экспортировать через `window.mmCPT`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateCPT()` в `ui/api/coingecko.js`
   - Вызывать при обновлении данных монет
   - Сохранять результат в `coin.enhancedCpt` и `coin.enhancedCptFormatted`

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmCPT.computeEnhancedCPT([1, 2, 3, 4, 5, 6], 7)` - должен вернуть число
- Проверить объект монеты: должен содержать `enhancedCpt` и `enhancedCptFormatted`

**Следующий элемент интерфейса для проверки**: Добавить колонку "CPT" в таблицу монет с отображением `enhancedCptFormatted`

---

### Этап 3: CD (Cumulative Delta)

**Цель**: Мигрировать расчет накопительной дельты

**Шаги**:
1. Создать файл `mm/metrics/cd.js`:
   - Функция `calculateCDsWeighted(pvs, prcWeights)` - расчет CD (сырых и взвешенных)
   - Функция `approximateCDHFromSeries(series, hDays)` - аппроксимация CDH
   - Экспортировать через `window.mmCD`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateCD()` в `ui/api/coingecko.js`
   - Вызывать после расчета CPT
   - Сохранять результаты:
     - `coin.cd1`..`coin.cd6` (сырые CD)
     - `coin.cd1w`..`coin.cd6w` (взвешенные CD)
     - `coin.cdh` (CDH сырое)
     - `coin.cdhw` (CDH взвешенное)

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmCD.calculateCDsWeighted([1, 2, 3, 4, 5, 6], [0.1, 0.2, 0.3, 0.2, 0.15, 0.05])`
- Должен вернуть объект `{cdRaw: [...], cdW: [...]}` с массивами из 6 элементов
- Проверить объект монеты: должен содержать `cd1`..`cd6`, `cd1w`..`cd6w`, `cdh`, `cdhw`

**Следующий элемент интерфейса для проверки**: Добавить колонки "CD1".."CD6" и "CDH" в таблицу монет

---

### Этап 4: CMD (Composite Market Delta)

**Цель**: Мигрировать расчет медианного фона рынка

**Шаги**:
1. Создать файл `mm/metrics/cmd.js`:
   - Функция `computeMDVectors(allCoins)` - расчет медианных PV по каждому временному узлу
   - Функция `computeCMDLevels(md, prcWeights)` - расчет уровней CMD
   - Экспортировать через `window.mmCMD`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateCMD()` в `ui/api/coingecko.js`
   - Вызывать после расчета CD для всех монет
   - Сохранять результат в `window.__CMDH__` (для использования в AGR)

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmCMD.computeMDVectors([...])` с массивом монет
- Должен вернуть массив из 6 медианных PV
- Проверить `window.__CMDH__` - должно быть число (CDH от медианных PV)

**Следующий элемент интерфейса для проверки**: Добавить инфобокс с отображением CMD (медианный фон рынка)

---

### Этап 5: CGR (Coin Gradient)

**Цель**: Мигрировать расчет градиента монеты

**Шаги**:
1. Создать файл `mm/metrics/cgr.js`:
   - Функция `computeCGR(values, hDays)` - расчет CGR (углы и наклоны)
   - Функция `computeWeightedCGR(angles, slopes, hDays)` - агрегация CGR2..CGR6
   - **ВАЖНО**: Адаптировать индексы для новых интервалов (pvs[3] теперь 14d, pvs[4] - 30d, pvs[5] - 200d)
   - Экспортировать через `window.mmCGR`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateCGR()` в `ui/api/coingecko.js`
   - Вызывать после расчета CD
   - Сохранять результаты:
     - `coin.cgr2`..`coin.cgr6` (градусы)
     - `coin.cgrDeg` (агрегированные градусы)
     - `coin.cgrSlope` (агрегированный наклон)

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmCGR.computeCGR([1, 2, 3, 4, 5, 6], 7)`
- Должен вернуть объект `{angles: [...], slopes: [...]}` с массивами из 5 элементов
- Проверить объект монеты: должен содержать `cgr2`..`cgr6`, `cgrDeg`, `cgrSlope`

**Следующий элемент интерфейса для проверки**: Добавить колонки "CGR2".."CGR6" и "CGR" в таблицу монет

---

### Этап 6: DIN (Divergence Index)

**Цель**: Мигрировать расчет индекса дивергенции

**Шаги**:
1. Создать файл `mm/metrics/din.js`:
   - Функция `calculateSimpleCorrelation(pvs1, pvs2)` - упрощенная корреляция по знакам
   - Функция `computeDivergenceIndices(allCoins, horizonDays, marketIndicators)` - расчет DIN для всех монет
   - **ВАЖНО**: Использовать рыночные индикаторы из `core/api/market-metrics.js`
   - Экспортировать через `window.mmDIN`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateDIN()` в `ui/api/coingecko.js`
   - Вызывать после расчета CMD и CGR
   - Сохранять результаты:
     - `coin.divergenceIndex` (сырой индекс)
     - `coin.divergenceAbs` (абсолютное значение для рейтингов)
     - `coin.btcCorrelation` (корреляция с BTC, если применимо)

**Проверка**:
- Открыть DevTools → Console
- Проверить, что рыночные индикаторы доступны (FGI, VIX, BTC Dom, OI, FR, LSR)
- Вызвать `window.mmDIN.computeDivergenceIndices([...], 7, {...})`
- Проверить объект монеты: должен содержать `divergenceIndex`, `divergenceAbs`

**Следующий элемент интерфейса для проверки**: Добавить колонку "DIN" в таблицу монет

---

### Этап 7: AGR (Aggregated Score)

**Цель**: Мигрировать расчет комплексного скора монеты

**Шаги**:
1. Создать файл `mm/metrics/agr.js`:
   - Функция `calculateAGR(coin, CMD, medianDIN)` - базовый расчет AGR (A.I.R. модель)
   - Функция `formatAGRForDisplay(value)` - форматирование AGR
   - Функция `recalculateAGR(allCoins, CMD, medianDIN)` - пересчет AGR для всех монет
   - **ВАЖНО**: AGR использует CDH, CMD, CGR, CPT, DIN, medianDIN
   - Экспортировать через `window.mmAGR`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateAGR()` в `ui/api/coingecko.js`
   - Вызывать после расчета DIN и вычисления medianDIN
   - Сохранять результаты:
     - `coin.AGR` (числовое значение)
     - `coin.AGR_formatted` (отформатированная строка)

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmAGR.calculateAGR({...}, 10, 5)` с объектом монеты
- Должен вернуть объект `{raw: number, formatted: string}`
- Проверить объект монеты: должен содержать `AGR` и `AGR_formatted`

**Следующий элемент интерфейса для проверки**: Добавить колонку "AGR" в таблицу монет, добавить сортировку по AGR

---

### Этап 8: MDN (Market Direction Now)

**Цель**: Мигрировать расчет прогноза направления рынка

**Шаги**:
1. Создать файл `mm/metrics/mdn.js`:
   - Функция `calculateMDN(hours, allCoins, marketIndicators)` - расчет MDN для заданного горизонта
   - **ВАЖНО**: MDN независим от пользовательского горизонта прогноза (horizonDays)
   - **ВАЖНО**: Использует фиксированные временные окна для разных горизонтов (4h, 8h, 12h)
   - Экспортировать через `window.mmMDN`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateMDN()` в `ui/api/coingecko.js`
   - Вызывать после расчета всех метрик
   - Сохранять результаты в глобальной переменной или отдельном объекте

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmMDN.calculateMDN(8, [...], {...})` для горизонта 8 часов
- Должен вернуть целое число от -100 до 100
- Проверить значения для всех горизонтов (4h, 8h, 12h)

**Следующий элемент интерфейса для проверки**: Добавить инфобокс с отображением MDN для всех горизонтов (4h, 8h, 12h)

---

### Этап 9: Медианы и сегментированный анализ

**Цель**: Мигрировать расчет медианных значений и сегментированного анализа

**Шаги**:
1. Создать файл `mm/metrics/medians.js`:
   - Функция `calculateAllMedians(allCoins, CMD)` - расчет всех медиан
   - Функция `calculateSegmentedMedians(allCoins, getValue)` - сегментированный анализ
   - Экспортировать через `window.mmMedians`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `calculateMedians()` в `ui/api/coingecko.js`
   - Вызывать после расчета всех метрик
   - Сохранять результаты для отображения в инфобоксе

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmMedians.calculateAllMedians([...], 10)`
- Должен вернуть объект с медианами и сегментами
- Проверить значения: `medianCD`, `medianCDH`, `medianCGR`, `medianAGR`

**Следующий элемент интерфейса для проверки**: Добавить инфобокс с отображением всех медиан и соотношений (CD, CDH, CGR, AGR)

---

### Этап 10: Главная функция пересчета

**Цель**: Создать главную функцию пересчета всех метрик

**Шаги**:
1. Создать файл `mm/core/recalculate-all.js`:
   - Функция `recalculateAllDerivedMath(allCoins, horizonDays, marketIndicators)` - главная функция пересчета
   - Последовательность вызовов:
     1. PRC Weights
     2. PV1h Clip
     3. CPT для каждой монеты
     4. CD для каждой монеты
     5. CMD (для всех монет)
     6. CGR для каждой монеты
     7. DIN для всех монет
     8. medianDIN
     9. AGR для всех монет
     10. MDN (опционально)
     11. Медианы
   - Экспортировать через `window.mmRecalculate`
2. Интегрировать в компонент CoinGecko:
   - Добавить метод `recalculateAllMetrics()` в `ui/api/coingecko.js`
   - Вызывать при обновлении данных монет или изменении горизонта прогноза
   - Обеспечить реактивность Vue для обновления интерфейса

**Проверка**:
- Открыть DevTools → Console
- Вызвать `window.mmRecalculate.recalculateAllDerivedMath([...], 7, {...})`
- Проверить, что все метрики рассчитаны для всех монет
- Проверить производительность (время выполнения)

**Следующий элемент интерфейса для проверки**: Полная таблица монет со всеми метриками (CPT, CD, CDH, CGR, DIN, AGR)

---

### Этап 11: UI - Таблицы и отображение метрик

**Цель**: Создать интерфейс для отображения всех метрик

**Шаги**:
1. Создать компонент таблицы метрик:
   - Базовые колонки: Тикер, PV (1h, 24h, 7d, 14d, 30d, 200d)
   - Производные колонки: CPT, CD1..CD6, CDH, CGR2..CGR6, CGR, DIN, AGR
   - Сортировка по каждой колонке
2. Создать инфобокс с медианами:
   - Медианы: CD, CDH, CGR, AGR
   - Соотношения: CD, CDH, CGR, AGR
   - MDN для горизонтов: 4h, 8h, 12h
3. Создать настройки горизонта прогноза:
   - Поле ввода для `horizonDays` (1-90 дней)
   - Автоматический пересчет при изменении

**Проверка**:
- Открыть приложение
- Проверить отображение всех метрик в таблице
- Проверить корректность сортировки
- Проверить обновление при изменении горизонта прогноза

**Следующий элемент интерфейса для проверки**: Полный интерфейс с таблицами, инфобоксом и настройками

---

### Этап 12: Тестирование и валидация

**Цель**: Проверить корректность расчетов и сравнить со старым приложением

**Шаги**:
1. Создать тестовые данные:
   - Набор монет с известными значениями PV
   - Сравнить результаты расчетов со старым приложением
2. Валидация метрик:
   - Проверить диапазоны значений (CPT, CD, CGR, DIN, AGR, MDN)
   - Проверить корректность форматирования
   - Проверить обработку граничных случаев (null, undefined, 0)
3. Производительность:
   - Измерить время расчета для разного количества монет
   - Оптимизировать при необходимости

**Проверка**:
- Загрузить одинаковые данные в старое и новое приложение
- Сравнить результаты расчетов (допустимые отклонения из-за новых интервалов)
- Проверить производительность на большом количестве монет (100+)

**Следующий элемент интерфейса для проверки**: Полное тестирование всех функций интерфейса

---

## Проблемы и решения миграции

### Проблема 1: Изменение интервалов времени

**Описание**: Интервалы изменились с `[1h, 24h, 7d, 30d, 60d, 90d]` на `[1h, 24h, 7d, 14d, 30d, 200d]`

**Влияние**:
- Индекс `pvs[3]`: было 30d → стало 14d
- Индекс `pvs[4]`: было 60d → стало 30d
- Индекс `pvs[5]`: было 90d → стало 200d

**Требуемые изменения**:
- Обновить `timeFramesDays`: `[1/24, 1, 7, 14, 30, 200]`
- Пересмотреть веса в `computeEnhancedCPT` (baseW для новых интервалов)
- Пересмотреть веса в `computeWeightedCGR` (betas для новых интервалов)
- Пересмотреть пороги и коэффициенты в MDN (momentumThreshold, trendThreshold)
- Пересмотреть интерполяцию CDH (использует CD7 и CD30, теперь нужно CD14 и CD30)

**Статус**: ⚠️ Требует анализа и пересмотра

---

### Проблема 2: Зависимость от рыночных индикаторов

**Описание**: DIN и MDN зависят от рыночных индикаторов (FGI, VIX, BTC Dom, OI, FR, LSR)

**Решение**:
- Использовать существующий модуль `core/api/market-metrics.js`
- Обеспечить доступность индикаторов перед расчетом DIN и MDN
- Обработать случаи недоступности индикаторов (например, VIX)

**Статус**: ✅ Решение найдено

---

### Проблема 3: Корреляция с BTC

**Описание**: DIN использует корреляцию монеты с BTC для адаптации веса BTC-индикаторов

**Решение**:
- Найти BTC в массиве монет по тикеру 'BTC' или 'BTCUSDT'
- Вычислить упрощенную корреляцию по знакам направлений
- Применить адаптацию веса marketFactor в зависимости от корреляции

**Статус**: ⚠️ Требует реализации

---

### Проблема 4: Независимость MDN от пользовательского горизонта

**Описание**: MDN должен быть независим от пользовательского горизонта прогноза (horizonDays)

**Решение**:
- MDN использует фиксированные временные окна для разных горизонтов (4h, 8h, 12h)
- CGR для MDN вычисляется с фиксированным горизонтом 2 дня
- CD1 и CD2 - фиксированные интервалы (1 час и 24 часа)

**Статус**: ⚠️ Требует внимательной реализации

---

## Заметки для разработки

### Порядок расчета метрик

1. **Исходные данные**: PV (уже трансформированы в `pvs`)
2. **PRC Weights**: На основе `horizonDays`
3. **PV1h Clip**: Порог клиппинга для сглаживания
4. **CPT**: Для каждой монеты
5. **CD**: Для каждой монеты (сырые и взвешенные)
6. **CDH**: Для каждой монеты (интерполяция CD)
7. **CMD**: Для всех монет (медианный фон рынка)
8. **CGR**: Для каждой монеты (градиент)
9. **DIN**: Для всех монет (дивергенция, требует CMD и рыночные индикаторы)
10. **medianDIN**: Медиана всех DIN
11. **AGR**: Для всех монет (требует CDH, CMD, CGR, CPT, DIN, medianDIN)
12. **MDN**: Для всех горизонтов (4h, 8h, 12h)
13. **Медианы**: Для всех метрик

### Структура файлов математической модели

```
mm/
├── utils/
│   └── math-helpers.js       # Базовые математические утилиты
├── core/
│   ├── prc-weights.js         # PRC-веса
│   ├── pv1h-clip.js          # Клиппинг PV1h
│   └── recalculate-all.js    # Главная функция пересчета
└── metrics/
    ├── cpt.js                 # Coin Potential
    ├── cd.js                  # Cumulative Delta
    ├── cmd.js                 # Composite Market Delta
    ├── cgr.js                 # Coin Gradient
    ├── din.js                 # Divergence Index
    ├── agr.js                 # Aggregated Score
    ├── mdn.js                 # Market Direction Now
    └── medians.js             # Медианы и сегментированный анализ
```

### Интеграция с Vue компонентом

Все функции математической модели должны быть доступны через `window.mm*` для использования в Vue компонентах. Компонент `ui/api/coingecko.js` будет вызывать эти функции и сохранять результаты в реактивные свойства Vue.

---

## История изменений

- **2025-12-11**: Создан план миграции, завершен Этап 0 (трансформация данных CoinGecko)

---

*Документ обновляется по мере прогресса миграции*

